diff '--exclude=testdata' -ur systemd-255-orig/src/basic/cgroup-util.c systemd-255/src/basic/cgroup-util.c
--- systemd-255-orig/src/basic/cgroup-util.c	2024-05-18 13:21:30.906869668 -0700
+++ systemd-255/src/basic/cgroup-util.c	2024-05-18 16:51:10.784751550 -0700
@@ -35,7 +35,6 @@
 #include "string-table.h"
 #include "string-util.h"
 #include "strv.h"
-#include "unit-name.h"
 #include "user-util.h"
 #include "xattr-util.h"
 
@@ -1140,149 +1139,6 @@
         return 0;
 }
 
-int cg_path_decode_unit(const char *cgroup, char **ret_unit) {
-        char *c, *s;
-        size_t n;
-
-        assert(cgroup);
-        assert(ret_unit);
-
-        n = strcspn(cgroup, "/");
-        if (n < 3)
-                return -ENXIO;
-
-        c = strndupa_safe(cgroup, n);
-        c = cg_unescape(c);
-
-        if (!unit_name_is_valid(c, UNIT_NAME_PLAIN|UNIT_NAME_INSTANCE))
-                return -ENXIO;
-
-        s = strdup(c);
-        if (!s)
-                return -ENOMEM;
-
-        *ret_unit = s;
-        return 0;
-}
-
-static bool valid_slice_name(const char *p, size_t n) {
-
-        if (!p)
-                return false;
-
-        if (n < STRLEN("x.slice"))
-                return false;
-
-        if (memcmp(p + n - 6, ".slice", 6) == 0) {
-                char buf[n+1], *c;
-
-                memcpy(buf, p, n);
-                buf[n] = 0;
-
-                c = cg_unescape(buf);
-
-                return unit_name_is_valid(c, UNIT_NAME_PLAIN);
-        }
-
-        return false;
-}
-
-static const char *skip_slices(const char *p) {
-        assert(p);
-
-        /* Skips over all slice assignments */
-
-        for (;;) {
-                size_t n;
-
-                p += strspn(p, "/");
-
-                n = strcspn(p, "/");
-                if (!valid_slice_name(p, n))
-                        return p;
-
-                p += n;
-        }
-}
-
-int cg_path_get_unit(const char *path, char **ret) {
-        _cleanup_free_ char *unit = NULL;
-        const char *e;
-        int r;
-
-        assert(path);
-        assert(ret);
-
-        e = skip_slices(path);
-
-        r = cg_path_decode_unit(e, &unit);
-        if (r < 0)
-                return r;
-
-        /* We skipped over the slices, don't accept any now */
-        if (endswith(unit, ".slice"))
-                return -ENXIO;
-
-        *ret = TAKE_PTR(unit);
-        return 0;
-}
-
-int cg_path_get_unit_path(const char *path, char **ret) {
-        _cleanup_free_ char *path_copy = NULL;
-        char *unit_name;
-
-        assert(path);
-        assert(ret);
-
-        path_copy = strdup(path);
-        if (!path_copy)
-                return -ENOMEM;
-
-        unit_name = (char *)skip_slices(path_copy);
-        unit_name[strcspn(unit_name, "/")] = 0;
-
-        if (!unit_name_is_valid(cg_unescape(unit_name), UNIT_NAME_PLAIN|UNIT_NAME_INSTANCE))
-                return -ENXIO;
-
-        *ret = TAKE_PTR(path_copy);
-
-        return 0;
-}
-
-int cg_pid_get_unit(pid_t pid, char **ret_unit) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        assert(ret_unit);
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_unit(cgroup, ret_unit);
-}
-
-int cg_pidref_get_unit(const PidRef *pidref, char **ret) {
-        _cleanup_free_ char *unit = NULL;
-        int r;
-
-        assert(ret);
-
-        if (!pidref_is_set(pidref))
-                return -ESRCH;
-
-        r = cg_pid_get_unit(pidref->pid, &unit);
-        if (r < 0)
-                return r;
-
-        r = pidref_verify(pidref);
-        if (r < 0)
-                return r;
-
-        *ret = TAKE_PTR(unit);
-        return 0;
-}
-
 /**
  * Skip session-*.scope, but require it to be there.
  */
@@ -1358,77 +1214,6 @@
         return NULL;
 }
 
-static const char *skip_user_prefix(const char *path) {
-        const char *e, *t;
-
-        assert(path);
-
-        /* Skip slices, if there are any */
-        e = skip_slices(path);
-
-        /* Skip the user manager, if it's in the path now... */
-        t = skip_user_manager(e);
-        if (t)
-                return t;
-
-        /* Alternatively skip the user session if it is in the path... */
-        return skip_session(e);
-}
-
-int cg_path_get_user_unit(const char *path, char **ret) {
-        const char *t;
-
-        assert(path);
-        assert(ret);
-
-        t = skip_user_prefix(path);
-        if (!t)
-                return -ENXIO;
-
-        /* And from here on it looks pretty much the same as for a system unit, hence let's use the same
-         * parser. */
-        return cg_path_get_unit(t, ret);
-}
-
-int cg_pid_get_user_unit(pid_t pid, char **ret_unit) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        assert(ret_unit);
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_user_unit(cgroup, ret_unit);
-}
-
-int cg_path_get_machine_name(const char *path, char **ret_machine) {
-        _cleanup_free_ char *u = NULL;
-        const char *sl;
-        int r;
-
-        r = cg_path_get_unit(path, &u);
-        if (r < 0)
-                return r;
-
-        sl = strjoina("/run/systemd/machines/unit:", u);
-        return readlink_malloc(sl, ret_machine);
-}
-
-int cg_pid_get_machine_name(pid_t pid, char **ret_machine) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        assert(ret_machine);
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_machine_name(cgroup, ret_machine);
-}
-
 int cg_path_get_cgroupid(const char *path, uint64_t *ret) {
         cg_file_handle fh = CG_FILE_HANDLE_INIT;
         int mnt_id = -1;
@@ -1445,165 +1230,6 @@
         return 0;
 }
 
-int cg_path_get_session(const char *path, char **ret_session) {
-        _cleanup_free_ char *unit = NULL;
-        char *start, *end;
-        int r;
-
-        assert(path);
-
-        r = cg_path_get_unit(path, &unit);
-        if (r < 0)
-                return r;
-
-        start = startswith(unit, "session-");
-        if (!start)
-                return -ENXIO;
-        end = endswith(start, ".scope");
-        if (!end)
-                return -ENXIO;
-
-        *end = 0;
-        if (!session_id_valid(start))
-                return -ENXIO;
-
-        if (ret_session) {
-                char *rr;
-
-                rr = strdup(start);
-                if (!rr)
-                        return -ENOMEM;
-
-                *ret_session = rr;
-        }
-
-        return 0;
-}
-
-int cg_pid_get_session(pid_t pid, char **ret_session) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_session(cgroup, ret_session);
-}
-
-int cg_path_get_owner_uid(const char *path, uid_t *ret_uid) {
-        _cleanup_free_ char *slice = NULL;
-        char *start, *end;
-        int r;
-
-        assert(path);
-
-        r = cg_path_get_slice(path, &slice);
-        if (r < 0)
-                return r;
-
-        start = startswith(slice, "user-");
-        if (!start)
-                return -ENXIO;
-
-        end = endswith(start, ".slice");
-        if (!end)
-                return -ENXIO;
-
-        *end = 0;
-        if (parse_uid(start, ret_uid) < 0)
-                return -ENXIO;
-
-        return 0;
-}
-
-int cg_pid_get_owner_uid(pid_t pid, uid_t *ret_uid) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_owner_uid(cgroup, ret_uid);
-}
-
-int cg_path_get_slice(const char *p, char **ret_slice) {
-        const char *e = NULL;
-
-        assert(p);
-        assert(ret_slice);
-
-        /* Finds the right-most slice unit from the beginning, but
-         * stops before we come to the first non-slice unit. */
-
-        for (;;) {
-                size_t n;
-
-                p += strspn(p, "/");
-
-                n = strcspn(p, "/");
-                if (!valid_slice_name(p, n)) {
-
-                        if (!e) {
-                                char *s;
-
-                                s = strdup(SPECIAL_ROOT_SLICE);
-                                if (!s)
-                                        return -ENOMEM;
-
-                                *ret_slice = s;
-                                return 0;
-                        }
-
-                        return cg_path_decode_unit(e, ret_slice);
-                }
-
-                e = p;
-                p += n;
-        }
-}
-
-int cg_pid_get_slice(pid_t pid, char **ret_slice) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        assert(ret_slice);
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_slice(cgroup, ret_slice);
-}
-
-int cg_path_get_user_slice(const char *p, char **ret_slice) {
-        const char *t;
-        assert(p);
-        assert(ret_slice);
-
-        t = skip_user_prefix(p);
-        if (!t)
-                return -ENXIO;
-
-        /* And now it looks pretty much the same as for a system slice, so let's just use the same parser
-         * from here on. */
-        return cg_path_get_slice(t, ret_slice);
-}
-
-int cg_pid_get_user_slice(pid_t pid, char **ret_slice) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        assert(ret_slice);
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_user_slice(cgroup, ret_slice);
-}
-
 bool cg_needs_escape(const char *p) {
 
         /* Checks if the specified path is a valid cgroup name by our rules, or if it must be escaped. Note
@@ -1706,81 +1332,6 @@
         return true;
 }
 
-int cg_slice_to_path(const char *unit, char **ret) {
-        _cleanup_free_ char *p = NULL, *s = NULL, *e = NULL;
-        const char *dash;
-        int r;
-
-        assert(unit);
-        assert(ret);
-
-        if (streq(unit, SPECIAL_ROOT_SLICE)) {
-                char *x;
-
-                x = strdup("");
-                if (!x)
-                        return -ENOMEM;
-                *ret = x;
-                return 0;
-        }
-
-        if (!unit_name_is_valid(unit, UNIT_NAME_PLAIN))
-                return -EINVAL;
-
-        if (!endswith(unit, ".slice"))
-                return -EINVAL;
-
-        r = unit_name_to_prefix(unit, &p);
-        if (r < 0)
-                return r;
-
-        dash = strchr(p, '-');
-
-        /* Don't allow initial dashes */
-        if (dash == p)
-                return -EINVAL;
-
-        while (dash) {
-                _cleanup_free_ char *escaped = NULL;
-                char n[dash - p + sizeof(".slice")];
-
-#if HAS_FEATURE_MEMORY_SANITIZER
-                /* msan doesn't instrument stpncpy, so it thinks
-                 * n is later used uninitialized:
-                 * https://github.com/google/sanitizers/issues/926
-                 */
-                zero(n);
-#endif
-
-                /* Don't allow trailing or double dashes */
-                if (IN_SET(dash[1], 0, '-'))
-                        return -EINVAL;
-
-                strcpy(stpncpy(n, p, dash - p), ".slice");
-                if (!unit_name_is_valid(n, UNIT_NAME_PLAIN))
-                        return -EINVAL;
-
-                r = cg_escape(n, &escaped);
-                if (r < 0)
-                        return r;
-
-                if (!strextend(&s, escaped, "/"))
-                        return -ENOMEM;
-
-                dash = strchr(dash+1, '-');
-        }
-
-        r = cg_escape(unit, &e);
-        if (r < 0)
-                return r;
-
-        if (!strextend(&s, e))
-                return -ENOMEM;
-
-        *ret = TAKE_PTR(s);
-        return 0;
-}
-
 int cg_is_threaded(const char *path) {
         _cleanup_free_ char *fs = NULL, *contents = NULL;
         _cleanup_strv_free_ char **v = NULL;
diff '--exclude=testdata' -ur systemd-255-orig/src/basic/glob-util.c systemd-255/src/basic/glob-util.c
--- systemd-255-orig/src/basic/glob-util.c	2024-05-18 13:21:30.910869411 -0700
+++ systemd-255/src/basic/glob-util.c	2024-05-18 14:04:00.989120300 -0700
@@ -19,22 +19,8 @@
 int safe_glob(const char *path, int flags, glob_t *pglob) {
         int k;
 
-        /* We want to set GLOB_ALTDIRFUNC ourselves, don't allow it to be set. */
-        assert(!(flags & GLOB_ALTDIRFUNC));
-
-        if (!pglob->gl_closedir)
-                pglob->gl_closedir = closedir_wrapper;
-        if (!pglob->gl_readdir)
-                pglob->gl_readdir = (struct dirent *(*)(void *)) readdir_no_dot;
-        if (!pglob->gl_opendir)
-                pglob->gl_opendir = (void *(*)(const char *)) opendir;
-        if (!pglob->gl_lstat)
-                pglob->gl_lstat = lstat;
-        if (!pglob->gl_stat)
-                pglob->gl_stat = stat;
-
         errno = 0;
-        k = glob(path, flags | GLOB_ALTDIRFUNC, NULL, pglob);
+        k = glob(path, flags, NULL, pglob);
         if (k == GLOB_NOMATCH)
                 return -ENOENT;
         if (k == GLOB_NOSPACE)
@@ -53,7 +39,7 @@
 
         assert(path);
 
-        k = safe_glob(path, GLOB_NOSORT|GLOB_BRACE, &g);
+        k = safe_glob(path, GLOB_NOSORT, &g);
         if (k == -ENOENT) {
                 if (ret_first)
                         *ret_first = NULL;
@@ -78,7 +64,7 @@
         _cleanup_globfree_ glob_t g = {};
         int k;
 
-        k = safe_glob(path, GLOB_NOSORT|GLOB_BRACE|flags, &g);
+        k = safe_glob(path, GLOB_NOSORT|flags, &g);
         if (k < 0)
                 return k;
 
diff '--exclude=testdata' -ur systemd-255-orig/src/basic/linux/if.h systemd-255/src/basic/linux/if.h
--- systemd-255-orig/src/basic/linux/if.h	2024-05-18 13:21:30.910869411 -0700
+++ systemd-255/src/basic/linux/if.h	2024-05-18 14:05:51.326935610 -0700
@@ -132,9 +132,6 @@
 #define IFF_ECHO			IFF_ECHO
 #endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO */
 
-#define IFF_VOLATILE	(IFF_LOOPBACK|IFF_POINTOPOINT|IFF_BROADCAST|IFF_ECHO|\
-		IFF_MASTER|IFF_SLAVE|IFF_RUNNING|IFF_LOWER_UP|IFF_DORMANT)
-
 #define IF_GET_IFACE	0x0001		/* for querying only */
 #define IF_GET_PROTO	0x0002
 
diff '--exclude=testdata' -ur systemd-255-orig/src/basic/mountpoint-util.c systemd-255/src/basic/mountpoint-util.c
--- systemd-255-orig/src/basic/mountpoint-util.c	2024-05-18 13:21:30.914869154 -0700
+++ systemd-255/src/basic/mountpoint-util.c	2024-05-18 16:28:37.993246165 -0700
@@ -11,7 +11,6 @@
 #include "chase.h"
 #include "fd-util.h"
 #include "fileio.h"
-#include "filesystems.h"
 #include "fs-util.h"
 #include "missing_fs.h"
 #include "missing_mount.h"
@@ -401,24 +400,6 @@
         return path_get_mnt_id_at_fallback(dir_fd, path, ret);
 }
 
-bool fstype_is_network(const char *fstype) {
-        const char *x;
-
-        x = startswith(fstype, "fuse.");
-        if (x)
-                fstype = x;
-
-        if (nulstr_contains(filesystem_sets[FILESYSTEM_SET_NETWORK].value, fstype))
-                return true;
-
-        /* Filesystems not present in the internal database */
-        return STR_IN_SET(fstype,
-                          "davfs",
-                          "glusterfs",
-                          "lustre",
-                          "sshfs");
-}
-
 bool fstype_needs_quota(const char *fstype) {
        /* 1. quotacheck needs to be run for some filesystems after they are mounted
         *    if the filesystem was not unmounted cleanly.
@@ -445,34 +426,6 @@
                           "f2fs");
 }
 
-bool fstype_is_api_vfs(const char *fstype) {
-        const FilesystemSet *fs;
-
-        FOREACH_POINTER(fs,
-                filesystem_sets + FILESYSTEM_SET_BASIC_API,
-                filesystem_sets + FILESYSTEM_SET_AUXILIARY_API,
-                filesystem_sets + FILESYSTEM_SET_PRIVILEGED_API,
-                filesystem_sets + FILESYSTEM_SET_TEMPORARY)
-            if (nulstr_contains(fs->value, fstype))
-                    return true;
-
-        /* Filesystems not present in the internal database */
-        return STR_IN_SET(fstype,
-                          "autofs",
-                          "cpuset",
-                          "devtmpfs");
-}
-
-bool fstype_is_blockdev_backed(const char *fstype) {
-        const char *x;
-
-        x = startswith(fstype, "fuse.");
-        if (x)
-                fstype = x;
-
-        return !streq(fstype, "9p") && !fstype_is_network(fstype) && !fstype_is_api_vfs(fstype);
-}
-
 bool fstype_is_ro(const char *fstype) {
         /* All Linux file systems that are necessarily read-only */
         return STR_IN_SET(fstype,
diff '--exclude=testdata' -ur systemd-255-orig/src/basic/sort-util.h systemd-255/src/basic/sort-util.h
--- systemd-255-orig/src/basic/sort-util.h	2024-05-18 13:21:30.918868898 -0700
+++ systemd-255/src/basic/sort-util.h	2024-05-18 13:35:46.075221094 -0700
@@ -5,6 +5,8 @@
 
 #include "macro.h"
 
+typedef int (*comparison_fn_t) (const void *, const void *);
+
 /* This is the same as glibc's internal __compar_d_fn_t type. glibc exports a public comparison_fn_t, for the
  * external type __compar_fn_t, but doesn't do anything similar for __compar_d_fn_t. Let's hence do that
  * ourselves, picking a name that is obvious, but likely enough to not clash with glibc's choice of naming if
diff '--exclude=testdata' -ur systemd-255-orig/src/basic/stat-util.c systemd-255/src/basic/stat-util.c
--- systemd-255-orig/src/basic/stat-util.c	2024-05-18 13:21:30.918868898 -0700
+++ systemd-255/src/basic/stat-util.c	2024-05-18 16:27:28.285958468 -0700
@@ -13,7 +13,6 @@
 #include "errno-util.h"
 #include "fd-util.h"
 #include "fileio.h"
-#include "filesystems.h"
 #include "fs-util.h"
 #include "hash-funcs.h"
 #include "macro.h"
@@ -218,14 +217,6 @@
         return is_fs_type(&s, magic_value);
 }
 
-bool is_temporary_fs(const struct statfs *s) {
-        return fs_in_group(s, FILESYSTEM_SET_TEMPORARY);
-}
-
-bool is_network_fs(const struct statfs *s) {
-        return fs_in_group(s, FILESYSTEM_SET_NETWORK);
-}
-
 int fd_is_temporary_fs(int fd) {
         struct statfs s;
 
diff '--exclude=testdata' -ur systemd-255-orig/src/basic/syslog-util.c systemd-255/src/basic/syslog-util.c
--- systemd-255-orig/src/basic/syslog-util.c	2024-05-18 13:21:30.918868898 -0700
+++ systemd-255/src/basic/syslog-util.c	2024-05-18 16:46:08.913018845 -0700
@@ -10,7 +10,6 @@
 #include "path-util.h"
 #include "string-table.h"
 #include "syslog-util.h"
-#include "unit-name.h"
 
 int syslog_parse_priority(const char **p, int *priority, bool with_facility) {
         int a = 0, b = 0, c = 0;
@@ -105,27 +104,3 @@
 /* The maximum size for a log namespace length. This is the file name size limit 255 minus the size of a
  * formatted machine ID minus a separator char */
 #define LOG_NAMESPACE_MAX (NAME_MAX - (SD_ID128_STRING_MAX - 1) - 1)
-
-bool log_namespace_name_valid(const char *s) {
-        /* Let's make sure the namespace fits in a filename that is prefixed with the machine ID and a dot
-         * (so that /var/log/journal/<machine-id>.<namespace> can be created based on it). Also make sure it
-         * is suitable as unit instance name, and does not contain fishy characters. */
-
-        if (!filename_is_valid(s))
-                return false;
-
-        if (strlen(s) > LOG_NAMESPACE_MAX)
-                return false;
-
-        if (!unit_instance_is_valid(s))
-                return false;
-
-        if (!string_is_safe(s))
-                return false;
-
-        /* Let's avoid globbing for now */
-        if (string_is_glob(s))
-                return false;
-
-        return true;
-}
