diff '--exclude=testdata' -ur systemd-255-orig/src/basic/syslog-util.c systemd-255/src/basic/syslog-util.c
--- systemd-255-orig/src/basic/syslog-util.c	2024-05-18 13:21:30.918868898 -0700
+++ systemd-255/src/basic/syslog-util.c	2024-05-18 16:46:08.913018845 -0700
@@ -10,7 +10,6 @@
 #include "path-util.h"
 #include "string-table.h"
 #include "syslog-util.h"
-#include "unit-name.h"

 int syslog_parse_priority(const char **p, int *priority, bool with_facility) {
         int a = 0, b = 0, c = 0;
@@ -105,27 +104,3 @@
 /* The maximum size for a log namespace length. This is the file name size limit 255 minus the size of a
  * formatted machine ID minus a separator char */
 #define LOG_NAMESPACE_MAX (NAME_MAX - (SD_ID128_STRING_MAX - 1) - 1)
-
-bool log_namespace_name_valid(const char *s) {
-        /* Let's make sure the namespace fits in a filename that is prefixed with the machine ID and a dot
-         * (so that /var/log/journal/<machine-id>.<namespace> can be created based on it). Also make sure it
-         * is suitable as unit instance name, and does not contain fishy characters. */
-
-        if (!filename_is_valid(s))
-                return false;
-
-        if (strlen(s) > LOG_NAMESPACE_MAX)
-                return false;
-
-        if (!unit_instance_is_valid(s))
-                return false;
-
-        if (!string_is_safe(s))
-                return false;
-
-        /* Let's avoid globbing for now */
-        if (string_is_glob(s))
-                return false;
-
-        return true;
-}
diff '--exclude=testdata' -ur systemd-255-orig/src/basic/cgroup-util.c systemd-255/src/basic/cgroup-util.c
--- systemd-255-orig/src/basic/cgroup-util.c	2024-05-18 13:21:30.906869668 -0700
+++ systemd-255/src/basic/cgroup-util.c	2024-05-18 16:51:10.784751550 -0700
@@ -35,7 +35,6 @@
 #include "string-table.h"
 #include "string-util.h"
 #include "strv.h"
-#include "unit-name.h"
 #include "user-util.h"
 #include "xattr-util.h"

@@ -1140,149 +1139,6 @@
         return 0;
 }

-int cg_path_decode_unit(const char *cgroup, char **ret_unit) {
-        char *c, *s;
-        size_t n;
-
-        assert(cgroup);
-        assert(ret_unit);
-
-        n = strcspn(cgroup, "/");
-        if (n < 3)
-                return -ENXIO;
-
-        c = strndupa_safe(cgroup, n);
-        c = cg_unescape(c);
-
-        if (!unit_name_is_valid(c, UNIT_NAME_PLAIN|UNIT_NAME_INSTANCE))
-                return -ENXIO;
-
-        s = strdup(c);
-        if (!s)
-                return -ENOMEM;
-
-        *ret_unit = s;
-        return 0;
-}
-
-static bool valid_slice_name(const char *p, size_t n) {
-
-        if (!p)
-                return false;
-
-        if (n < STRLEN("x.slice"))
-                return false;
-
-        if (memcmp(p + n - 6, ".slice", 6) == 0) {
-                char buf[n+1], *c;
-
-                memcpy(buf, p, n);
-                buf[n] = 0;
-
-                c = cg_unescape(buf);
-
-                return unit_name_is_valid(c, UNIT_NAME_PLAIN);
-        }
-
-        return false;
-}
-
-static const char *skip_slices(const char *p) {
-        assert(p);
-
-        /* Skips over all slice assignments */
-
-        for (;;) {
-                size_t n;
-
-                p += strspn(p, "/");
-
-                n = strcspn(p, "/");
-                if (!valid_slice_name(p, n))
-                        return p;
-
-                p += n;
-        }
-}
-
-int cg_path_get_unit(const char *path, char **ret) {
-        _cleanup_free_ char *unit = NULL;
-        const char *e;
-        int r;
-
-        assert(path);
-        assert(ret);
-
-        e = skip_slices(path);
-
-        r = cg_path_decode_unit(e, &unit);
-        if (r < 0)
-                return r;
-
-        /* We skipped over the slices, don't accept any now */
-        if (endswith(unit, ".slice"))
-                return -ENXIO;
-
-        *ret = TAKE_PTR(unit);
-        return 0;
-}
-
-int cg_path_get_unit_path(const char *path, char **ret) {
-        _cleanup_free_ char *path_copy = NULL;
-        char *unit_name;
-
-        assert(path);
-        assert(ret);
-
-        path_copy = strdup(path);
-        if (!path_copy)
-                return -ENOMEM;
-
-        unit_name = (char *)skip_slices(path_copy);
-        unit_name[strcspn(unit_name, "/")] = 0;
-
-        if (!unit_name_is_valid(cg_unescape(unit_name), UNIT_NAME_PLAIN|UNIT_NAME_INSTANCE))
-                return -ENXIO;
-
-        *ret = TAKE_PTR(path_copy);
-
-        return 0;
-}
-
-int cg_pid_get_unit(pid_t pid, char **ret_unit) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        assert(ret_unit);
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_unit(cgroup, ret_unit);
-}
-
-int cg_pidref_get_unit(const PidRef *pidref, char **ret) {
-        _cleanup_free_ char *unit = NULL;
-        int r;
-
-        assert(ret);
-
-        if (!pidref_is_set(pidref))
-                return -ESRCH;
-
-        r = cg_pid_get_unit(pidref->pid, &unit);
-        if (r < 0)
-                return r;
-
-        r = pidref_verify(pidref);
-        if (r < 0)
-                return r;
-
-        *ret = TAKE_PTR(unit);
-        return 0;
-}
-
 /**
  * Skip session-*.scope, but require it to be there.
  */
@@ -1358,77 +1214,6 @@
         return NULL;
 }

-static const char *skip_user_prefix(const char *path) {
-        const char *e, *t;
-
-        assert(path);
-
-        /* Skip slices, if there are any */
-        e = skip_slices(path);
-
-        /* Skip the user manager, if it's in the path now... */
-        t = skip_user_manager(e);
-        if (t)
-                return t;
-
-        /* Alternatively skip the user session if it is in the path... */
-        return skip_session(e);
-}
-
-int cg_path_get_user_unit(const char *path, char **ret) {
-        const char *t;
-
-        assert(path);
-        assert(ret);
-
-        t = skip_user_prefix(path);
-        if (!t)
-                return -ENXIO;
-
-        /* And from here on it looks pretty much the same as for a system unit, hence let's use the same
-         * parser. */
-        return cg_path_get_unit(t, ret);
-}
-
-int cg_pid_get_user_unit(pid_t pid, char **ret_unit) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        assert(ret_unit);
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_user_unit(cgroup, ret_unit);
-}
-
-int cg_path_get_machine_name(const char *path, char **ret_machine) {
-        _cleanup_free_ char *u = NULL;
-        const char *sl;
-        int r;
-
-        r = cg_path_get_unit(path, &u);
-        if (r < 0)
-                return r;
-
-        sl = strjoina("/run/systemd/machines/unit:", u);
-        return readlink_malloc(sl, ret_machine);
-}
-
-int cg_pid_get_machine_name(pid_t pid, char **ret_machine) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        assert(ret_machine);
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_machine_name(cgroup, ret_machine);
-}
-
 int cg_path_get_cgroupid(const char *path, uint64_t *ret) {
         cg_file_handle fh = CG_FILE_HANDLE_INIT;
         int mnt_id = -1;
@@ -1445,165 +1230,6 @@
         return 0;
 }

-int cg_path_get_session(const char *path, char **ret_session) {
-        _cleanup_free_ char *unit = NULL;
-        char *start, *end;
-        int r;
-
-        assert(path);
-
-        r = cg_path_get_unit(path, &unit);
-        if (r < 0)
-                return r;
-
-        start = startswith(unit, "session-");
-        if (!start)
-                return -ENXIO;
-        end = endswith(start, ".scope");
-        if (!end)
-                return -ENXIO;
-
-        *end = 0;
-        if (!session_id_valid(start))
-                return -ENXIO;
-
-        if (ret_session) {
-                char *rr;
-
-                rr = strdup(start);
-                if (!rr)
-                        return -ENOMEM;
-
-                *ret_session = rr;
-        }
-
-        return 0;
-}
-
-int cg_pid_get_session(pid_t pid, char **ret_session) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_session(cgroup, ret_session);
-}
-
-int cg_path_get_owner_uid(const char *path, uid_t *ret_uid) {
-        _cleanup_free_ char *slice = NULL;
-        char *start, *end;
-        int r;
-
-        assert(path);
-
-        r = cg_path_get_slice(path, &slice);
-        if (r < 0)
-                return r;
-
-        start = startswith(slice, "user-");
-        if (!start)
-                return -ENXIO;
-
-        end = endswith(start, ".slice");
-        if (!end)
-                return -ENXIO;
-
-        *end = 0;
-        if (parse_uid(start, ret_uid) < 0)
-                return -ENXIO;
-
-        return 0;
-}
-
-int cg_pid_get_owner_uid(pid_t pid, uid_t *ret_uid) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_owner_uid(cgroup, ret_uid);
-}
-
-int cg_path_get_slice(const char *p, char **ret_slice) {
-        const char *e = NULL;
-
-        assert(p);
-        assert(ret_slice);
-
-        /* Finds the right-most slice unit from the beginning, but
-         * stops before we come to the first non-slice unit. */
-
-        for (;;) {
-                size_t n;
-
-                p += strspn(p, "/");
-
-                n = strcspn(p, "/");
-                if (!valid_slice_name(p, n)) {
-
-                        if (!e) {
-                                char *s;
-
-                                s = strdup(SPECIAL_ROOT_SLICE);
-                                if (!s)
-                                        return -ENOMEM;
-
-                                *ret_slice = s;
-                                return 0;
-                        }
-
-                        return cg_path_decode_unit(e, ret_slice);
-                }
-
-                e = p;
-                p += n;
-        }
-}
-
-int cg_pid_get_slice(pid_t pid, char **ret_slice) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        assert(ret_slice);
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_slice(cgroup, ret_slice);
-}
-
-int cg_path_get_user_slice(const char *p, char **ret_slice) {
-        const char *t;
-        assert(p);
-        assert(ret_slice);
-
-        t = skip_user_prefix(p);
-        if (!t)
-                return -ENXIO;
-
-        /* And now it looks pretty much the same as for a system slice, so let's just use the same parser
-         * from here on. */
-        return cg_path_get_slice(t, ret_slice);
-}
-
-int cg_pid_get_user_slice(pid_t pid, char **ret_slice) {
-        _cleanup_free_ char *cgroup = NULL;
-        int r;
-
-        assert(ret_slice);
-
-        r = cg_pid_get_path_shifted(pid, NULL, &cgroup);
-        if (r < 0)
-                return r;
-
-        return cg_path_get_user_slice(cgroup, ret_slice);
-}
-
 bool cg_needs_escape(const char *p) {

         /* Checks if the specified path is a valid cgroup name by our rules, or if it must be escaped. Note
@@ -1706,81 +1332,6 @@
         return true;
 }

-int cg_slice_to_path(const char *unit, char **ret) {
-        _cleanup_free_ char *p = NULL, *s = NULL, *e = NULL;
-        const char *dash;
-        int r;
-
-        assert(unit);
-        assert(ret);
-
-        if (streq(unit, SPECIAL_ROOT_SLICE)) {
-                char *x;
-
-                x = strdup("");
-                if (!x)
-                        return -ENOMEM;
-                *ret = x;
-                return 0;
-        }
-
-        if (!unit_name_is_valid(unit, UNIT_NAME_PLAIN))
-                return -EINVAL;
-
-        if (!endswith(unit, ".slice"))
-                return -EINVAL;
-
-        r = unit_name_to_prefix(unit, &p);
-        if (r < 0)
-                return r;
-
-        dash = strchr(p, '-');
-
-        /* Don't allow initial dashes */
-        if (dash == p)
-                return -EINVAL;
-
-        while (dash) {
-                _cleanup_free_ char *escaped = NULL;
-                char n[dash - p + sizeof(".slice")];
-
-#if HAS_FEATURE_MEMORY_SANITIZER
-                /* msan doesn't instrument stpncpy, so it thinks
-                 * n is later used uninitialized:
-                 * https://github.com/google/sanitizers/issues/926
-                 */
-                zero(n);
-#endif
-
-                /* Don't allow trailing or double dashes */
-                if (IN_SET(dash[1], 0, '-'))
-                        return -EINVAL;
-
-                strcpy(stpncpy(n, p, dash - p), ".slice");
-                if (!unit_name_is_valid(n, UNIT_NAME_PLAIN))
-                        return -EINVAL;
-
-                r = cg_escape(n, &escaped);
-                if (r < 0)
-                        return r;
-
-                if (!strextend(&s, escaped, "/"))
-                        return -ENOMEM;
-
-                dash = strchr(dash+1, '-');
-        }
-
-        r = cg_escape(unit, &e);
-        if (r < 0)
-                return r;
-
-        if (!strextend(&s, e))
-                return -ENOMEM;
-
-        *ret = TAKE_PTR(s);
-        return 0;
-}
-
 int cg_is_threaded(const char *path) {
         _cleanup_free_ char *fs = NULL, *contents = NULL;
         _cleanup_strv_free_ char **v = NULL;
