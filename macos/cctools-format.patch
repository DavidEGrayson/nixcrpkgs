diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/debugline.c cctools-port-format/cctools/ld64/src/ld/debugline.c
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/debugline.c	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/debugline.c	2020-11-26 19:03:51.778874452 -0800
@@ -397,11 +397,11 @@
 	      case DW_LNE_set_address:
 		if (sz == 9) {
 		  lnd->cur.pc = read_64 (eop);
-	          if (verbose) fprintf(stderr, "DW_LNE_set_address(0x%08llX)\n", lnd->cur.pc);
+	          if (verbose) fprintf(stderr, "DW_LNE_set_address(0x%08lX)\n", lnd->cur.pc);
 		}
 		else if (sz == 5) {
 		  lnd->cur.pc = read_32 (eop);
-	          if (verbose) fprintf(stderr, "DW_LNE_set_address(0x%08llX)\n", lnd->cur.pc);
+	          if (verbose) fprintf(stderr, "DW_LNE_set_address(0x%08lX)\n", lnd->cur.pc);
 		}
 		else
 		  return false;
@@ -443,11 +443,11 @@
 	  if (tmp == (uint64_t) -1)
 	    return false;
 	  lnd->cur.pc += tmp * lnd->minimum_instruction_length;
-	  if (verbose) fprintf(stderr, "DW_LNS_advance_pc(0x%08llX)\n", lnd->cur.pc);
+	  if (verbose) fprintf(stderr, "DW_LNS_advance_pc(0x%08lX)\n", lnd->cur.pc);
 	  break;
 	case DW_LNS_advance_line:
 	  lnd->cur.line += read_sleb128 (lnd);
-	  if (verbose) fprintf(stderr, "DW_LNS_advance_line(%lld)\n", lnd->cur.line);
+	  if (verbose) fprintf(stderr, "DW_LNS_advance_line(%ld)\n", lnd->cur.line);
 	  break;
 	case DW_LNS_set_file:
 	  if (verbose) fprintf(stderr, "DW_LNS_set_file\n");
diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/InputFiles.cpp cctools-port-format/cctools/ld64/src/ld/InputFiles.cpp
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/InputFiles.cpp	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/InputFiles.cpp	2020-11-26 20:11:07.078874452 -0800
@@ -22,7 +22,7 @@
  *
  * @APPLE_LICENSE_HEADER_END@
  */
- 
+
 
 #include <stdlib.h>
 #include <sys/types.h>
@@ -83,12 +83,12 @@
 
 class DSOHandleAtom : public ld::Atom {
 public:
-									DSOHandleAtom(const char* nm, ld::Atom::Scope sc, 
+									DSOHandleAtom(const char* nm, ld::Atom::Scope sc,
 														ld::Atom::SymbolTableInclusion inc, ld::Section& sect=_s_section)
 										: ld::Atom(sect, ld::Atom::definitionRegular,
-												   (sect == _s_section_text) ? ld::Atom::combineByName : ld::Atom::combineNever, 
+												   (sect == _s_section_text) ? ld::Atom::combineByName : ld::Atom::combineNever,
 												   // make "weak def" so that link succeeds even if app defines __dso_handle
-													sc, ld::Atom::typeUnclassified, inc, true, false, false, 
+													sc, ld::Atom::typeUnclassified, inc, true, false, false,
 													 ld::Atom::Alignment(1)), _name(nm) {}
 
 	virtual ld::File*						file() const					{ return NULL; }
@@ -100,7 +100,7 @@
 	virtual void							setScope(Scope)					{ }
 
 	virtual									~DSOHandleAtom() {}
-	
+
 	static ld::Section						_s_section;
 	static ld::Section						_s_section_preload;
 	static ld::Section						_s_section_text;
@@ -133,7 +133,7 @@
 public:
 									PageZeroAtom(uint64_t sz)
 										: ld::Atom(_s_section, ld::Atom::definitionRegular, ld::Atom::combineNever,
-											ld::Atom::scopeTranslationUnit, ld::Atom::typeZeroFill, 
+											ld::Atom::scopeTranslationUnit, ld::Atom::typeZeroFill,
 											symbolTableNotIn, true, false, false, ld::Atom::Alignment(12)),
 											_size(sz) {}
 
@@ -141,12 +141,12 @@
 	virtual const char*						name() const					{ return "page zero"; }
 	virtual uint64_t						size() const					{ return _size; }
 	virtual uint64_t						objectAddress() const			{ return 0; }
-	virtual void							copyRawContent(uint8_t buffer[]) const 
+	virtual void							copyRawContent(uint8_t buffer[]) const
 																			{ }
 	virtual void							setScope(Scope)					{ }
 
 	virtual									~PageZeroAtom() {}
-	
+
 	static ld::Section						_s_section;
 	static DSOHandleAtom					_s_atomAll;
 private:
@@ -159,7 +159,7 @@
 public:
 									CustomStackAtom(uint64_t sz)
 										: ld::Atom(_s_section, ld::Atom::definitionRegular, ld::Atom::combineNever,
-											ld::Atom::scopeTranslationUnit, ld::Atom::typeZeroFill, 
+											ld::Atom::scopeTranslationUnit, ld::Atom::typeZeroFill,
 											symbolTableNotIn, false, false, false, ld::Atom::Alignment(12)),
 											_size(sz) {}
 
@@ -167,12 +167,12 @@
 	virtual const char*						name() const					{ return "custom stack"; }
 	virtual uint64_t						size() const					{ return _size; }
 	virtual uint64_t						objectAddress() const			{ return 0; }
-	virtual void							copyRawContent(uint8_t buffer[]) const 
+	virtual void							copyRawContent(uint8_t buffer[]) const
 																			{ }
 	virtual void							setScope(Scope)					{ }
 
 	virtual									~CustomStackAtom() {}
-	
+
 private:
 	uint64_t								_size;
 	static ld::Section						_s_section;
@@ -257,7 +257,7 @@
 	if ( ::fstat(fd, &stat_buf) != 0 )
 		throwf("fstat(%s) failed, errno=%d\n", info.path, errno);
 	if ( stat_buf.st_size < 20 )
-		throwf("file too small (length=%llu)", stat_buf.st_size);
+		throwf("file too small (length=%lu)", stat_buf.st_size);
 	int64_t len = stat_buf.st_size;
 	uint8_t* p = (uint8_t*)::mmap(NULL, stat_buf.st_size, PROT_READ, MAP_FILE | MAP_PRIVATE, fd, 0);
 	if ( p == (uint8_t*)(-1) )
@@ -316,7 +316,7 @@
 					newFileLen = statBuffer.st_size;
 				}
 				if ( fileOffset+len > newFileLen ) {
-					throwf("truncated fat file. Slice from %u to %llu is past end of file with length %llu", 
+					throwf("truncated fat file. Slice from %u to %lu is past end of file with length %lu",
 						fileOffset, fileOffset+len, stat_buf.st_size);
 				}
 			}
@@ -386,7 +386,7 @@
 	switch ( _options.outputKind() ) {
 		case Options::kDynamicExecutable:
 		case Options::kDynamicLibrary:
-		case Options::kDynamicBundle:	
+		case Options::kDynamicBundle:
 			dylibResult = mach_o::dylib::parse(p, len, info.path, info.modTime, _options, info.ordinal, info.options.fBundleLoader, indirectDylib);
 			if ( dylibResult != NULL ) {
 				return dylibResult;
@@ -426,12 +426,12 @@
 
 	ld::archive::File* archiveResult = ::archive::parse(p, len, info.path, info.modTime, info.ordinal, archOpts);
 	if ( archiveResult != NULL ) {
-	
+
 		OSAtomicAdd64(len, &_totalArchiveSize);
 		OSAtomicIncrement32(&_totalArchivesLoaded);
 		return archiveResult;
 	}
-	
+
 #ifdef LTO_SUPPORT
 	// does not seem to be any valid linker input file, check LTO misconfiguration problems
 	if ( lto::archName((uint8_t*)p, len) != NULL ) {
@@ -460,7 +460,7 @@
 					if ( lastSlash != NULL )
 						strcpy(lastSlash, "/../lib/llvm/libLTO.so");
 					libLTO = tmpPath;
-					if ( realpath(tmpPath, libLTOPath) != NULL ) 
+					if ( realpath(tmpPath, libLTOPath) != NULL )
 						libLTO = libLTOPath;
 				}
 			}
@@ -526,22 +526,22 @@
 			}
 		}
 	}
-	
+
 	if ( _options.dumpDependencyInfo() ) {
 		const ld::dylib::File* dylib = dynamic_cast<const ld::dylib::File*>(file);
 		if ( file == _bundleLoader ) {
 			_options.addDependency(Options::depBundleLoader, file->path());
 		}
 		else if ( (dylib != NULL ) && dylib->willBeUpwardDylib() ) {
-			if ( indirect ) 
+			if ( indirect )
 				_options.addDependency(Options::depUpwardIndirectDylib, file->path());
-			else 
+			else
 				_options.addDependency(Options::depUpwardDirectDylib, file->path());
 		}
 		else {
-			if ( indirect ) 
+			if ( indirect )
 				_options.addDependency(Options::depIndirectDylib, file->path());
-			else 
+			else
 				_options.addDependency(Options::depDirectDylib, file->path());
 		}
 	}
@@ -557,7 +557,7 @@
 		if ( realpath(fullPath, realName) != NULL )
 			fullPath = realName;
 		logTraceInfo("[Logging for XBS] Used static archive: %s\n", fullPath);
-		
+
 		std::string archivePath(fullPath);
 		_archiveFilePaths.push_back(archivePath);
 	}
@@ -599,7 +599,7 @@
 						this->logDylib(dylibReader, true, speculative);
 						return dylibReader;
 					}
-					else 
+					else
 						throwf("indirect dylib at %s is not a dylib", dit->useInstead);
 				}
 				catch (const char* msg) {
@@ -623,7 +623,7 @@
 				this->logDylib(dylibReader, true, speculative);
 				return dylibReader;
 			}
-			else 
+			else
 				throwf("indirect dylib at %s is not a dylib", info.path);
 		}
 		catch (const char* msg) {
@@ -635,7 +635,7 @@
 
 // mark all dylibs initially specified as required, and check if they can be used
 void InputFiles::markExplicitlyLinkedDylibs()
-{	
+{
 	for (InstallNameToDylib::iterator it=_installPathToDylibs.begin(); it != _installPathToDylibs.end(); it++) {
 		it->second->setExplicitlyLinked();
 		this->checkDylibClientRestrictions(it->second);
@@ -683,10 +683,10 @@
 
 
 void InputFiles::addLinkerOptionLibraries(ld::Internal& state, ld::File::AtomHandler& handler)
-{	
+{
   	if ( _options.outputKind() == Options::kObjectFile )
  		return;
-  
+
 	while (! state.unprocessedLinkerOptionLibraries.empty() || ! state.unprocessedLinkerOptionFrameworks.empty()) {
 
 		// process frameworks specified in .o linker options
@@ -783,7 +783,7 @@
 }
 
 void InputFiles::createIndirectDylibs()
-{	
+{
 	// keep processing dylibs until no more dylibs are added
 	unsigned long lastMapSize = 0;
 	std::set<ld::dylib::File*>  dylibsProcessed;
@@ -823,7 +823,7 @@
 			}
 		}
 	}
-	
+
 }
 
 void InputFiles::createOpaqueFileSections()
@@ -851,7 +851,7 @@
 
 void InputFiles::checkDylibClientRestrictions(ld::dylib::File* dylib)
 {
-	// Check for any restrictions on who can link with this dylib  
+	// Check for any restrictions on who can link with this dylib
 	const char* dylibParentName = dylib->parentUmbrella() ;
 	const std::vector<const char*>* clients = dylib->allowableClients();
 	if ( (dylibParentName != NULL) || (clients != NULL) ) {
@@ -876,10 +876,10 @@
 			const char* firstUnderscore = strchr(myName, '_');
 			if ( (firstUnderscore != NULL) && ((firstUnderscore - myName) < (int)myNameLen) )
 				myNameLen = firstUnderscore - myName;
-		
+
 			// case 1) The dylib has a parent umbrella, and we are creating the parent umbrella
 			isParent = ( (strlen(dylibParentName) == myNameLen) && (strncmp(myName, dylibParentName, myNameLen) == 0) );
-			
+
 			// case 2) The dylib has a parent umbrella, and we are creating a sibling with the same parent
 			isSibling = ( (_options.umbrellaName() != NULL) && (strcmp(_options.umbrellaName(), dylibParentName) == 0) );
 		}
@@ -928,10 +928,10 @@
 			}
 
 		}
-	
+
 		if ( !isParent && !isSibling && !isAllowableClient ) {
 			if ( dylibParentName != NULL ) {
-				throwf("cannot link directly with %s.  Link against the umbrella framework '%s.framework' instead.", 
+				throwf("cannot link directly with %s.  Link against the umbrella framework '%s.framework' instead.",
 					dylib->path(), dylibParentName);
 			}
 			else {
@@ -942,11 +942,11 @@
 }
 
 
-InputFiles::InputFiles(Options& opts) 
- : _totalObjectSize(0), _totalArchiveSize(0), 
+InputFiles::InputFiles(Options& opts)
+ : _totalObjectSize(0), _totalArchiveSize(0),
    _totalObjectLoaded(0), _totalArchivesLoaded(0), _totalDylibsLoaded(0),
-	_options(opts), _bundleLoader(NULL), 
-	_exception(NULL), 
+	_options(opts), _bundleLoader(NULL),
+	_exception(NULL),
 	_indirectDylibOrdinal(ld::File::Ordinal::indirectDylibBase()),
 	_linkerOptionOrdinal(ld::File::Ordinal::linkeOptionBase())
 {
@@ -984,10 +984,10 @@
 		_inputFiles.push_back(makeFile(*entry, false));
 #endif
 	}
-	
+
 #if HAVE_PTHREADS
 	_remainingInputFiles = files.size();
-	
+
 	// initialize info for parsing input files on worker threads
 	unsigned int ncpus;
 #ifdef __APPLE__
@@ -1005,7 +1005,7 @@
 #endif
 	_availableWorkers = MIN(ncpus, files.size()); // max # workers we permit
 	_idleWorkers = 0;
-	
+
 	if (_options.pipelineEnabled()) {
 		// start up a thread to listen for available input files
 		startThread(InputFiles::waitForInputFiles);
@@ -1068,7 +1068,7 @@
 					else {
 						warning("ignoring file %s, %s", entry.path, msg);
 					}
-				} 
+				}
 				else if ( strstr(msg, "ignoring unexpected") != NULL ) {
 					warning("%s, %s", entry.path, msg);
 				}
@@ -1085,7 +1085,7 @@
 				// We are about to die, so set to zero to stop other threads from doing unneeded work.
 				_remainingInputFiles = 0;
 				_exception = exception;
-			} 
+			}
 			else {
 				_inputFiles[slot] = file;
 				if (_neededFileSlot == slot)
@@ -1109,7 +1109,7 @@
 ld::File* InputFiles::addDylib(ld::dylib::File* reader, const Options::FileInfo& info)
 {
 	_allDylibs.insert(reader);
-	
+
 	if ( (reader->installPath() == NULL) && !info.options.fBundleLoader ) {
 		// this is a "blank" stub
 		// silently ignore it
@@ -1121,14 +1121,14 @@
 	if ( info.options.fReExport )
 		reader->setWillBeReExported();
 	if ( info.options.fUpward ) {
-		if ( _options.outputKind() == Options::kDynamicLibrary ) 
+		if ( _options.outputKind() == Options::kDynamicLibrary )
 			reader->setWillBeUpwardDylib();
-		else 
+		else
 			warning("ignoring upward dylib option for %s\n", info.path);
 	}
 	if ( info.options.fLazyLoad )
 		reader->setWillBeLazyLoadedDylb();
-	
+
 	// add to map of loaded dylibs
 	const char* installPath = reader->installPath();
 	if ( installPath != NULL ) {
@@ -1158,16 +1158,16 @@
 		_bundleLoader = reader;
 
 	// log direct readers
-	if ( ! info.options.fIndirectDylib ) 
+	if ( ! info.options.fIndirectDylib )
 		this->logDylib(reader, false, false);
 
 	// update stats
 	_totalDylibsLoaded++;
 
 	// just add direct libraries to search-first list
-	if ( ! info.options.fIndirectDylib ) 
+	if ( ! info.options.fIndirectDylib )
 		_searchLibraries.push_back(LibraryInfo(reader));
-	
+
 	return reader;
 }
 
@@ -1240,7 +1240,7 @@
 		ld::File *file;
 #if HAVE_PTHREADS
 		pthread_mutex_lock(&_parseLock);
-		
+
 		// this loop waits for the needed file to be ready (parsed by worker thread)
 		while (_inputFiles[fileIndex] == NULL && _exception == NULL) {
 			// We are starved for input. If there are still files to parse and we have
@@ -1322,22 +1322,22 @@
 	addLinkerOptionLibraries(state, handler);
 	createIndirectDylibs();
 	createOpaqueFileSections();
-	
+
 	while (fileIndex < _inputFiles.size()) {
 		ld::File *file = _inputFiles[fileIndex];
 		file->forEachAtom(handler);
 		fileIndex++;
 	}
-    
+
     switch ( _options.outputKind() ) {
         case Options::kStaticExecutable:
         case Options::kDynamicExecutable:
             // add implicit __dso_handle label
             handler.doAtom(DSOHandleAtom::_s_atomExecutable);
             handler.doAtom(DSOHandleAtom::_s_atomAll);
-            if ( _options.pageZeroSize() != 0 ) 
+            if ( _options.pageZeroSize() != 0 )
                 handler.doAtom(*new PageZeroAtom(_options.pageZeroSize()));
-            if ( _options.hasCustomStack() && !_options.needsEntryPointLoadCommand() ) 
+            if ( _options.hasCustomStack() && !_options.needsEntryPointLoadCommand() )
                 handler.doAtom(*new CustomStackAtom(_options.customStackSize()));
             break;
         case Options::kDynamicLibrary:
@@ -1358,7 +1358,7 @@
         case Options::kPreload:
             // add implicit __mh_preload_header label
             handler.doAtom(DSOHandleAtom::_s_atomPreload);
-            // add implicit __dso_handle label, but put it in __text section because 
+            // add implicit __dso_handle label, but put it in __text section because
             // with -preload the mach_header is no in the address space.
             handler.doAtom(DSOHandleAtom::_s_atomPreloadDSO);
             break;
@@ -1442,7 +1442,7 @@
                     }
 					// else continue search for a non-weak definition
 				}
-			}			
+			}
 		}
 	}
 
@@ -1463,14 +1463,14 @@
 	}
 	return false;
 }
-	
+
 static bool vectorContains(const std::vector<ld::dylib::File*>& vec, ld::dylib::File* key)
 {
 	return std::find(vec.begin(), vec.end(), key) != vec.end();
 }
 
 struct DylibByInstallNameSorter
-{	
+{
 	 bool operator()(const ld::dylib::File* left, const ld::dylib::File* right)
 	 {
           return (strcmp(left->installPath(), right->installPath()) < 0);
@@ -1542,10 +1542,10 @@
 	//	const ld::dylib::File* dylib = *it;
 	//	fprintf(stderr, "    %p impl=%d %s\n", dylib, dylib->implicitlyLinked(), dylib->path());
 	//}
-	
+
 	// and -bundle_loader
 	state.bundleLoader = _bundleLoader;
-	
+
 	// <rdar://problem/10807040> give an error when -nostdlib is used and libSystem is missing
 	if ( (state.dylibs.size() == 0) && _options.needsEntryPointLoadCommand() && !_options.platforms().contains(ld::Platform::driverKit))  {
 		// HACK until 39514191 is fixed
@@ -1562,12 +1562,12 @@
 void InputFiles::archives(ld::Internal& state)
 {
 	for (const std::string& path :  _archiveFilePaths) {
-		
+
 		state.archivePaths.push_back(path);
 	}
 }
 
 
-} // namespace tool 
-} // namespace ld 
+} // namespace tool
+} // namespace ld
 
diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/ld.cpp cctools-port-format/cctools/ld64/src/ld/ld.cpp
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/ld.cpp	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/ld.cpp	2020-11-26 20:17:51.378874452 -0800
@@ -21,7 +21,7 @@
  *
  * @APPLE_LICENSE_HEADER_END@
  */
- 
+
 // start temp HACK for cross builds
 //extern "C" double log2 ( double ); // ld64-port: commented
 //#define __MATH__
@@ -116,7 +116,7 @@
 	virtual	ld::Internal::FinalSection*		addAtom(const ld::Atom& atom);
 	virtual ld::Internal::FinalSection*		getFinalSection(const ld::Section&);
 			ld::Internal::FinalSection*     getFinalSection(const char* seg, const char* sect, ld::Section::Type type);
-	
+
 	uint64_t								assignFileOffsets();
 	void									setSectionSizesAndAlignments();
 	void									sortSections();
@@ -128,7 +128,7 @@
 	bool									inMoveRWChain(const ld::Atom& atom, const char* filePath, bool followedBackBranch, const char*& dstSeg, bool& wildCardMatch);
 	bool									inMoveROChain(const ld::Atom& atom, const char* filePath, const char*& dstSeg, bool& wildCardMatch);
 
-	class FinalSection : public ld::Internal::FinalSection 
+	class FinalSection : public ld::Internal::FinalSection
 	{
 	public:
 									FinalSection(const ld::Section& sect, uint32_t sectionsSeen, const Options&);
@@ -152,11 +152,11 @@
 		static ld::Section		_s_DATA_DIRTY_data;
 		static ld::Section		_s_DATA_CONST_const;
 	};
-	
+
 	bool hasZeroForFileOffset(const ld::Section* sect);
 	uint64_t pageAlign(uint64_t addr);
 	uint64_t pageAlign(uint64_t addr, uint64_t pageSize);
-	
+
 	struct SectionHash {
 		size_t operator()(const ld::Section*) const;
 	};
@@ -164,7 +164,7 @@
 		bool operator()(const ld::Section* left, const ld::Section* right) const;
 	};
 	typedef std::unordered_map<const ld::Section*, FinalSection*, SectionHash, SectionEquals> SectionInToOut;
-	
+
 
 	SectionInToOut			_sectionInToFinalMap;
 	const Options&			_options;
@@ -187,7 +187,7 @@
 
 size_t InternalState::SectionHash::operator()(const ld::Section* sect) const
 {
-	size_t hash = 0;	
+	size_t hash = 0;
 	ld::CStringHash temp;
 	hash += temp.operator()(sect->segmentName());
 	hash += temp.operator()(sect->sectionName());
@@ -201,7 +201,7 @@
 
 
 InternalState::FinalSection::FinalSection(const ld::Section& sect, uint32_t sectionsSeen, const Options& opts)
-	: ld::Internal::FinalSection(sect), 
+	: ld::Internal::FinalSection(sect),
 	  _segmentOrder(segmentOrder(sect, opts)),
 	  _sectionOrder(sectionOrder(sect, sectionsSeen, opts))
 {
@@ -258,7 +258,7 @@
 			}
 			else if ( strcmp(sect.segmentName(), "__IMPORT") == 0 ) {
 				if ( strcmp(sect.sectionName(), "__pointers") == 0 )
-					return _s_DATA_nl_symbol_ptr; 
+					return _s_DATA_nl_symbol_ptr;
 			}
 			break;
 		case ld::Section::typeTentativeDefs:
@@ -269,7 +269,7 @@
 					return _s_DATA_common;
 			}
 			break;
-			// FIX ME: more 
+			// FIX ME: more
 		default:
 			break;
 	}
@@ -287,16 +287,16 @@
 uint32_t InternalState::FinalSection::segmentOrder(const ld::Section& sect, const Options& options)
 {
 	if ( options.outputKind() == Options::kPreload ) {
-		if ( strcmp(sect.segmentName(), "__HEADER") == 0 ) 
+		if ( strcmp(sect.segmentName(), "__HEADER") == 0 )
 			return 0;
 		const std::vector<const char*>& order = options.segmentOrder();
 		for (size_t i=0; i != order.size(); ++i) {
-			if ( strcmp(sect.segmentName(), order[i]) == 0 ) 
+			if ( strcmp(sect.segmentName(), order[i]) == 0 )
 				return i+1;
 		}
-		if ( strcmp(sect.segmentName(), "__TEXT") == 0 ) 
+		if ( strcmp(sect.segmentName(), "__TEXT") == 0 )
 			return order.size()+1;
-		if ( strcmp(sect.segmentName(), "__DATA") == 0 ) 
+		if ( strcmp(sect.segmentName(), "__DATA") == 0 )
 			return order.size()+2;
 	}
 	else if ( options.outputKind() == Options::kStaticExecutable ) {
@@ -314,9 +314,9 @@
 	}
 	else {
 		bool armCloseStubs = (options.architecture() == CPU_TYPE_ARM) && !options.sharedRegionEligible() && !options.makeEncryptable() && !options.makeChainedFixups();
-		if ( strcmp(sect.segmentName(), "__PAGEZERO") == 0 ) 
+		if ( strcmp(sect.segmentName(), "__PAGEZERO") == 0 )
 			return 0;
-		if ( strcmp(sect.segmentName(), "__TEXT") == 0 ) 
+		if ( strcmp(sect.segmentName(), "__TEXT") == 0 )
 			return 1;
 		if ( strcmp(sect.segmentName(), "__TEXT_EXEC") == 0 )
 			return 2;
@@ -325,7 +325,7 @@
 		// in -r mode, want __DATA  last so zerofill sections are at end
 		if ( strcmp(sect.segmentName(), "__DATA") == 0 )
 			return (options.outputKind() == Options::kObjectFile) ? 7 : 4;
-		if ( strcmp(sect.segmentName(), "__OBJC") == 0 ) 
+		if ( strcmp(sect.segmentName(), "__OBJC") == 0 )
 			return 5;
 		if ( strcmp(sect.segmentName(), "__IMPORT") == 0 )
 			return 6;
@@ -351,7 +351,7 @@
 	if ( ((options.outputKind() == Options::kPreload) || (options.outputKind() == Options::kDyld)) && (sectionList != NULL) ) {
 		uint32_t count = 10;
 		for (std::vector<const char*>::const_iterator it=sectionList->begin(); it != sectionList->end(); ++it, ++count) {
-			if ( strcmp(*it, sect.sectionName()) == 0 ) 
+			if ( strcmp(*it, sect.sectionName()) == 0 )
 				return count;
 		}
 	}
@@ -429,33 +429,33 @@
 				if ( strcmp(sect.sectionName(), "__cfstring") == 0 )
 					return 15;
 				// <rdar://problem/7435296> Reorder sections to reduce page faults in object files
-				else if ( strcmp(sect.sectionName(), "__objc_classlist") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_classlist") == 0 )
 					return 20;
-				else if ( strcmp(sect.sectionName(), "__objc_nlclslist") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_nlclslist") == 0 )
 					return 21;
-				else if ( strcmp(sect.sectionName(), "__objc_catlist") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_catlist") == 0 )
 					return 22;
-				else if ( strcmp(sect.sectionName(), "__objc_nlcatlist") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_nlcatlist") == 0 )
 					return 23;
-				else if ( strcmp(sect.sectionName(), "__objc_protolist") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_protolist") == 0 )
 					return 24;
-				else if ( strcmp(sect.sectionName(), "__objc_imageinfo") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_imageinfo") == 0 )
 					return 25;
-				else if ( strcmp(sect.sectionName(), "__objc_const") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_const") == 0 )
 					return 26;
-				else if ( strcmp(sect.sectionName(), "__objc_selrefs") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_selrefs") == 0 )
 					return 27;
-				else if ( strcmp(sect.sectionName(), "__objc_msgrefs") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_msgrefs") == 0 )
 					return 28;
-				else if ( strcmp(sect.sectionName(), "__objc_protorefs") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_protorefs") == 0 )
 					return 29;
-				else if ( strcmp(sect.sectionName(), "__objc_classrefs") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_classrefs") == 0 )
 					return 30;
-				else if ( strcmp(sect.sectionName(), "__objc_superrefs") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_superrefs") == 0 )
 					return 31;
-				else if ( strcmp(sect.sectionName(), "__objc_ivar") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_ivar") == 0 )
 					return 32;
-				else if ( strcmp(sect.sectionName(), "__objc_data") == 0 ) 
+				else if ( strcmp(sect.sectionName(), "__objc_data") == 0 )
 					return 33;
 				else if ( strcmp(sect.sectionName(), "__objc_const_ax") == 0 )
 					return 34;
@@ -601,7 +601,7 @@
 		dstSeg = pos->second;
 		return true;
 	}
-	
+
 	bool result = false;
 	if ( _options.moveRwSymbol(atom.name(), filePath, dstSeg, wildCardMatch) )
 		result = true;
@@ -694,8 +694,8 @@
 		const char* dstSeg;
 		bool wildCardMatch;
 		if ( inMoveRWChain(atom, path, false, dstSeg, wildCardMatch) ) {
-			if ( (sectType != ld::Section::typeZeroFill) 
-			  && (sectType != ld::Section::typeUnclassified) 
+			if ( (sectType != ld::Section::typeZeroFill)
+			  && (sectType != ld::Section::typeUnclassified)
 			  && (sectType != ld::Section::typeTentativeDefs)
 			  && (sectType != ld::Section::typeTLVDefs)
 			  && (sectType != ld::Section::typeDyldInfo) ) {
@@ -813,7 +813,7 @@
 
 
 ld::Internal::FinalSection* InternalState::getFinalSection(const char* seg, const char* sect, ld::Section::Type type)
-{	
+{
 	for (std::vector<ld::Internal::FinalSection*>::iterator it=sections.begin(); it != sections.end(); ++it) {
 		if ( (strcmp((*it)->segmentName(),seg) == 0) && (strcmp((*it)->sectionName(),sect) == 0) )
 			return *it;
@@ -822,9 +822,9 @@
 }
 
 ld::Internal::FinalSection* InternalState::getFinalSection(const ld::Section& inputSection)
-{	
+{
 	const ld::Section* baseForFinalSection = &inputSection;
-	
+
 	// see if input section already has a FinalSection
 	SectionInToOut::iterator pos = _sectionInToFinalMap.find(&inputSection);
 	if ( pos != _sectionInToFinalMap.end() ) {
@@ -866,7 +866,7 @@
 			break;
 	}
 
-	InternalState::FinalSection* result = new InternalState::FinalSection(*baseForFinalSection, 
+	InternalState::FinalSection* result = new InternalState::FinalSection(*baseForFinalSection,
 																	_sectionInToFinalMap.size(), _options);
 	_sectionInToFinalMap[baseForFinalSection] = result;
 	//fprintf(stderr, "_sectionInToFinalMap[%p(%s)] = %p\n", baseForFinalSection, baseForFinalSection->sectionName(), result);
@@ -892,11 +892,11 @@
 	//for (std::vector<ld::Internal::FinalSection*>::iterator it = sections.begin(); it != sections.end(); ++it) {
 	//	fprintf(stderr, "final section %p %s/%s\n", (*it), (*it)->segmentName(), (*it)->sectionName());
 	//}
-	assert((sections[0]->type() == ld::Section::typeMachHeader) 
+	assert((sections[0]->type() == ld::Section::typeMachHeader)
 		|| ((sections[0]->type() == ld::Section::typeFirstSection) && (sections[1]->type() == ld::Section::typeMachHeader))
 		|| ((sections[0]->type() == ld::Section::typePageZero) && (sections[1]->type() == ld::Section::typeMachHeader))
 		|| ((sections[0]->type() == ld::Section::typePageZero) && (sections[1]->type() == ld::Section::typeFirstSection) && (sections[2]->type() == ld::Section::typeMachHeader)) );
-	
+
 }
 
 
@@ -919,12 +919,12 @@
 uint64_t InternalState::pageAlign(uint64_t addr)
 {
 	const uint64_t alignment = _options.segmentAlignment();
-	return ((addr+alignment-1) & (-alignment)); 
+	return ((addr+alignment-1) & (-alignment));
 }
 
 uint64_t InternalState::pageAlign(uint64_t addr, uint64_t pageSize)
 {
-	return ((addr+pageSize-1) & (-pageSize)); 
+	return ((addr+pageSize-1) & (-pageSize));
 }
 
 void InternalState::setSectionSizesAndAlignments()
@@ -957,7 +957,7 @@
 						case ld::Section::typeUnclassified:
 						case ld::Section::typeTentativeDefs:
 						case ld::Section::typeZeroFill:
-							if ( contiguousObjCSection ) 
+							if ( contiguousObjCSection )
 								break;
 							pagePerAtom = true;
 							if ( atomAlignmentPowerOf2 < 12 ) {
@@ -989,13 +989,13 @@
 						offset = (offset + 4095) & (-4096); // round up to end of page
 					}
 				}
-				if ( (atom->scope() == ld::Atom::scopeGlobal) 
-					&& (atom->definition() == ld::Atom::definitionRegular) 
-					&& (atom->combine() == ld::Atom::combineByName) 
-					&& ((atom->symbolTableInclusion() == ld::Atom::symbolTableIn) 
+				if ( (atom->scope() == ld::Atom::scopeGlobal)
+					&& (atom->definition() == ld::Atom::definitionRegular)
+					&& (atom->combine() == ld::Atom::combineByName)
+					&& ((atom->symbolTableInclusion() == ld::Atom::symbolTableIn)
 					 || (atom->symbolTableInclusion() == ld::Atom::symbolTableInAndNeverStrip)) ) {
 						this->hasWeakExternalSymbols = true;
-						if ( _options.warnWeakExports()	) 
+						if ( _options.warnWeakExports()	)
 							warning("weak external symbol: %s", atom->name());
 						else if ( _options.noWeakExports()	)
 							throwf("weak external symbol: %s", atom->name());
@@ -1033,7 +1033,7 @@
 
 }
 
-uint64_t InternalState::assignFileOffsets() 
+uint64_t InternalState::assignFileOffsets()
 {
   	const bool log = false;
 	const bool hiddenSectionsOccupyAddressSpace = ((_options.outputKind() != Options::kObjectFile)
@@ -1044,7 +1044,7 @@
 	const char* lastSegName = "";
 	uint64_t floatingAddressStart = _options.baseAddress();
 	bool haveFixedSegments = false;
-	
+
 	// mark all sections as not having an address yet
 	for (std::vector<ld::Internal::FinalSection*>::iterator it = sections.begin(); it != sections.end(); ++it) {
 		ld::Internal::FinalSection* sect = *it;
@@ -1056,7 +1056,7 @@
 	if ( log ) fprintf(stderr, "Fixed address segments:\n");
 	for (std::vector<ld::Internal::FinalSection*>::iterator it = sections.begin(); it != sections.end(); ++it) {
 		ld::Internal::FinalSection* sect = *it;
-		if ( ! _options.hasCustomSegmentAddress(sect->segmentName()) ) 
+		if ( ! _options.hasCustomSegmentAddress(sect->segmentName()) )
 			continue;
 		haveFixedSegments = true;
 		if ( segmentsArePageAligned ) {
@@ -1069,23 +1069,23 @@
 		uint64_t unalignedAddress = address;
 		uint64_t alignment = (1 << sect->alignment);
 		address = ( (unalignedAddress+alignment-1) & (-alignment) );
-	
+
 		// update section info
 		sect->address = address;
 		sect->alignmentPaddingBytes = (address - unalignedAddress);
-		
+
 		// sanity check size
-		if ( ((address + sect->size) > _options.maxAddress()) && (_options.outputKind() != Options::kObjectFile) 
+		if ( ((address + sect->size) > _options.maxAddress()) && (_options.outputKind() != Options::kObjectFile)
 															  && (_options.outputKind() != Options::kStaticExecutable) )
-			throwf("section %s (address=0x%08llX, size=%llu) would make the output executable exceed available address range", 
+			throwf("section %s (address=0x%08lX, size=%lu) would make the output executable exceed available address range",
 						sect->sectionName(), address, sect->size);
-		
-		if ( log ) fprintf(stderr, "  address=0x%08llX, hidden=%d, alignment=%02d, section=%s,%s\n",
+
+		if ( log ) fprintf(stderr, "  address=0x%08lX, hidden=%d, alignment=%02d, section=%s,%s\n",
 						sect->address, sect->isSectionHidden(), sect->alignment, sect->segmentName(), sect->sectionName());
 		// update running totals
 		if ( !sect->isSectionHidden() || hiddenSectionsOccupyAddressSpace )
 			address += sect->size;
-		
+
 		// if TEXT segment address is fixed, then flow other segments after it
 		if ( strcmp(sect->segmentName(), "__TEXT") == 0 ) {
 			floatingAddressStart = address;
@@ -1096,7 +1096,7 @@
 	if ( haveFixedSegments && !_options.segmentOrder().empty() ) {
 		if ( log ) fprintf(stderr, "After Fixed address segments:\n");
 		lastSegName = "";
-		ld::Internal::FinalSection* lastSect = NULL; 
+		ld::Internal::FinalSection* lastSect = NULL;
 		for (std::vector<ld::Internal::FinalSection*>::iterator it = sections.begin(); it != sections.end(); ++it) {
 			ld::Internal::FinalSection* sect = *it;
 			if ( (sect->address == ULLONG_MAX) && _options.segmentOrderAfterFixedAddressSegment(sect->segmentName()) ) {
@@ -1111,7 +1111,7 @@
 				address = ( (unalignedAddress+alignment-1) & (-alignment) );
 				sect->alignmentPaddingBytes = (address - unalignedAddress);
 				sect->address = address;
-				if ( log ) fprintf(stderr, "  address=0x%08llX, hidden=%d, alignment=%02d, section=%s,%s\n",
+				if ( log ) fprintf(stderr, "  address=0x%08lX, hidden=%d, alignment=%02d, section=%s,%s\n",
 									sect->address, sect->isSectionHidden(), sect->alignment, sect->segmentName(), sect->sectionName());
 				// update running totals
 				if ( !sect->isSectionHidden() || hiddenSectionsOccupyAddressSpace )
@@ -1148,12 +1148,12 @@
 				lastSegName = sect->segmentName();
 			}
 		}
-		
+
 		// adjust section address based on alignment
 		uint64_t unalignedAddress = address;
 		uint64_t alignment = (1 << sect->alignment);
 		address = ( (unalignedAddress+alignment-1) & (-alignment) );
-	
+
 		// update section info
 		sect->address = address;
 		sect->alignmentPaddingBytes = (address - unalignedAddress);
@@ -1168,15 +1168,15 @@
 		}
 
 		// sanity check size
-		if ( ((address + sect->size) > _options.maxAddress()) && (_options.outputKind() != Options::kObjectFile) 
+		if ( ((address + sect->size) > _options.maxAddress()) && (_options.outputKind() != Options::kObjectFile)
 															  && (_options.outputKind() != Options::kStaticExecutable) )
-				throwf("section %s (address=0x%08llX, size=%llu) would make the output executable exceed available address range", 
+				throwf("section %s (address=0x%08lX, size=%lu) would make the output executable exceed available address range",
 						sect->sectionName(), address, sect->size);
 
 		// sanity check it does not overlap a fixed address segment
 		for (std::vector<ld::Internal::FinalSection*>::iterator sit = sections.begin(); sit != sections.end(); ++sit) {
 			ld::Internal::FinalSection* otherSect = *sit;
-			if ( ! _options.hasCustomSegmentAddress(otherSect->segmentName()) ) 
+			if ( ! _options.hasCustomSegmentAddress(otherSect->segmentName()) )
 				continue;
 			if ( otherSect->size == 0 )
 				continue;
@@ -1195,9 +1195,9 @@
 				}
 			}
 		}
-		
-		if ( log ) fprintf(stderr, "  address=0x%08llX, size=0x%08llX, hidden=%d, alignment=%02d, padBytes=%d, section=%s,%s\n",
-							sect->address, sect->size, sect->isSectionHidden(), sect->alignment, sect->alignmentPaddingBytes, 
+
+		if ( log ) fprintf(stderr, "  address=0x%08lX, size=0x%08lX, hidden=%d, alignment=%02d, padBytes=%d, section=%s,%s\n",
+							sect->address, sect->size, sect->isSectionHidden(), sect->alignment, sect->alignmentPaddingBytes,
 							sect->segmentName(), sect->sectionName());
 		// update running totals
 		if ( !sect->isSectionHidden() || hiddenSectionsOccupyAddressSpace )
@@ -1210,18 +1210,18 @@
 			ld::Internal::FinalSection* sect = *it;
 			//if ( sect->isSectionHidden() )
 			//	continue;
-			fprintf(stderr, "  address:0x%08llX, alignment:2^%d, size:0x%08llX, padBytes:%d, section:%s/%s\n",
-							sect->address, sect->alignment, sect->size, sect->alignmentPaddingBytes, 
+			fprintf(stderr, "  address:0x%08lX, alignment:2^%d, size:0x%08lX, padBytes:%d, section:%s/%s\n",
+							sect->address, sect->alignment, sect->size, sect->alignmentPaddingBytes,
 							sect->segmentName(), sect->sectionName());
-	
+
 		}
-		throwf("Section (%s/%s) overlaps fixed address section (%s/%s)", 
+		throwf("Section (%s/%s) overlaps fixed address section (%s/%s)",
 			overlappingFlowSection->segmentName(), overlappingFlowSection->sectionName(),
 			overlappingFixedSection->segmentName(), overlappingFixedSection->sectionName());
 	}
-	
-	
-	// third pass, assign section file offsets 
+
+
+	// third pass, assign section file offsets
 	uint64_t fileOffset = 0;
 	lastSegName = "";
 	if ( log ) fprintf(stderr, "All segments with file offsets:\n");
@@ -1243,22 +1243,22 @@
 
 			// align file offset with address layout
 			fileOffset += sect->alignmentPaddingBytes;
-			
+
 			// update section info
 			sect->fileOffset = fileOffset;
-			
+
 			// update running total
 			fileOffset += sect->size;
 		}
-		
-		if ( log ) fprintf(stderr, "  fileoffset=0x%08llX, address=0x%08llX, hidden=%d, size=%lld, alignment=%02d, section=%s,%s\n",
-				sect->fileOffset, sect->address, sect->isSectionHidden(), sect->size, sect->alignment, 
+
+		if ( log ) fprintf(stderr, "  fileoffset=0x%08lX, address=0x%08lX, hidden=%d, size=%ld, alignment=%02d, section=%s,%s\n",
+				sect->fileOffset, sect->address, sect->isSectionHidden(), sect->size, sect->alignment,
 				sect->segmentName(), sect->sectionName());
 	}
 
 #if 0
 	// for encrypted iPhoneOS apps
-	if ( _options.makeEncryptable() ) { 
+	if ( _options.makeEncryptable() ) {
 		// remember end of __TEXT for later use by load command
 		for (std::vector<ld::Internal::FinalSection*>::iterator it = state.sections.begin(); it != state.sections.end(); ++it) {
 			ld::Internal::FinalSection* sect = *it;
@@ -1277,7 +1277,7 @@
 {
 	char* result = out;
 	char rawNum[30];
-	sprintf(rawNum, "%llu", in);
+	sprintf(rawNum, "%lu", in);
 	const int rawNumLen = strlen(rawNum);
 	for(int i=0; i < rawNumLen-1; ++i) {
 		*out++ = rawNum[i];
@@ -1335,7 +1335,7 @@
 	try {
 		PerformanceStatistics statistics;
 		statistics.startTool = mach_absolute_time();
-		
+
 		// create object to track command line arguments
 		Options options(argc, argv);
 		if (options.dumpNormalizedLibArgs()) {
@@ -1361,20 +1361,20 @@
 		// update strings for error messages
 		showArch = options.printArchPrefix();
 		archName = options.architectureName();
-		
+
 		// open and parse input files
 		statistics.startInputFileProcessing = mach_absolute_time();
 		ld::tool::InputFiles inputFiles(options);
-		
+
 		// load and resolve all references
 		statistics.startResolver = mach_absolute_time();
 		ld::tool::Resolver resolver(options, inputFiles, state);
 		resolver.resolve();
-        
+
 		// add dylibs used
 		statistics.startDylibs = mach_absolute_time();
 		inputFiles.dylibs(state);
-	
+
 		// do initial section sorting so passes have rough idea of the layout
 		state.sortSections();
 
@@ -1412,7 +1412,7 @@
 		ld::tool::OutputFile out(options);
 		out.write(state);
 		statistics.startDone = mach_absolute_time();
-		
+
 		// print statistics
 		//mach_o::relocatable::printCounts();
 		if ( options.printStatistics() ) {
@@ -1425,9 +1425,9 @@
 			printTime(" build atom list", statistics.startPasses				 -	statistics.startDylibs,				totalTime);
 			printTime(" passess", statistics.startOutput				 -	statistics.startPasses,				totalTime);
 			printTime(" write output", statistics.startDone				 -	statistics.startOutput,				totalTime);
-			fprintf(stderr, "pageins=%u, pageouts=%u, faults=%u\n", 
+			fprintf(stderr, "pageins=%u, pageouts=%u, faults=%u\n",
 								statistics.vmEnd.pageins-statistics.vmStart.pageins,
-								statistics.vmEnd.pageouts-statistics.vmStart.pageouts, 
+								statistics.vmEnd.pageouts-statistics.vmStart.pageouts,
 								statistics.vmEnd.faults-statistics.vmStart.faults);
 			char temp[40];
 			fprintf(stderr, "processed %3u object files,  totaling %15s bytes\n", inputFiles._totalObjectLoaded, commatize(inputFiles._totalObjectSize, temp));
@@ -1474,7 +1474,7 @@
 {
 #ifdef HAVE_EXECINFO_H // ld64-port
     Snapshot *snapshot = Snapshot::globalSnapshot;
-    
+
     snapshot->setSnapshotMode(Snapshot::SNAPSHOT_DEBUG);
     snapshot->createSnapshot();
 	snapshot->recordAssertionMessage("Assertion failed: (%s), function %s, file %s, line %d.\n", failedexpr, func, file, line);
diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/LinkEdit.hpp cctools-port-format/cctools/ld64/src/ld/LinkEdit.hpp
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/LinkEdit.hpp	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/LinkEdit.hpp	2020-11-26 20:07:47.206874452 -0800
@@ -63,7 +63,7 @@
 			value = value >> 7;
 		} while( byte >= 0x80 );
 	}
-	
+
 	void append_sleb128(int64_t value) {
 		bool isNeg = ( value < 0 );
 		uint8_t byte;
@@ -71,17 +71,17 @@
 		do {
 			byte = value & 0x7F;
 			value = value >> 7;
-			if ( isNeg ) 
+			if ( isNeg )
 				more = ( (value != -1) || ((byte & 0x40) == 0) );
 			else
 				more = ( (value != 0) || ((byte & 0x40) != 0) );
 			if ( more )
 				byte |= 0x80;
 			_data.push_back(byte);
-		} 
+		}
 		while( more );
 	}
-	
+
 	void append_delta_encoded_uleb128_run(uint64_t start, const std::vector<uint64_t>& locations) {
 		uint64_t lastAddr = start;
 		for(std::vector<uint64_t>::const_iterator it = locations.begin(); it != locations.end(); ++it) {
@@ -98,11 +98,11 @@
 			_data.push_back(*s);
 		_data.push_back('\0');
 	}
-	
+
 	void append_byte(uint8_t byte) {
 		_data.push_back(byte);
 	}
-	
+
 	void append_mem(const void* mem, size_t len) {
 		_data.insert(_data.end(), (uint8_t*)mem, (uint8_t*)mem + len);
 	}
@@ -115,7 +115,7 @@
 		} while ( value != 0 );
 		return result;
 	}
-	
+
 	void pad_to_size(unsigned int alignment) {
 		while ( (_data.size() % alignment) != 0 )
 			_data.push_back(0);
@@ -131,20 +131,20 @@
 	virtual ld::File*							file() const		{ return NULL; }
 	virtual uint64_t							objectAddress() const { return 0; }
 	virtual uint64_t							size() const;
-	virtual void								copyRawContent(uint8_t buffer[]) const; 
+	virtual void								copyRawContent(uint8_t buffer[]) const;
 
 	virtual void								encode() const = 0;
 
 	const uint8_t*								rawContent() const { return this->_encodedData.start(); }
 
-												LinkEditAtom(const Options& opts, ld::Internal& state, 
+												LinkEditAtom(const Options& opts, ld::Internal& state,
 																OutputFile& writer, const ld::Section& sect,
 																unsigned int pointerSize)
 												: ld::Atom(sect, ld::Atom::definitionRegular,
 															ld::Atom::combineNever, ld::Atom::scopeTranslationUnit,
 															ld::Atom::typeUnclassified, ld::Atom::symbolTableNotIn,
-															false, false, false, ld::Atom::Alignment(log2(pointerSize))), 
-														_options(opts), _state(state), _writer(writer), 
+															false, false, false, ld::Atom::Alignment(log2(pointerSize))),
+														_options(opts), _state(state), _writer(writer),
 														_encoded(false) { }
 protected:
 	const Options&				_options;
@@ -195,7 +195,7 @@
 	typedef typename A::P						P;
 	typedef typename A::P::E					E;
 	typedef typename A::P::uint_t				pint_t;
-	
+
 	static ld::Section			_s_section;
 };
 
@@ -207,7 +207,7 @@
 void RebaseInfoAtom<A>::encode() const
 {
 	// omit relocs if this was supposed to be PIE but PIE not possible
-	if ( _options.positionIndependentExecutable() && this->_writer.pieDisabled ) 
+	if ( _options.positionIndependentExecutable() && this->_writer.pieDisabled )
 		return;
 
 	// sort rebase info by type, then address
@@ -216,7 +216,7 @@
 		return;
 
 	std::sort(info.begin(), info.end());
-	
+
 	// use encoding based on target minOS
 	if ( _options.useLinkedListBinding() && !this->_writer._hasUnalignedFixup ) {
 		if ( info.back()._type != REBASE_TYPE_POINTER )
@@ -238,7 +238,7 @@
 	std::vector<rebase_tmp> mid;
 	uint64_t curSegStart = 0;
 	uint64_t curSegEnd = 0;
-	uint32_t curSegIndex = 0;	
+	uint32_t curSegIndex = 0;
 	uint8_t type = 0;
 	uint64_t address = (uint64_t)(-1);
 	for (std::vector<OutputFile::RebaseInfo>::iterator it = info.begin(); it != info.end(); ++it) {
@@ -285,8 +285,8 @@
 	// optimize phase 2, combine rebase/add pairs
 	dst = &mid[0];
 	for (const rebase_tmp* src = &mid[0]; src->opcode != REBASE_OPCODE_DONE; ++src) {
-		if ( (src->opcode == REBASE_OPCODE_DO_REBASE_ULEB_TIMES) 
-				&& (src->operand1 == 1) 
+		if ( (src->opcode == REBASE_OPCODE_DO_REBASE_ULEB_TIMES)
+				&& (src->operand1 == 1)
 				&& (src[1].opcode == REBASE_OPCODE_ADD_ADDR_ULEB)) {
 			dst->opcode = REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB;
 			dst->operand1 = src[1].operand1;
@@ -298,16 +298,16 @@
 		}
 	}
 	dst->opcode = REBASE_OPCODE_DONE;
-	
+
 	// optimize phase 3, compress packed runs of REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB with
 	// same addr delta into one REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB
 	dst = &mid[0];
 	for (const rebase_tmp* src = &mid[0]; src->opcode != REBASE_OPCODE_DONE; ++src) {
 		uint64_t delta = src->operand1;
-		if ( (src->opcode == REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB) 
-				&& (src[1].opcode == REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB) 
-				&& (src[2].opcode == REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB) 
-				&& (src[1].operand1 == delta) 
+		if ( (src->opcode == REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB)
+				&& (src[1].opcode == REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB)
+				&& (src[2].opcode == REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB)
+				&& (src[1].operand1 == delta)
 				&& (src[2].operand1 == delta) ) {
 			// found at least three in a row, this is worth compressing
 			dst->opcode = REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB;
@@ -327,10 +327,10 @@
 		}
 	}
 	dst->opcode = REBASE_OPCODE_DONE;
-	
+
 	// optimize phase 4, use immediate encodings
 	for (rebase_tmp* p = &mid[0]; p->opcode != REBASE_OPCODE_DONE; ++p) {
-		if ( (p->opcode == REBASE_OPCODE_ADD_ADDR_ULEB) 
+		if ( (p->opcode == REBASE_OPCODE_ADD_ADDR_ULEB)
 			&& (p->operand1 < (15*sizeof(pint_t)))
 			&& ((p->operand1 % sizeof(pint_t)) == 0) ) {
 			p->opcode = REBASE_OPCODE_ADD_ADDR_IMM_SCALED;
@@ -352,47 +352,47 @@
 				done = true;
 				break;
 			case REBASE_OPCODE_SET_TYPE_IMM:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_SET_TYPE_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_SET_TYPE_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(REBASE_OPCODE_SET_TYPE_IMM | it->operand1);
 				break;
 			case REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%lld, 0x%llX)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%ld, 0x%lX)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB | it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
 				break;
 			case REBASE_OPCODE_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(REBASE_OPCODE_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case REBASE_OPCODE_ADD_ADDR_IMM_SCALED:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_ADD_ADDR_IMM_SCALED(%lld=0x%llX)\n", it->operand1, it->operand1*sizeof(pint_t));
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_ADD_ADDR_IMM_SCALED(%ld=0x%lX)\n", it->operand1, it->operand1*sizeof(pint_t));
 				this->_encodedData.append_byte(REBASE_OPCODE_ADD_ADDR_IMM_SCALED | it->operand1 );
 				break;
 			case REBASE_OPCODE_DO_REBASE_IMM_TIMES:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_IMM_TIMES(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_IMM_TIMES(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(REBASE_OPCODE_DO_REBASE_IMM_TIMES | it->operand1);
 				break;
 			case REBASE_OPCODE_DO_REBASE_ULEB_TIMES:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_ULEB_TIMES(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_ULEB_TIMES(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(REBASE_OPCODE_DO_REBASE_ULEB_TIMES);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB(%lld, %lld)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB(%ld, %ld)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
 				break;
 		}
 	}
-	
-		
+
+
 	// align to pointer size
 	this->_encodedData.pad_to_size(sizeof(pint_t));
 
@@ -425,7 +425,7 @@
 
 	struct binding_tmp
 	{
-		binding_tmp(uint8_t op, uint64_t p1, uint64_t p2=0, const char* s=NULL) 
+		binding_tmp(uint8_t op, uint64_t p1, uint64_t p2=0, const char* s=NULL)
 			: opcode(op), operand1(p1), operand2(p2), name(s) {}
 		uint8_t		opcode;
 		uint64_t	operand1;
@@ -463,7 +463,7 @@
 	std::vector<binding_tmp> mid;
 	uint64_t curSegStart = 0;
 	uint64_t curSegEnd = 0;
-	uint32_t curSegIndex = 0;	
+	uint32_t curSegIndex = 0;
 	int ordinal = 0x80000000;
 	const char* symbolName = NULL;
 	uint8_t type = 0;
@@ -512,7 +512,7 @@
 	// optimize phase 1, combine bind/add pairs
 	binding_tmp* dst = &mid[0];
 	for (const binding_tmp* src = &mid[0]; src->opcode != BIND_OPCODE_DONE; ++src) {
-		if ( (src->opcode == BIND_OPCODE_DO_BIND) 
+		if ( (src->opcode == BIND_OPCODE_DO_BIND)
 				&& (src[1].opcode == BIND_OPCODE_ADD_ADDR_ULEB) ) {
 			dst->opcode = BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB;
 			dst->operand1 = src[1].operand1;
@@ -530,8 +530,8 @@
 	dst = &mid[0];
 	for (const binding_tmp* src = &mid[0]; src->opcode != BIND_OPCODE_DONE; ++src) {
 		uint64_t delta = src->operand1;
-		if ( (src->opcode == BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB) 
-				&& (src[1].opcode == BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB) 
+		if ( (src->opcode == BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB)
+				&& (src[1].opcode == BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB)
 				&& (src[1].operand1 == delta) ) {
 			// found at least two in a row, this is worth compressing
 			dst->opcode = BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB;
@@ -551,10 +551,10 @@
 		}
 	}
 	dst->opcode = BIND_OPCODE_DONE;
-	
+
 	// optimize phase 3, use immediate encodings
 	for (binding_tmp* p = &mid[0]; p->opcode != REBASE_OPCODE_DONE; ++p) {
-		if ( (p->opcode == BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB) 
+		if ( (p->opcode == BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB)
 			&& (p->operand1 < (15*sizeof(pint_t)))
 			&& ((p->operand1 % sizeof(pint_t)) == 0) ) {
 			p->opcode = BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED;
@@ -563,7 +563,7 @@
 		else if ( (p->opcode == BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB) && (p->operand1 <= 15) ) {
 			p->opcode = BIND_OPCODE_SET_DYLIB_ORDINAL_IMM;
 		}
-	}	
+	}
 	dst->opcode = BIND_OPCODE_DONE;
 
 	// convert to compressed encoding
@@ -577,39 +577,39 @@
 				done = true;
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_ORDINAL_IMM | it->operand1);
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_SPECIAL_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_SPECIAL_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_SPECIAL_IMM | (it->operand1 & BIND_IMMEDIATE_MASK));
 				break;
 			case BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM(0x%0llX, %s)\n", it->operand1, it->name);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM(0x%0lX, %s)\n", it->operand1, it->name);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM | it->operand1);
 				this->_encodedData.append_string(it->name);
 				break;
 			case BIND_OPCODE_SET_TYPE_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_TYPE_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_TYPE_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_TYPE_IMM | it->operand1);
 				break;
 			case BIND_OPCODE_SET_ADDEND_SLEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_ADDEND_SLEB(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_ADDEND_SLEB(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_ADDEND_SLEB);
 				this->_encodedData.append_sleb128(it->operand1);
 				break;
 			case BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%lld, 0x%llX)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%ld, 0x%lX)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB | it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
 				break;
 			case BIND_OPCODE_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
@@ -618,23 +618,23 @@
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND);
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED(%lld=0x%llX)\n", it->operand1, it->operand1*sizeof(pint_t));
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED(%ld=0x%lX)\n", it->operand1, it->operand1*sizeof(pint_t));
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED | it->operand1 );
 				break;
 			case BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB(%lld, %lld)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB(%ld, %ld)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
 				break;
 		}
 	}
-	
+
 	// align to pointer size
 	this->_encodedData.pad_to_size(sizeof(pint_t));
 
@@ -714,7 +714,7 @@
 
 	// We can only support 2^16 bind ordinals.
 	if ( (numBinds > 0x10000) && (numBinds != (uint64_t)(-1)) )
-		throwf("too many binds (%llu).  The limit is 65536", numBinds);
+		throwf("too many binds (%lu).  The limit is 65536", numBinds);
 
 	// Now that we have the bind ordinal table populate, set the page starts.
 
@@ -778,7 +778,7 @@
 	this->_encodedData.reserve(bindInfo.size()*2);
 
 	// First push the total number of binds so that we can allocate space for this in dyld.
-	if ( log ) fprintf(stderr, "BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB(%lld)\n", numBinds + 1);
+	if ( log ) fprintf(stderr, "BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB(%ld)\n", numBinds + 1);
 	this->_encodedData.append_byte(BIND_OPCODE_THREADED | BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB);
 	this->_encodedData.append_uleb128(numBinds + 1);
 
@@ -790,39 +790,39 @@
 				done = true;
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_ORDINAL_IMM | it->operand1);
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_SPECIAL_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_SPECIAL_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_SPECIAL_IMM | (it->operand1 & BIND_IMMEDIATE_MASK));
 				break;
 			case BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM(0x%0llX, %s)\n", it->operand1, it->name);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM(0x%0lX, %s)\n", it->operand1, it->name);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM | it->operand1);
 				this->_encodedData.append_string(it->name);
 				break;
 			case BIND_OPCODE_SET_TYPE_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_TYPE_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_TYPE_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_TYPE_IMM | it->operand1);
 				break;
 			case BIND_OPCODE_SET_ADDEND_SLEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_ADDEND_SLEB(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_ADDEND_SLEB(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_ADDEND_SLEB);
 				this->_encodedData.append_sleb128(it->operand1);
 				break;
 			case BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%lld, 0x%llX)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%ld, 0x%lX)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB | it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
 				break;
 			case BIND_OPCODE_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
@@ -831,22 +831,22 @@
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND);
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED(%lld=0x%llX)\n", it->operand1, it->operand1*sizeof(pint_t));
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED(%ld=0x%lX)\n", it->operand1, it->operand1*sizeof(pint_t));
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED | it->operand1 );
 				break;
 			case BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB(%lld, %lld)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB(%ld, %ld)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
 				break;
 			case BIND_OPCODE_THREADED | BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB:
-				if ( log ) fprintf(stderr, "BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_THREADED | BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
@@ -886,7 +886,7 @@
 	typedef typename A::P::uint_t				pint_t;
 
 	struct WeakBindingSorter
-	{	
+	{
 		 bool operator()(const OutputFile::BindingInfo& left, const OutputFile::BindingInfo& right)
 		 {
 			// sort by symbol, type, address
@@ -897,10 +897,10 @@
 			return  (left._address < right._address);
 		 }
 	};
-	
+
 	struct binding_tmp
 	{
-		binding_tmp(uint8_t op, uint64_t p1, uint64_t p2=0, const char* s=NULL) 
+		binding_tmp(uint8_t op, uint64_t p1, uint64_t p2=0, const char* s=NULL)
 			: opcode(op), operand1(p1), operand2(p2), name(s) {}
 		uint8_t		opcode;
 		uint64_t	operand1;
@@ -926,13 +926,13 @@
 		return;
 	}
 	std::sort(info.begin(), info.end(), WeakBindingSorter());
-	
+
 	// convert to temp encoding that can be more easily optimized
 	std::vector<binding_tmp> mid;
 	mid.reserve(info.size());
 	uint64_t curSegStart = 0;
 	uint64_t curSegEnd = 0;
-	uint32_t curSegIndex = 0;	
+	uint32_t curSegIndex = 0;
 	const char* symbolName = NULL;
 	uint8_t type = 0;
 	uint64_t address = (uint64_t)(-1);
@@ -974,7 +974,7 @@
 	// optimize phase 1, combine bind/add pairs
 	binding_tmp* dst = &mid[0];
 	for (const binding_tmp* src = &mid[0]; src->opcode != BIND_OPCODE_DONE; ++src) {
-		if ( (src->opcode == BIND_OPCODE_DO_BIND) 
+		if ( (src->opcode == BIND_OPCODE_DO_BIND)
 				&& (src[1].opcode == BIND_OPCODE_ADD_ADDR_ULEB) ) {
 			dst->opcode = BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB;
 			dst->operand1 = src[1].operand1;
@@ -992,8 +992,8 @@
 	dst = &mid[0];
 	for (const binding_tmp* src = &mid[0]; src->opcode != BIND_OPCODE_DONE; ++src) {
 		uint64_t delta = src->operand1;
-		if ( (src->opcode == BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB) 
-				&& (src[1].opcode == BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB) 
+		if ( (src->opcode == BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB)
+				&& (src[1].opcode == BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB)
 				&& (src[1].operand1 == delta) ) {
 			// found at least two in a row, this is worth compressing
 			dst->opcode = BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB;
@@ -1013,16 +1013,16 @@
 		}
 	}
 	dst->opcode = BIND_OPCODE_DONE;
-	
+
 	// optimize phase 3, use immediate encodings
 	for (binding_tmp* p = &mid[0]; p->opcode != REBASE_OPCODE_DONE; ++p) {
-		if ( (p->opcode == BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB) 
+		if ( (p->opcode == BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB)
 			&& (p->operand1 < (15*sizeof(pint_t)))
 			&& ((p->operand1 % sizeof(pint_t)) == 0) ) {
 			p->opcode = BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED;
 			p->operand1 = p->operand1/sizeof(pint_t);
 		}
-	}	
+	}
 	dst->opcode = BIND_OPCODE_DONE;
 
 
@@ -1038,39 +1038,39 @@
 				done = true;
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_ORDINAL_IMM | it->operand1);
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_SPECIAL_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_SPECIAL_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_SPECIAL_IMM | (it->operand1 & BIND_IMMEDIATE_MASK));
 				break;
 			case BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM(0x%0llX, %s)\n", it->operand1, it->name);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM(0x%0lX, %s)\n", it->operand1, it->name);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM | it->operand1);
 				this->_encodedData.append_string(it->name);
 				break;
 			case BIND_OPCODE_SET_TYPE_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_TYPE_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_TYPE_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_TYPE_IMM | it->operand1);
 				break;
 			case BIND_OPCODE_SET_ADDEND_SLEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_ADDEND_SLEB(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_ADDEND_SLEB(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_ADDEND_SLEB);
 				this->_encodedData.append_sleb128(it->operand1);
 				break;
 			case BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%lld, 0x%llX)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%ld, 0x%lX)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB | it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
 				break;
 			case BIND_OPCODE_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
@@ -1079,30 +1079,30 @@
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND);
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED(%lld=0x%llX)\n", it->operand1, it->operand1*sizeof(pint_t));
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED(%ld=0x%lX)\n", it->operand1, it->operand1*sizeof(pint_t));
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED | it->operand1 );
 				break;
 			case BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB(%lld, %lld)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB(%ld, %ld)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
 				break;
 		}
 	}
-	
+
 	// align to pointer size
 	this->_encodedData.pad_to_size(sizeof(pint_t));
 
 	this->_encoded = true;
 
 	if (log) fprintf(stderr, "total weak binding info size = %ld\n", this->_encodedData.size());
-	
+
 }
 
 
@@ -1123,7 +1123,7 @@
 	typedef typename A::P						P;
 	typedef typename A::P::E					E;
 	typedef typename A::P::uint_t				pint_t;
-	
+
 	static ld::Section			_s_section;
 };
 
@@ -1144,12 +1144,12 @@
 		// write address to bind
 		uint64_t segStart = 0;
 		uint64_t segEnd = 0;
-		uint32_t segIndex = 0;	
+		uint32_t segIndex = 0;
 		if ( ! this->_writer.findSegment(this->_state, it->_address, &segStart, &segEnd, &segIndex) )
 			throw "lazy binding address outside range of any segment";
 		this->_encodedData.append_byte(BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB | segIndex);
 		this->_encodedData.append_uleb128(it->_address - segStart);
-		
+
 		// write ordinal
 		if ( it->_libraryOrdinal <= 0 ) {
 			// special lookups are encoded as negative numbers in BindingInfo
@@ -1170,10 +1170,10 @@
 		this->_encodedData.append_byte(BIND_OPCODE_DO_BIND);
 		this->_encodedData.append_byte(BIND_OPCODE_DONE);
 	}
-	
+
 	// align to pointer size
 	this->_encodedData.pad_to_size(sizeof(pint_t));
-	
+
 	this->_encoded = true;
 	//fprintf(stderr, "lazy binding info size = %ld, for %ld entries\n", _encodedData.size(), allLazys.size());
 }
@@ -1368,14 +1368,14 @@
 	struct TrieEntriesSorter
 	{
 		TrieEntriesSorter(const Options& o) : _options(o) {}
-		
+
 		 bool operator()(const mach_o::trie::Entry& left, const mach_o::trie::Entry& right)
 		 {
 			unsigned int leftOrder;
 			unsigned int rightOrder;
 			_options.exportedSymbolOrder(left.name, &leftOrder);
 			_options.exportedSymbolOrder(right.name, &rightOrder);
-			if ( leftOrder != rightOrder ) 
+			if ( leftOrder != rightOrder )
 				return (leftOrder < rightOrder);
 			else
 				return (left.address < right.address);
@@ -1383,7 +1383,7 @@
 	private:
 		const Options&	_options;
 	};
-	
+
 	static ld::Section			_s_section;
 };
 
@@ -1477,8 +1477,8 @@
 			}
 			entry.name = atom->name();
 			entry.flags = flags;
-			entry.address = address; 
-			entry.other = other; 
+			entry.address = address;
+			entry.other = other;
 			entry.importName = NULL;
 			entries.push_back(entry);
 		}
@@ -1493,7 +1493,7 @@
 
 	// sort vector by -exported_symbols_order, and any others by address
 	std::sort(entries.begin(), entries.end(), TrieEntriesSorter(_options));
-	
+
 	// create trie
 	mach_o::trie::makeTrie(entries, this->_encodedData.bytes());
 
@@ -1503,7 +1503,7 @@
 
 	// align to pointer size
 	this->_encodedData.pad_to_size(sizeof(pint_t));
-	
+
 	this->_encoded = true;
 }
 
@@ -1574,7 +1574,7 @@
 			break;
 #endif
 		default:
-			warning("codegen at address 0x%08llX prevents image from working in dyld shared cache", address);
+			warning("codegen at address 0x%08lX prevents image from working in dyld shared cache", address);
 			break;
 	}
 }
@@ -1590,7 +1590,7 @@
 			_32bitPointerLocations.push_back(address);
 			break;
 		default:
-			warning("codegen at address 0x%08llX prevents image from working in dyld shared cache", address);
+			warning("codegen at address 0x%08lX prevents image from working in dyld shared cache", address);
 			break;
 	}
 }
@@ -1605,19 +1605,19 @@
         case ld::Fixup::kindStoreARMLow16:
  			_armLo16Locations.push_back(address);
 			break;
-       case ld::Fixup::kindStoreThumbLow16: 
+       case ld::Fixup::kindStoreThumbLow16:
 			_thumbLo16Locations.push_back(address);
 			break;
-        case ld::Fixup::kindStoreARMHigh16: 
+        case ld::Fixup::kindStoreARMHigh16:
             assert(extra < 16);
 			_armHi16Locations[extra].push_back(address);
 			break;
-        case ld::Fixup::kindStoreThumbHigh16: 
+        case ld::Fixup::kindStoreThumbHigh16:
             assert(extra < 16);
 			_thumbHi16Locations[extra].push_back(address);
 			break;
 		default:
-			warning("codegen at address 0x%08llX prevents image from working in dyld shared cache", address);
+			warning("codegen at address 0x%08lX prevents image from working in dyld shared cache", address);
 			break;
 	}
 }
@@ -1647,11 +1647,11 @@
 #if SUPPORT_ARCH_arm64e
 		case ld::Fixup::kindStoreLittleEndianAuth64:
 		case ld::Fixup::kindStoreTargetAddressLittleEndianAuth64:
-			warning("authenticated pointer at address 0x%08llX prevents image from working in dyld shared cache", address);
+			warning("authenticated pointer at address 0x%08lX prevents image from working in dyld shared cache", address);
 			break;
 #endif
 		default:
-			warning("codegen at address 0x%08llX prevents image from working in dyld shared cache", address);
+			warning("codegen at address 0x%08lX prevents image from working in dyld shared cache", address);
 			break;
 	}
 }
@@ -1666,7 +1666,7 @@
 		//fprintf(stderr, "nextAddr=0x%0llX\n", (uint64_t)nextAddr);
 		uint64_t delta = nextAddr - addr;
 		//fprintf(stderr, "delta=0x%0llX\n", delta);
-		if ( delta == 0 ) 
+		if ( delta == 0 )
 			throw "double split seg info for same address";
 		// uleb128 encode
 		uint8_t byte;
@@ -1677,7 +1677,7 @@
 				byte |= 0x80;
 			this->_encodedData.append_byte(byte);
 			delta = delta >> 7;
-		} 
+		}
 		while( byte >= 0x80 );
 		addr = nextAddr;
 	}
@@ -1702,7 +1702,7 @@
 		this->uleb128EncodeAddresses(_32bitPointerLocations);
 		this->_encodedData.append_byte(0); // terminator
 	}
-	
+
 	if ( _64bitPointerLocations.size() != 0 ) {
 		this->_encodedData.append_byte(2);
 		//fprintf(stderr, "type 2:\n");
@@ -1760,9 +1760,9 @@
 
 	// align to pointer size
 	this->_encodedData.pad_to_size(sizeof(pint_t));
-	
+
 	this->_encoded = true;
-	
+
 	// clean up temporaries
 	_32bitPointerLocations.clear();
 	_64bitPointerLocations.clear();
@@ -1820,7 +1820,7 @@
 
 	// Add marker that this is V2 data
 	this->_encodedData.reserve(8192);
-	this->_encodedData.append_byte(DYLD_CACHE_ADJ_V2_FORMAT); 
+	this->_encodedData.append_byte(DYLD_CACHE_ADJ_V2_FORMAT);
 
 	// stream out
 	// Whole :== <count> FromToSection+
@@ -1864,7 +1864,7 @@
 
 	// align to pointer size
 	this->_encodedData.pad_to_size(sizeof(pint_t));
-	
+
 	this->_encoded = true;
 }
 
@@ -1917,7 +1917,7 @@
 					continue;
 				uint64_t nextAddr = atom->finalAddress();
 				if ( atom->isThumb() )
-					nextAddr |= 1; 
+					nextAddr |= 1;
 				uint64_t delta = nextAddr - addr;
 				if ( delta != 0 )
 					this->_encodedData.append_uleb128(delta);
@@ -1925,12 +1925,12 @@
 			}
 		}
 	}
-	
+
 	// terminator
-	this->_encodedData.append_byte(0); 
-	
+	this->_encodedData.append_byte(0);
+
 	// align to pointer size
-	this->_encodedData.pad_to_size(sizeof(pint_t));		
+	this->_encodedData.pad_to_size(sizeof(pint_t));
 
 	this->_encoded = true;
 }
@@ -2040,7 +2040,7 @@
 				}
 				// to do: sort labels by address
 				std::sort(dataInCodeLabels.begin(), dataInCodeLabels.end(), FixupByAddressSorter());
-				
+
 				// convert to array of struct data_in_code_entry
 				ld::Fixup::Kind prevKind = ld::Fixup::kindDataInCodeEnd;
 				uint32_t prevOffset = 0;
@@ -2061,7 +2061,7 @@
 			}
 		}
 	}
-	
+
 	this->_encoded = true;
 }
 
@@ -2075,7 +2075,7 @@
 {
 public:
 												OptimizationHintsAtom(const Options& opts, ld::Internal& state, OutputFile& writer)
-													: LinkEditAtom(opts, state, writer, _s_section, sizeof(pint_t)) { 
+													: LinkEditAtom(opts, state, writer, _s_section, sizeof(pint_t)) {
 														assert(opts.outputKind() == Options::kObjectFile);
 													}
 
@@ -2108,7 +2108,7 @@
 				const ld::Atom*	atom = *ait;
 				uint64_t address = atom->finalAddress();
 				for (ld::Fixup::iterator fit = atom->fixupsBegin(); fit != atom->fixupsEnd(); ++fit) {
-					if ( fit->kind != ld::Fixup::kindLinkerOptimizationHint) 
+					if ( fit->kind != ld::Fixup::kindLinkerOptimizationHint)
 						continue;
 					ld::Fixup::LOH_arm64 extra;
 					extra.addend = fit->u.addend;
@@ -2124,15 +2124,15 @@
 				}
 			}
 		}
-			
+
 		this->_encodedData.pad_to_size(sizeof(pint_t));
 	}
-	
+
 	this->_encoded = true;
 }
 
 
-} // namespace tool 
-} // namespace ld 
+} // namespace tool
+} // namespace ld
 
 #endif // __LINKEDIT_HPP__
diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/Options.cpp cctools-port-format/cctools/ld64/src/ld/Options.cpp
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/Options.cpp	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/Options.cpp	2020-11-26 19:27:32.642874452 -0800
@@ -79,12 +79,12 @@
 #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1070 && HAVE_CRASHREPORTER_HEADER
 	#include <CrashReporterClient.h>
 	// hack until ld does not need to build on 10.6 anymore
-    struct crashreporter_annotations_t gCRAnnotations 
-        __attribute__((section("__DATA," CRASHREPORTER_ANNOTATIONS_SECTION))) 
+    struct crashreporter_annotations_t gCRAnnotations
+        __attribute__((section("__DATA," CRASHREPORTER_ANNOTATIONS_SECTION)))
         = { CRASHREPORTER_ANNOTATIONS_VERSION, 0, 0, 0, 0, 0, 0 };
 #else
 	extern "C" char* __crashreporter_info__;
-	__attribute__((used)) 
+	__attribute__((used))
 	char* __crashreporter_info__ = crashreporterBuffer;
 #endif
 
@@ -174,7 +174,7 @@
 		return true;
 	}
 	struct stat statBuffer;
-	if (p == NULL) 
+	if (p == NULL)
 	  p = path;
 	if ( stat(p, &statBuffer) == 0 ) {
 		if (p != path) path = strdup(p);
@@ -197,17 +197,17 @@
 	  fBaseAddress(0), fMaxAddress(0xFFFFFFFFFFFFFFFFULL),
 	  fBaseWritableAddress(0),
 	  fExportMode(kExportDefault), fLibrarySearchMode(kSearchDylibAndArchiveInEachDir),
-	  fUndefinedTreatment(kUndefinedError), fMessagesPrefixedWithArchitecture(true), 
+	  fUndefinedTreatment(kUndefinedError), fMessagesPrefixedWithArchitecture(true),
 	  fWeakReferenceMismatchTreatment(kWeakReferenceMismatchNonWeak),
 	  fClientName(NULL),
 	  fUmbrellaName(NULL), fInitFunctionName(NULL), fDotOutputFile(NULL), fExecutablePath(NULL),
 	  fBundleLoader(NULL), fDtraceScriptName(NULL), fMapPath(NULL),
 	  fDyldInstallPath("/usr/lib/dyld"), fLtoCachePath(NULL), fTempLtoObjectPath(NULL), fOverridePathlibLTO(NULL), fLtoCpu(NULL),
 	  fKextObjectsEnable(-1),fKextObjectsDirPath(NULL),fToolchainPath(NULL),fOrderFilePath(NULL),
-	  fZeroPageSize(ULLONG_MAX), fStackSize(0), fStackAddr(0), fSourceVersion(0), fSDKVersion(0), fExecutableStack(false), 
+	  fZeroPageSize(ULLONG_MAX), fStackSize(0), fStackAddr(0), fSourceVersion(0), fSDKVersion(0), fExecutableStack(false),
 	  fNonExecutableHeap(false), fDisableNonExecutableHeap(false),
 	  fMinimumHeaderPad(32), fSegmentAlignment(LD_PAGE_SIZE),
-	  fCommonsMode(kCommonsIgnoreDylibs),  fUUIDMode(kUUIDContent), fLocalSymbolHandling(kLocalSymbolsAll), fWarnCommons(false), 
+	  fCommonsMode(kCommonsIgnoreDylibs),  fUUIDMode(kUUIDContent), fLocalSymbolHandling(kLocalSymbolsAll), fWarnCommons(false),
 	  fVerbose(false), fKeepRelocations(false), fWarnStabs(false),
 	  fTraceDylibSearching(false), fPause(false), fStatistics(false), fPrintOptions(false),
 	  fSharedRegionEligible(false), fSharedRegionEligibleForceOff(false), fPrintOrderFileStatistics(false),
@@ -229,21 +229,21 @@
 	  fAutoOrderInitializers(true), fOptimizeZeroFill(true), fMergeZeroFill(false), fLogObjectFiles(false),
 	  fLogAllFiles(false), fTraceDylibs(false), fTraceIndirectDylibs(false), fTraceArchives(false), fTraceEmitJSON(false),
 	  fOutputSlidable(false), fWarnWeakExports(false), fNoWeakExports(false),
-	  fObjcGcCompaction(false), fObjCGc(false), fObjCGcOnly(false), 
-	  fDemangle(false), fTLVSupport(false), 
-	  fVersionLoadCommand(false), fVersionLoadCommandForcedOn(false), 
+	  fObjcGcCompaction(false), fObjCGc(false), fObjCGcOnly(false),
+	  fDemangle(false), fTLVSupport(false),
+	  fVersionLoadCommand(false), fVersionLoadCommandForcedOn(false),
 	  fVersionLoadCommandForcedOff(false), fForceLegacyVersionLoadCommands(false), fFunctionStartsLoadCommand(false),
 	  fFunctionStartsForcedOn(false), fFunctionStartsForcedOff(false),
 	  fDataInCodeInfoLoadCommand(false), fDataInCodeInfoLoadCommandForcedOn(false), fDataInCodeInfoLoadCommandForcedOff(false),
-	  fCanReExportSymbols(false), fObjcCategoryMerging(true), fPageAlignDataAtoms(false), 
+	  fCanReExportSymbols(false), fObjcCategoryMerging(true), fPageAlignDataAtoms(false),
 	  fNeedsThreadLoadCommand(false), fEntryPointLoadCommand(false),
 	  fSourceVersionLoadCommand(false),
-	  fSourceVersionLoadCommandForceOn(false), fSourceVersionLoadCommandForceOff(false), 
+	  fSourceVersionLoadCommandForceOn(false), fSourceVersionLoadCommandForceOff(false),
 	  fExportDynamic(false), fAbsoluteSymbols(false),
 	  fAllowSimulatorToLinkWithMacOSX(false), fSimulatorSupportDylib(false), fKeepDwarfUnwind(true),
 	  fKeepDwarfUnwindForcedOn(false), fKeepDwarfUnwindForcedOff(false),
 	  fVerboseOptimizationHints(false), fIgnoreOptimizationHints(false),
-	  fGenerateDtraceDOF(true), fAllowBranchIslands(true), fTraceSymbolLayout(false), 
+	  fGenerateDtraceDOF(true), fAllowBranchIslands(true), fTraceSymbolLayout(false),
 	  fMarkAppExtensionSafe(false), fCheckAppExtensionSafe(false), fForceLoadSwiftLibs(false),
 	  fSharedRegionEncodingV2(false), fUseDataConstSegment(false),
 	  fUseDataConstSegmentForceOn(false), fUseDataConstSegmentForceOff(false), fUseTextExecSegment(false),
@@ -268,7 +268,7 @@
 	this->parsePostCommandLineEnvironmentSettings();
 	this->reconfigureDefaults();
 	this->checkIllegalOptionCombinations();
-	
+
 	this->addDependency(depOutputFile, fOutputFile);
 	if ( fMapPath != NULL )
 		this->addDependency(depOutputFile, fMapPath);
@@ -343,7 +343,7 @@
 	//
 	switch ( fOutputKind ) {
 		case Options::kDynamicExecutable:
-			// <rdar://problem/12839986> Add the -export_dynamic flag 
+			// <rdar://problem/12839986> Add the -export_dynamic flag
 			return fExportDynamic;
 		case Options::kStaticExecutable:
 			// <rdar://problem/13361218> Support the -export_dynamic flag for xnu
@@ -441,7 +441,7 @@
 	// all others default to all
 	return VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE;
 }
-	
+
 uint64_t Options::segPageSize(const char* segName) const
 {
 	for(std::vector<SegmentSize>::const_iterator it=fCustomSegmentSizes.begin(); it != fCustomSegmentSizes.end(); ++it) {
@@ -728,7 +728,7 @@
 }
 
 const std::vector<const char*>* Options::sectionOrder(const char* segName) const
-{ 
+{
 	for (std::vector<SectionOrderList>::const_iterator it=fSectionOrder.begin(); it != fSectionOrder.end(); ++it) {
 		if ( strcmp(it->segmentName, segName) == 0 )
 			return &it->sectionOrder;
@@ -862,7 +862,7 @@
 			case Options::kDynamicExecutable:
 			case Options::kDynamicLibrary:
 			case Options::kDynamicBundle:
-			case Options::kObjectFile:  // <rdar://problem/15914513> 
+			case Options::kObjectFile:  // <rdar://problem/15914513>
 				lookForDylibs = true;
 				break;
 			case Options::kStaticExecutable:
@@ -1148,12 +1148,12 @@
 #if ((TAPI_API_VERSION_MAJOR == 1 &&  TAPI_API_VERSION_MINOR >= 3) || (TAPI_API_VERSION_MAJOR > 1))
 	tapi::LinkerInterfaceFile* interface = nullptr;
 	std::string TBDPath;
-	
+
 	// create parsing options.
 	tapi::ParsingFlags flags = tapi::ParsingFlags::None;
 	if (enforceDylibSubtypesMatch())
 		flags |= tapi::ParsingFlags::ExactCpuSubType;
-	
+
 	if (!allowWeakImports())
 		flags |= tapi::ParsingFlags::DisallowWeakImports;
 
@@ -1221,7 +1221,7 @@
 		if ( installName.rfind(frameworkDir) != std::string::npos )
 			isFramework = true;
 	}
-	
+
 	// These are abbreviated versions of the routines findFramework and findLibrary above
 	// because we already know the final name of the file that we're looking for and so
 	// don't need to try variations, just paths. We do need to add the additional bits
@@ -1338,7 +1338,7 @@
 	}
 }
 
-bool Options::SetWithWildcards::hasWildCards(const char* symbol) 
+bool Options::SetWithWildcards::hasWildCards(const char* symbol)
 {
 	// an exported symbol name containing *, ?, or [ requires wildcard matching
 	return ( strpbrk(symbol, "*?[") != NULL );
@@ -1714,7 +1714,7 @@
 	target[len] = '\0';
 	DylibOverride entry;
 	entry.installName = target;
-	entry.useInstead = &colon[1];	
+	entry.useInstead = &colon[1];
 	fDylibOverrides.push_back(entry);
 }
 
@@ -1789,7 +1789,7 @@
 	uint64_t rep32 = ((uint64_t)a << 40) |  ((uint64_t)b << 30) | ((uint64_t)c << 20);
 	if ( rep32 != fDylibCurrentVersion ) {
 		warning("truncating -current_version to fit in 32-bit space used by old mach-o format");
-		a = (fDylibCurrentVersion >> 40) & 0xFFFFFF;		
+		a = (fDylibCurrentVersion >> 40) & 0xFFFFFF;
 		if ( a > 0xFFFF )
 			a = 0xFFFF;
 		b = (fDylibCurrentVersion >> 30) & 0x3FF;
@@ -2010,7 +2010,7 @@
 						}
 					}
 					// trim leading spaces
-					while ( isspace(*symbolStart) ) 
+					while ( isspace(*symbolStart) )
 						++symbolStart;
 					Options::OrderedSymbol pair;
 					if ( cstring )
@@ -2121,14 +2121,14 @@
 {
 	if ( strlen(dstSegment) > 16 )
 		throwf("%s segment name max 16 chars", optionName);
-	
+
 	SymbolsMove tmp;
 	list.push_back(tmp);
 	SymbolsMove& info = list.back();
 	info.toSegment = dstSegment;
 	loadExportFile(symbolList, optionName, info.symbols);
 }
-		
+
 bool Options::moveRwSymbol(const char* symName, const char* filePath, const char*& seg, bool& wildCardMatch) const
 {
 	for (std::vector<SymbolsMove>::const_iterator it=fSymbolsMovesData.begin(); it != fSymbolsMovesData.end(); ++it) {
@@ -2492,7 +2492,7 @@
 {
     // Store the original args in the link snapshot.
     fLinkSnapshot.recordRawArgs(argc, argv);
-    
+
 	// pass one builds search list from -L and -F options
 	this->buildSearchPaths(argc, argv);
 
@@ -2753,9 +2753,9 @@
 				 if ( address == NULL )
 					throwf("%s missing <address>", arg);
 				fBaseAddress = parseAddress(address);
-				uint64_t temp = ((fBaseAddress+fSegmentAlignment-1) & (-fSegmentAlignment)); 
+				uint64_t temp = ((fBaseAddress+fSegmentAlignment-1) & (-fSegmentAlignment));
 				if ( fBaseAddress != temp ) {
-					warning("-seg1addr not %lld byte aligned, rounding up", fSegmentAlignment);
+					warning("-seg1addr not %ld byte aligned, rounding up", fSegmentAlignment);
 					fBaseAddress = temp;
 				}
 				cannotBeUsedWithBitcode(arg);
@@ -3059,9 +3059,9 @@
 				 if ( (seg.name == NULL) || (argv[i+1] == NULL) )
 					throw "-segaddr missing segName Adddress";
 				seg.address = parseAddress(argv[++i]);
-				uint64_t temp = ((seg.address+fSegmentAlignment-1) & (-fSegmentAlignment)); 
+				uint64_t temp = ((seg.address+fSegmentAlignment-1) & (-fSegmentAlignment));
 				if ( seg.address != temp )
-					warning("-segaddr %s not %lld byte aligned", seg.name, fSegmentAlignment);
+					warning("-segaddr %s not %ld byte aligned", seg.name, fSegmentAlignment);
 				fCustomSegmentAddresses.push_back(seg);
 				cannotBeUsedWithBitcode(arg);
 			}
@@ -3779,7 +3779,7 @@
 			else if ( strcmp(arg, "-page_align_data_atoms") == 0 ) {
 				fPageAlignDataAtoms = true;
 				cannotBeUsedWithBitcode(arg);
-			} 
+			}
 			else if (strcmp(arg, "-debug_snapshot") == 0) {
                 fLinkSnapshot.setSnapshotMode(Snapshot::SNAPSHOT_DEBUG);
                 fSnapshotRequested = true;
@@ -3971,7 +3971,7 @@
 					}
 				}
 				cannotBeUsedWithBitcode(arg);
-			}			
+			}
 			else if ( strcmp(arg, "-application_extension") == 0 ) {
 				fMarkAppExtensionSafe = true;
 				fCheckAppExtensionSafe = true;
@@ -4037,7 +4037,7 @@
 					warning("zero is not a valid -max_default_common_align");
 					value = 1;
 				}
-				// alignment is power of 2 
+				// alignment is power of 2
 				uint8_t alignment = (uint8_t)__builtin_ctz(value);
 				if ( (unsigned long)(1 << alignment) != value ) {
 					warning("alignment for -max_default_common_align is not a power of two, using 0x%X", 1 << alignment);
@@ -4093,7 +4093,7 @@
 			else {
 				throwf("unknown option: %s", arg);
 			}
-            
+
             if (snapshotArgCount == -1)
                 snapshotArgCount = i-snapshotArgIndex+1;
             if (snapshotArgCount > 0)
@@ -4108,14 +4108,14 @@
 				fInputFiles.push_back(info);
 		}
 	}
-	
+
 	// if a -lazy option was used, implicitly link in lazydylib1.o
 	if ( fUsingLazyDylibLinking ) {
 		FileInfo info = findLibrary("lazydylib1.o");
 		info.ordinal = ld::File::Ordinal::makeArgOrdinal((uint16_t)argc);
 		addLibrary(info);
 	}
-    
+
     if (fSnapshotRequested)
         fLinkSnapshot.createSnapshot();
 
@@ -4178,7 +4178,7 @@
 					throw "-L missing argument";
 				libSearchDir = path;
 			}
-			if ( libSearchDir[0] == '\0' ) 
+			if ( libSearchDir[0] == '\0' )
 				throw "-L must be immediately followed by a directory path (no space)";
 			libraryPaths.push_back(libSearchDir);
 		}
@@ -4192,7 +4192,7 @@
 					throw "-F missing argument";
 				frameworkSearchDir = path;
 			}
-			if ( frameworkSearchDir[0] == '\0' ) 
+			if ( frameworkSearchDir[0] == '\0' )
 				throw "-F must be immediately followed by a directory path (no space)";
 			frameworkPaths.push_back(frameworkSearchDir);
 		}
@@ -4309,7 +4309,7 @@
 		// <rdar://problem/5433882> remove /Network/Library/Frameworks from default search path
 	}
 
-	// <rdar://problem/5829579> Support for configure based hacks 
+	// <rdar://problem/5829579> Support for configure based hacks
 	// if last -syslibroot is /, then ignore all syslibroots
 	if ( fSDKPaths.size() > 0 ) {
 		if ( strcmp(fSDKPaths.back(), "/") == 0 ) {
@@ -4454,7 +4454,7 @@
 	    fTraceDylibs = true;
 		fTraceIndirectDylibs = true;
 	}
-	
+
 	if ((getenv("LD_TRACE_DEPENDENTS") != NULL)) {
 		fTraceEmitJSON 		 = true;
 		// <rdar://problem/43652680> ld64 should ignore LD_TRACE_ARCHIVES and LD_TRACE_DYLIBS if LD_TRACE_DEPENDENTS is set in the environment
@@ -4486,22 +4486,22 @@
 		fMarkAppExtensionSafe = true;
 		fCheckAppExtensionSafe = false;
 	}
-	
+
 	if (getenv("LD_ALLOW_CPU_SUBTYPE_MISMATCHES") != NULL)
 		fAllowCpuSubtypeMismatches = true;
-	
+
 	if (getenv("LD_DYLIB_CPU_SUBTYPES_MUST_MATCH") != NULL)
 		fEnforceDylibSubtypesMatch = true;
 
 	if (getenv("LD_WARN_ON_SWIFT_ABI_VERSION_MISMATCHES") != NULL)
 		fWarnOnSwiftABIVersionMismatches = true;
-	
+
 	sWarningsSideFilePath = getenv("LD_WARN_FILE");
-	
+
 	const char* customDyldPath = getenv("LD_DYLD_PATH");
-	if ( customDyldPath != NULL ) 
+	if ( customDyldPath != NULL )
 		fDyldInstallPath = customDyldPath;
-    
+
     const char* debugArchivePath = getenv("LD_DEBUG_SNAPSHOT");
     if (debugArchivePath != NULL) {
         fLinkSnapshot.setSnapshotMode(Snapshot::SNAPSHOT_DEBUG);
@@ -4533,7 +4533,7 @@
 
 	// <rdar://problem/38679559> ld64 should consider RC_RELEASE when calculating a binary's UUID
 	fBuildContextName = getenv("RC_RELEASE");
-	
+
 #ifdef TAPI_SUPPORT
 	if (getenv("LD_PREFER_TAPI_FILE") != NULL)
 		fPreferTAPIFile = true;
@@ -4567,18 +4567,18 @@
 			}
 		}
 	}
-	
+
 	// allow build system to force on -warn_commons
 	if ( getenv("LD_WARN_COMMONS") != NULL )
 		fWarnCommons = true;
-	
+
 	// allow B&I to set default -source_version
 	if ( fSourceVersion == 0 ) {
 		const char* vers = getenv("RC_ProjectSourceVersion");
 		if ( vers != NULL )
 			fSourceVersion = parseVersionNumber64(vers);
 	}
-		
+
 }
 
 
@@ -4698,7 +4698,7 @@
 				fFunctionStartsLoadCommand = true;
 			break;
 	}
-		
+
 	// adjust kext type based on architecture
 	if ( fOutputKind == kKextBundle ) {
 		switch ( fArchitecture ) {
@@ -4713,7 +4713,7 @@
 				// arm64 uses new MH_KEXT_BUNDLE type
 				fMakeCompressedDyldInfo = false;
 				fMakeCompressedDyldInfoForceOff = true;
-				fAllowTextRelocs = false; 
+				fAllowTextRelocs = false;
 				fKextsUseStubs = true;
 				fUndefinedTreatment = kUndefinedDynamicLookup;
 				break;
@@ -4761,7 +4761,7 @@
 			}
 			// range check -seg1addr for ARM
 			if ( fBaseAddress > fMaxAddress ) {
-				warning("ignoring -seg1addr 0x%08llX.  Address out of range.", fBaseAddress);
+				warning("ignoring -seg1addr 0x%08lX.  Address out of range.", fBaseAddress);
 				fBaseAddress = 0;
 			}
 			break;
@@ -4834,7 +4834,7 @@
 		}
 		fIgnoreOptimizationHints = true;
 	}
-	
+
 	if ( fUseDataConstSegmentForceOn ) {
 		fUseDataConstSegment = true;
 	}
@@ -4845,7 +4845,7 @@
 		// automatically use __DATA_CONST in shared dylibs when V2 is in use
 		fUseDataConstSegment = true;
 	}
-	
+
 
 	// TEMP until <rdar://problem/45656620&45656620> are fixed
 	if ( (fFinalName != NULL) && ((strcmp(fFinalName, "/usr/libexec/locationd") == 0) || (strcmp(fFinalName, "/usr/libexec/terminusd") == 0)) ) {
@@ -4886,7 +4886,7 @@
 
 	// <rdar://problem/5366363> -r -x implies -S
 	if ( (fOutputKind == Options::kObjectFile) && (fLocalSymbolHandling == kLocalSymbolsNone) )
-		fDebugInfoStripping = Options::kDebugInfoNone;			
+		fDebugInfoStripping = Options::kDebugInfoNone;
 
 	// <rdar://problem/15252891> -r implies -no_uuid
 	if ( fOutputKind == Options::kObjectFile )
@@ -4894,9 +4894,9 @@
 
 	// choose how to process unwind info
 	switch ( fArchitecture ) {
-		case CPU_TYPE_I386:		
-		case CPU_TYPE_X86_64:		
-		case CPU_TYPE_ARM64:		
+		case CPU_TYPE_I386:
+		case CPU_TYPE_X86_64:
+		case CPU_TYPE_ARM64:
 			switch ( fOutputKind ) {
 				case Options::kObjectFile:
 				case Options::kStaticExecutable:
@@ -4940,7 +4940,7 @@
 			fAddCompactUnwindEncoding = false;
 			break;
 	}
-		
+
 	// only iOS executables should be encryptable
 	switch ( fOutputKind ) {
 		case Options::kObjectFile:
@@ -4969,10 +4969,10 @@
 
 	// don't move inits in dyld because dyld wants certain
 	// entries point at stable locations at the start of __text
-	if ( fOutputKind == Options::kDyld ) 
+	if ( fOutputKind == Options::kDyld )
 		fAutoOrderInitializers = false;
-		
-		
+
+
 	// disable __data ordering for some output kinds
 	switch ( fOutputKind ) {
 		case Options::kObjectFile:
@@ -4987,7 +4987,7 @@
 		case Options::kDynamicBundle:
 			break;
 	}
-	
+
 	// only use compressed LINKEDIT for final linked images
 	switch ( fOutputKind ) {
 		case Options::kDynamicExecutable:
@@ -5024,8 +5024,8 @@
 			fEnforceDylibSubtypesMatch = false;
 			break;
 	}
-		
-		
+
+
 	// only final linked images can not optimize zero fill sections
 	if ( fOutputKind == Options::kObjectFile )
 		fOptimizeZeroFill = true;
@@ -5050,11 +5050,11 @@
 				break;
 		}
 	}
-	
+
 	// Mac OS X 10.5 and iPhoneOS 2.0 support LC_REEXPORT_DYLIB
 	if ( platforms().minOS(ld::version2008) )
 		fUseSimplifiedDylibReExports = true;
-	
+
 	// Mac OS X 10.7 and iOS 4.2 support LC_LOAD_UPWARD_DYLIB
 	if ( platforms().minOS(ld::version2010) && (fOutputKind == kDynamicLibrary) )
 		fCanUseUpwardDylib = true;
@@ -5155,7 +5155,7 @@
 	// also be using no lazy binding.
 	if ( fUseLinkedListBinding )
 		assert(fNoLazyBinding);
-	
+
 	// MacOSX 10.7 defaults to PIE
 	if ( (fArchitecture == CPU_TYPE_I386)
 		&& (fOutputKind == kDynamicExecutable)
@@ -5164,7 +5164,7 @@
 	}
 
 	// armv7 for iOS4.3 defaults to PIE
-	if ( (fArchitecture == CPU_TYPE_ARM) 
+	if ( (fArchitecture == CPU_TYPE_ARM)
 		&& fArchSupportsThumb2
 		&& (fOutputKind == kDynamicExecutable)
 		&& (platforms().contains(ld::Platform::watchOS) || platforms().minOS(ld::iOS_4_3)) ) {
@@ -5244,11 +5244,11 @@
 				fVersionLoadCommand = true;
 			break;
 	}
-	
+
 	// support re-export of individual symbols in MacOSX 10.7 and iOS 4.2
 	if ( (fOutputKind == kDynamicLibrary) && platforms().minOS(ld::version2010) )
 		fCanReExportSymbols = true;
-	
+
 	// ObjC optimization is only in dynamic final linked images
 	switch ( fOutputKind ) {
 		case Options::kObjectFile:
@@ -5269,7 +5269,7 @@
 	// on the command line
 	if ( (fArchitecture == CPU_TYPE_I386) && (fOutputKind == kDynamicExecutable) && !fDisableNonExecutableHeap)
 		fNonExecutableHeap = true;
-		
+
 	// Use LC_MAIN instead of LC_UNIXTHREAD for newer OSs
 	switch ( fOutputKind ) {
 		case Options::kDynamicExecutable:
@@ -5296,16 +5296,16 @@
 		case Options::kDynamicLibrary:
 		case Options::kDynamicBundle:
 			break;
-			
+
 		case Options::kStaticExecutable:
 		case Options::kPreload:
 		case Options::kDyld:
 			fNeedsThreadLoadCommand = true;
-			if ( fEntryName == NULL ) 
+			if ( fEntryName == NULL )
 				fEntryName = "start";  // Perhaps these should have no default and require -e
 			break;
 	}
-	
+
 	// add LC_SOURCE_VERSION
 	switch ( fOutputKind ) {
 		case Options::kDynamicExecutable:
@@ -5406,7 +5406,7 @@
 		if ( fSegmentAlignment == 4096 )
 			fSegmentAlignment = 4096*4;
 	}
-  
+
 	// <rdar://problem/12258065> ARM64 needs 16KB page size for user land code
 	// <rdar://problem/15974532> make armv7[s] use 16KB pages in user land code for iOS 8 or later
 	if ( fSegmentAlignment == LD_PAGE_SIZE ) {
@@ -5465,11 +5465,11 @@
 			fKeepDwarfUnwind = true;
 			break;
 	}
-	
+
 	// Make sure -image_base matches alignment
 	uint64_t alignedBaseAddress = (fBaseAddress+fSegmentAlignment-1) & (-fSegmentAlignment);
 	if ( alignedBaseAddress != fBaseAddress ) {
-		warning("base address 0x%llX is not properly aligned. Changing it to 0x%llX", fBaseAddress, alignedBaseAddress);
+		warning("base address 0x%lX is not properly aligned. Changing it to 0x%lX", fBaseAddress, alignedBaseAddress);
 		fBaseAddress = alignedBaseAddress;
 	}
 
@@ -5766,7 +5766,7 @@
 				break;
 		}
 		if ( (fStackSize & (-fSegmentAlignment)) != fStackSize )
-			throwf("-stack_size must be multiple of segment alignment (%lldKB)", fSegmentAlignment/1024);
+			throwf("-stack_size must be multiple of segment alignment (%ldKB)", fSegmentAlignment/1024);
 		switch ( fOutputKind ) {
 			case Options::kDynamicExecutable:
 			case Options::kStaticExecutable:
@@ -5781,7 +5781,7 @@
 				throw "-stack_size option can only be used when linking a main executable";
 		}
 		if ( fStackSize > fStackAddr )
-			throwf("-stack_size (0x%08llX) must be smaller than -stack_addr (0x%08llX)", fStackSize, fStackAddr);
+			throwf("-stack_size (0x%08lX) must be smaller than -stack_addr (0x%08lX)", fStackSize, fStackAddr);
 	}
 
 	// check that -allow_stack_execute is only used with main executables
@@ -5835,7 +5835,7 @@
 				throw "-client_name can only be used with -bundle";
 		}
 	}
-	
+
 	// check -init is only used when building a dylib
 	if ( (fInitFunctionName != NULL) && (fOutputKind != Options::kDynamicLibrary) )
 		throw "-init can only be used with -dynamiclib";
@@ -5916,7 +5916,7 @@
 	for (NameSet::const_iterator it=fReExportSymbols.regularBegin(); it != fReExportSymbols.regularEnd(); ++it) {    // ld64-port: NameSet::iterator it -> NameSet::const_iterator it
 		fInitialUndefines.push_back(*it);
 	}
-	
+
 	// make sure that -init symbol exists
 	if ( fInitFunctionName != NULL )
 		fInitialUndefines.push_back(fInitFunctionName);
@@ -5948,7 +5948,7 @@
 		if ( fZeroPageSize != ULLONG_MAX ) {
 			for (std::vector<SegmentStart>::iterator it = fCustomSegmentAddresses.begin(); it != fCustomSegmentAddresses.end(); ++it) {
 				if ( it->address < fZeroPageSize )
-					throwf("-segaddr %s 0x%llX conflicts with -pagezero_size", it->name, it->address);
+					throwf("-segaddr %s 0x%lX conflicts with -pagezero_size", it->name, it->address);
 			}
 		}
 		// verify no duplicates
@@ -6027,7 +6027,7 @@
 				throw "-rpath can only be used when creating a dynamic final linked image";
 		}
 	}
-	
+
 	if ( fPositionIndependentExecutable ) {
 		switch ( fOutputKind ) {
 			case Options::kDynamicExecutable:
@@ -6051,7 +6051,7 @@
 				throw "-pie can only be used when linking a main executable";
 		}
 	}
-	
+
 	// check -read_only_relocs is not used with x86_64 or arm64
 	if ( fAllowTextRelocs ) {
 		if ( (fArchitecture == CPU_TYPE_X86_64) && (fOutputKind != kKextBundle) ) {
@@ -6062,7 +6062,7 @@
 			warning("-read_only_relocs cannot be used with arm64");
 		}
 	}
-	
+
 	// check -mark_auto_dead_strip is only used with dylibs
 	if ( fMarkDeadStrippableDylib ) {
 		if ( fOutputKind != Options::kDynamicLibrary ) {
@@ -6070,14 +6070,14 @@
 			fMarkDeadStrippableDylib = false;
 		}
 	}
-	
+
 	// -force_cpusubtype_ALL is not supported for ARM
 	if ( fForceSubtypeAll ) {
 		if ( fArchitecture == CPU_TYPE_ARM ) {
 			warning("-force_cpusubtype_ALL will become unsupported for ARM architectures");
 		}
 	}
-	
+
 	// -reexported_symbols_list can only be used with -dynamiclib
 	if ( !fReExportSymbols.empty() ) {
 		if ( fOutputKind != Options::kDynamicLibrary )
@@ -6085,7 +6085,7 @@
 		if ( !platforms().minOS(ld::version2010) )
 			throw "targeted OS version does not support -reexported_symbols_list";
 	}
-	
+
 	// -dyld_env can only be used with main executables
 	if ( (fOutputKind != Options::kDynamicExecutable) && (fDyldEnvironExtras.size() != 0) )
 		throw "-dyld_env can only used used when created main executables";
@@ -6262,7 +6262,7 @@
 	bool rFound = false;
 	bool creatingMachKernel = false;
 	bool newLinker = false;
-	
+
 	// build command line buffer in case ld crashes
 #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1070 && HAVE_CRASHREPORTER_HEADER // ld64-port: added && HAVE_CRASHREPORTER_HEADER
 	CRSetCrashLogMessage(crashreporterBuffer);
@@ -6335,14 +6335,14 @@
 	}
 	// ld classic does not understand -kext (change to -static -r)
 	for(int j=0; j < argc; ++j) {
-		if ( strcmp(argv[j], "-kext") == 0) 
+		if ( strcmp(argv[j], "-kext") == 0)
 			argv[j] = "-r";
-		else if ( strcmp(argv[j], "-dynamic") == 0) 
+		else if ( strcmp(argv[j], "-dynamic") == 0)
 			argv[j] = "-static";
 	}
-	// ld classic does not understand -demangle 
+	// ld classic does not understand -demangle
 	for(int j=0; j < argc; ++j) {
-		if ( strcmp(argv[j], "-demangle") == 0) 
+		if ( strcmp(argv[j], "-demangle") == 0)
 			argv[j] = "-noprebind";
 	}
 	// in -v mode, print command line passed to ld_classic
@@ -6406,7 +6406,7 @@
 		return sym;
 
 	int status;
-	char* result = abi::__cxa_demangle(&sym[1], buff, &size, &status); 
+	char* result = abi::__cxa_demangle(&sym[1], buff, &size, &status);
 	if ( result != NULL ) {
 		// if demangling successful, keep buffer for next demangle
 		buff = result;
@@ -6457,7 +6457,7 @@
 
 void Options::addDependency(uint8_t opcode, const char* path) const
 {
-	if ( !this->dumpDependencyInfo() ) 
+	if ( !this->dumpDependencyInfo() )
 		return;
 
 	char realPath[PATH_MAX];
diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/OutputFile.cpp cctools-port-format/cctools/ld64/src/ld/OutputFile.cpp
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/OutputFile.cpp	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/OutputFile.cpp	2020-11-26 20:03:13.826874452 -0800
@@ -21,7 +21,7 @@
  *
  * @APPLE_LICENSE_HEADER_END@
  */
- 
+
 
 #include <stdlib.h>
 #include <sys/types.h>
@@ -78,18 +78,18 @@
 uint32_t sAdrpNotNoped = 0;
 
 
-OutputFile::OutputFile(const Options& opts) 
+OutputFile::OutputFile(const Options& opts)
 	:
-		usesWeakExternalSymbols(false), overridesWeakExternalSymbols(false), 
-		_noReExportedDylibs(false), pieDisabled(false), hasDataInCode(false), 
+		usesWeakExternalSymbols(false), overridesWeakExternalSymbols(false),
+		_noReExportedDylibs(false), pieDisabled(false), hasDataInCode(false),
 		headerAndLoadCommandsSection(NULL),
-		rebaseSection(NULL), bindingSection(NULL), weakBindingSection(NULL), 
-		lazyBindingSection(NULL), exportSection(NULL), 
-		splitSegInfoSection(NULL), functionStartsSection(NULL), 
+		rebaseSection(NULL), bindingSection(NULL), weakBindingSection(NULL),
+		lazyBindingSection(NULL), exportSection(NULL),
+		splitSegInfoSection(NULL), functionStartsSection(NULL),
 		dataInCodeSection(NULL), optimizationHintsSection(NULL),
-		symbolTableSection(NULL), stringPoolSection(NULL), 
-		localRelocationsSection(NULL), externalRelocationsSection(NULL), 
-		sectionRelocationsSection(NULL), 
+		symbolTableSection(NULL), stringPoolSection(NULL),
+		localRelocationsSection(NULL), externalRelocationsSection(NULL),
+		sectionRelocationsSection(NULL),
 		indirectSymbolTableSection(NULL),
 		threadedPageStartsSection(NULL),
 		_options(opts),
@@ -135,20 +135,20 @@
 {
 	fprintf(stderr, "SORTED:\n");
 	for (std::vector<ld::Internal::FinalSection*>::iterator it = state.sections.begin(); it != state.sections.end(); ++it) {
-		fprintf(stderr, "final section %p %s/%s %s start addr=0x%08llX, size=0x%08llX, alignment=%02d, fileOffset=0x%08llX\n", 
-				(*it), (*it)->segmentName(), (*it)->sectionName(), (*it)->isSectionHidden() ? "(hidden)" : "", 
+		fprintf(stderr, "final section %p %s/%s %s start addr=0x%08lX, size=0x%08lX, alignment=%02d, fileOffset=0x%08lX\n",
+				(*it), (*it)->segmentName(), (*it)->sectionName(), (*it)->isSectionHidden() ? "(hidden)" : "",
 				(*it)->address, (*it)->size, (*it)->alignment, (*it)->fileOffset);
 		if ( printAtoms ) {
 			std::vector<const ld::Atom*>& atoms = (*it)->atoms;
 			for (std::vector<const ld::Atom*>::iterator ait = atoms.begin(); ait != atoms.end(); ++ait) {
-				fprintf(stderr, "   %p (0x%04llX) %s\n", *ait, (*ait)->size(), (*ait)->name());
+				fprintf(stderr, "   %p (0x%04lX) %s\n", *ait, (*ait)->size(), (*ait)->name());
 			}
 		}
 	}
 	fprintf(stderr, "DYLIBS:\n");
 	for (std::vector<ld::dylib::File*>::iterator it=state.dylibs.begin(); it != state.dylibs.end(); ++it )
 		fprintf(stderr, "  %s\n", (*it)->installPath());
-}	
+}
 
 void OutputFile::write(ld::Internal& state)
 {
@@ -223,7 +223,7 @@
 					break;
 				default:
 					(const_cast<ld::Atom*>(atom))->setSectionStartAddress(sect->address);
-					if ( log ) fprintf(stderr, "    atom=%p, addr=0x%08llX, name=%s\n", atom, atom->finalAddress(), atom->name());
+					if ( log ) fprintf(stderr, "    atom=%p, addr=0x%08lX, name=%s\n", atom, atom->finalAddress(), atom->name());
 					break;
 			}
 		}
@@ -240,51 +240,51 @@
 		_chainedInfoAtom->encode();
 	}
 	else if ( _options.makeCompressedDyldInfo() ) {
-		// build dylb rebasing info  
+		// build dylb rebasing info
 		assert(_rebasingInfoAtom != NULL);
 		_rebasingInfoAtom->encode();
-		
-		// build dyld binding info  
+
+		// build dyld binding info
 		assert(_bindingInfoAtom != NULL);
 		_bindingInfoAtom->encode();
-		
-		// build dyld lazy binding info  
+
+		// build dyld lazy binding info
 		assert(_lazyBindingInfoAtom != NULL);
 		_lazyBindingInfoAtom->encode();
-		
-		// build dyld weak binding info  
+
+		// build dyld weak binding info
 		assert(_weakBindingInfoAtom != NULL);
 		_weakBindingInfoAtom->encode();
-		
-		// build dyld export info  
+
+		// build dyld export info
 		assert(_exportInfoAtom != NULL);
 		_exportInfoAtom->encode();
 	}
-	
+
 	if ( _options.sharedRegionEligible() ) {
-		// build split seg info  
+		// build split seg info
 		assert(_splitSegInfoAtom != NULL);
 		_splitSegInfoAtom->encode();
 	}
 
 	if ( _options.addFunctionStarts() ) {
-		// build function starts info  
+		// build function starts info
 		assert(_functionStartsAtom != NULL);
 		_functionStartsAtom->encode();
 	}
 
 	if ( _options.addDataInCodeInfo() ) {
-		// build data-in-code info  
+		// build data-in-code info
 		assert(_dataInCodeAtom != NULL);
 		_dataInCodeAtom->encode();
 	}
-	
+
 	if ( _hasOptimizationHints ) {
-		// build linker-optimization-hint info  
+		// build linker-optimization-hint info
 		assert(_optimizationHintsAtom != NULL);
 		_optimizationHintsAtom->encode();
 	}
-	
+
 	// build classic symbol table
 	assert(_symbolTableAtom != NULL);
 	_symbolTableAtom->encode();
@@ -298,10 +298,10 @@
 	}
 
 	if ( !_options.makeCompressedDyldInfo() && !_options.makeThreadedStartsSection() && !_options.makeChainedFixups() ) {
-		// build external relocations 
+		// build external relocations
 		assert(_externalRelocsAtom != NULL);
 		_externalRelocsAtom->encode();
-		// build local relocations 
+		// build local relocations
 		assert(_localRelocsAtom != NULL);
 		_localRelocsAtom->encode();
 	}
@@ -311,7 +311,7 @@
 	uint64_t curLinkEditfileOffset = 0;
 	for (std::vector<ld::Internal::FinalSection*>::iterator sit = state.sections.begin(); sit != state.sections.end(); ++sit) {
 		ld::Internal::FinalSection* sect = *sit;
-		if ( sect->type() != ld::Section::typeLinkEdit ) 
+		if ( sect->type() != ld::Section::typeLinkEdit )
 			continue;
 		if ( curLinkEditAddress == 0 ) {
 			curLinkEditAddress = sect->address;
@@ -346,7 +346,7 @@
 		curLinkEditAddress += sect->size;
 		curLinkEditfileOffset += sect->size;
 	}
-	
+
 	_fileSize = state.sections.back()->fileOffset + state.sections.back()->size;
 }
 
@@ -385,7 +385,7 @@
 				textSegPageSize = 0x1000;
 			for (std::vector<ld::Internal::FinalSection*>::reverse_iterator it = state.sections.rbegin(); it != state.sections.rend(); ++it) {
 				ld::Internal::FinalSection* sect = *it;
-				if ( strcmp(sect->segmentName(), "__TEXT") != 0 ) 
+				if ( strcmp(sect->segmentName(), "__TEXT") != 0 )
 					continue;
 				if ( sect == headerAndLoadCommandsSection ) {
 					addr -= headerAndLoadCommandsSection->size;
@@ -395,7 +395,7 @@
 				addr -= sect->size;
 				addr = addr & (0 - (1 << sect->alignment));
 			}
-	
+
 			// if command line requires more padding than this
 			uint32_t minPad = _options.minimumHeaderPad();
 			if ( _options.maxMminimumHeaderPad() ) {
@@ -410,7 +410,7 @@
 				int extraPages = (minPad - paddingSize + _options.segmentAlignment() - 1)/_options.segmentAlignment();
 				paddingSize += extraPages * _options.segmentAlignment();
 			}
-			
+
 			if ( _options.makeEncryptable() ) {
 				// load commands must be on a separate non-encrypted page
 				int loadCommandsPage = (headerAndLoadCommandsSection->size + minPad)/_options.segmentAlignment();
@@ -432,12 +432,12 @@
 uint64_t OutputFile::pageAlign(uint64_t addr)
 {
 	const uint64_t alignment = _options.segmentAlignment();
-	return ((addr+alignment-1) & (-alignment)); 
+	return ((addr+alignment-1) & (-alignment));
 }
 
 uint64_t OutputFile::pageAlign(uint64_t addr, uint64_t pageSize)
 {
-	return ((addr+pageSize-1) & (-pageSize)); 
+	return ((addr+pageSize-1) & (-pageSize));
 }
 
 static const char* makeName(const ld::Atom& atom)
@@ -446,7 +446,7 @@
 	switch ( atom.symbolTableInclusion() ) {
 		case ld::Atom::symbolTableNotIn:
 		case ld::Atom::symbolTableNotInFinalLinkedImages:
-			sprintf(buffer, "%s@0x%08llX", atom.name(), atom.objectAddress());
+			sprintf(buffer, "%s@0x%08lX", atom.name(), atom.objectAddress());
 			break;
 		case ld::Atom::symbolTableIn:
 		case ld::Atom::symbolTableInAndNeverStrip:
@@ -563,7 +563,7 @@
 			break;
 	}
 	assert(target != NULL);
-	
+
 	uint64_t targetAddress = target->finalAddress();
 	for (std::vector<ld::Internal::FinalSection*>::const_iterator it = state.sections.begin(); it != state.sections.end(); ++it) {
 		const ld::Internal::FinalSection* sect = *it;
@@ -592,7 +592,7 @@
 			break;
 	}
 	assert(target != NULL);
-	
+
 	for (std::vector<ld::Internal::FinalSection*>::const_iterator it = state.sections.begin(); it != state.sections.end(); ++it) {
 		const ld::Internal::FinalSection* sect = *it;
 		switch ( sect->type() ) {
@@ -613,8 +613,8 @@
 	for (std::vector<ld::Internal::FinalSection*>::iterator it = state.sections.begin(); it != state.sections.end(); ++it) {
 		if ( (*it)->isSectionHidden() )
 			continue;
-		fprintf(stderr, "    %s/%s addr=0x%08llX, size=0x%08llX, fileOffset=0x%08llX, type=%d\n", 
-				(*it)->segmentName(), (*it)->sectionName(), 
+		fprintf(stderr, "    %s/%s addr=0x%08lX, size=0x%08lX, fileOffset=0x%08lX, type=%d\n",
+				(*it)->segmentName(), (*it)->sectionName(),
 				(*it)->address, (*it)->size, (*it)->fileOffset, (*it)->type());
 	}
 }
@@ -625,10 +625,10 @@
 	if ( (displacement > 127) || (displacement < -128) ) {
 		// show layout of final image
 		printSectionLayout(state);
-		
-		const ld::Atom* target;	
-		throwf("8-bit reference out of range (%lld max is +/-127B): from %s (0x%08llX) to %s (0x%08llX)", 
-				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
+
+		const ld::Atom* target;
+		throwf("8-bit reference out of range (%ld max is +/-127B): from %s (0x%08lX) to %s (0x%08lX)",
+				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup),
 				addressOf(state, fixup, &target));
 	}
 }
@@ -639,10 +639,10 @@
 	if ( (displacement > thirtyTwoKLimit) || (displacement < (-thirtyTwoKLimit)) ) {
 		// show layout of final image
 		printSectionLayout(state);
-		
-		const ld::Atom* target;	
-		throwf("16-bit reference out of range (%lld max is +/-32KB): from %s (0x%08llX) to %s (0x%08llX)", 
-				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup),  
+
+		const ld::Atom* target;
+		throwf("16-bit reference out of range (%ld max is +/-32KB): from %s (0x%08lX) to %s (0x%08lX)",
+				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup),
 				addressOf(state, fixup, &target));
 	}
 }
@@ -653,10 +653,10 @@
 	if ( (displacement > twoGigLimit) || (displacement < (-twoGigLimit)) ) {
 		// show layout of final image
 		printSectionLayout(state);
-		
-		const ld::Atom* target;	
-		throwf("32-bit branch out of range (%lld max is +/-2GB): from %s (0x%08llX) to %s (0x%08llX)",
-				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
+
+		const ld::Atom* target;
+		throwf("32-bit branch out of range (%ld max is +/-2GB): from %s (0x%08lX) to %s (0x%08lX)",
+				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup),
 				addressOf(state, fixup, &target));
 	}
 }
@@ -670,25 +670,25 @@
 		//  .long _foo - 0xC0000000
 		// is encoded in mach-o the same as:
 		//  .long _foo + 0x40000000
-		// so if _foo lays out to 0xC0000100, the first is ok, but the second is not.  
+		// so if _foo lays out to 0xC0000100, the first is ok, but the second is not.
 		if ( (_options.architecture() == CPU_TYPE_ARM) || (_options.architecture() == CPU_TYPE_I386) ) {
 			// Unlikely userland code does funky stuff like this, so warn for them, but not warn for -preload or -static
 			if ( (_options.outputKind() != Options::kPreload) && (_options.outputKind() != Options::kStaticExecutable) ) {
-				warning("32-bit absolute address out of range (0x%08llX max is 4GB): from %s + 0x%08X (0x%08llX) to 0x%08llX", 
+				warning("32-bit absolute address out of range (0x%08lX max is 4GB): from %s + 0x%08X (0x%08lX) to 0x%08lX",
 						displacement, atom->name(), fixup->offsetInAtom, atom->finalAddress(), displacement);
 			}
 			return;
 		}
 		// show layout of final image
 		printSectionLayout(state);
-		
-		const ld::Atom* target;	
+
+		const ld::Atom* target;
 		if ( fixup->binding == ld::Fixup::bindingNone )
-			throwf("32-bit absolute address out of range (0x%08llX max is 4GB): from %s + 0x%08X (0x%08llX) to 0x%08llX", 
+			throwf("32-bit absolute address out of range (0x%08lX max is 4GB): from %s + 0x%08X (0x%08lX) to 0x%08lX",
 				displacement, atom->name(), fixup->offsetInAtom, atom->finalAddress(), displacement);
 		else
-			throwf("32-bit absolute address out of range (0x%08llX max is 4GB): from %s + 0x%08X (0x%08llX) to %s (0x%08llX)", 
-				displacement, atom->name(), fixup->offsetInAtom, atom->finalAddress(), referenceTargetAtomName(state, fixup), 
+			throwf("32-bit absolute address out of range (0x%08lX max is 4GB): from %s + 0x%08X (0x%08lX) to %s (0x%08lX)",
+				displacement, atom->name(), fixup->offsetInAtom, atom->finalAddress(), referenceTargetAtomName(state, fixup),
 				addressOf(state, fixup, &target));
 	}
 }
@@ -697,13 +697,13 @@
 void OutputFile::rangeCheckRIP32(int64_t displacement, ld::Internal& state, const ld::Atom* atom, const ld::Fixup* fixup)
 {
 	const int64_t twoGigLimit  = 0x7FFFFFFF;
-	if ( (displacement > twoGigLimit) || (displacement < (-twoGigLimit)) ) {	
+	if ( (displacement > twoGigLimit) || (displacement < (-twoGigLimit)) ) {
 		// show layout of final image
 		printSectionLayout(state);
-		
-		const ld::Atom* target;	
-		throwf("32-bit RIP relative reference out of range (%lld max is +/-2GB): from %s (0x%08llX) to %s (0x%08llX)",
-				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
+
+		const ld::Atom* target;
+		throwf("32-bit RIP relative reference out of range (%ld max is +/-2GB): from %s (0x%08lX) to %s (0x%08lX)",
+				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup),
 				addressOf(state, fixup, &target));
 	}
 }
@@ -713,10 +713,10 @@
 	if ( (displacement > 4092LL) || (displacement < (-4092LL)) ) {
 		// show layout of final image
 		printSectionLayout(state);
-		
-		const ld::Atom* target;	
-		throwf("ARM ldr 12-bit displacement out of range (%lld max is +/-4096B): from %s (0x%08llX) to %s (0x%08llX)", 
-				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
+
+		const ld::Atom* target;
+		throwf("ARM ldr 12-bit displacement out of range (%ld max is +/-4096B): from %s (0x%08lX) to %s (0x%08lX)",
+				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup),
 				addressOf(state, fixup, &target));
 	}
 }
@@ -730,13 +730,13 @@
 {
 	if ( checkArmBranch24Displacement(displacement) )
 		return;
-		
+
 	// show layout of final image
 	printSectionLayout(state);
-	
-	const ld::Atom* target;	
-	throwf("b/bl/blx ARM branch out of range (%lld max is +/-32MB): from %s (0x%08llX) to %s (0x%08llX)", 
-			displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
+
+	const ld::Atom* target;
+	throwf("b/bl/blx ARM branch out of range (%ld max is +/-32MB): from %s (0x%08lX) to %s (0x%08lX)",
+			displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup),
 			addressOf(state, fixup, &target));
 }
 
@@ -765,15 +765,15 @@
 	// show layout of final image
 	printSectionLayout(state);
 
-	const ld::Atom* target;	
+	const ld::Atom* target;
 	if ( _options.preferSubArchitecture() && _options.archSupportsThumb2() ) {
-		throwf("b/bl/blx thumb2 branch out of range (%lld max is +/-16MB): from %s (0x%08llX) to %s (0x%08llX)", 
-				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
+		throwf("b/bl/blx thumb2 branch out of range (%ld max is +/-16MB): from %s (0x%08lX) to %s (0x%08lX)",
+				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup),
 				addressOf(state, fixup, &target));
 	}
 	else {
-		throwf("b/bl/blx thumb1 branch out of range (%lld max is +/-4MB): from %s (0x%08llX) to %s (0x%08llX)", 
-				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
+		throwf("b/bl/blx thumb1 branch out of range (%ld max is +/-4MB): from %s (0x%08lX) to %s (0x%08lX)",
+				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup),
 				addressOf(state, fixup, &target));
 	}
 }
@@ -785,10 +785,10 @@
 	if ( (displacement > bl_128MegLimit) || (displacement < (-bl_128MegLimit)) ) {
 		// show layout of final image
 		printSectionLayout(state);
-		
-		const ld::Atom* target;	
-		throwf("b(l) ARM64 branch out of range (%lld max is +/-128MB): from %s (0x%08llX) to %s (0x%08llX)", 
-				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
+
+		const ld::Atom* target;
+		throwf("b(l) ARM64 branch out of range (%ld max is +/-128MB): from %s (0x%08lX) to %s (0x%08lX)",
+				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup),
 				addressOf(state, fixup, &target));
 	}
 }
@@ -799,10 +799,10 @@
 	if ( (displacement > adrp_4GigLimit) || (displacement < (-adrp_4GigLimit)) ) {
 		// show layout of final image
 		printSectionLayout(state);
-		
-		const ld::Atom* target;	
-		throwf("ARM64 ADRP out of range (%lld max is +/-4GB): from %s (0x%08llX) to %s (0x%08llX)", 
-				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
+
+		const ld::Atom* target;
+		throwf("ARM64 ADRP out of range (%ld max is +/-4GB): from %s (0x%08lX) to %s (0x%08lX)",
+				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup),
 				addressOf(state, fixup, &target));
 	}
 }
@@ -843,7 +843,7 @@
 	SignExtension	signEx;		// if load is sign extended
 };
 
-static uint32_t makeLDR_literal(const LoadStoreInfo& info, uint64_t targetAddress, uint64_t instructionAddress) 
+static uint32_t makeLDR_literal(const LoadStoreInfo& info, uint64_t targetAddress, uint64_t instructionAddress)
 {
 	int64_t delta = targetAddress - instructionAddress;
 	assert(delta < 1024*1024);
@@ -891,7 +891,7 @@
 	assert(delta > -1024*1024);
 	uint32_t immhi = (delta & 0x001FFFFC) << 3;
 	uint32_t immlo = (delta & 0x00000003) << 29;
-	return (instruction | immhi | immlo | destReg); 
+	return (instruction | immhi | immlo | destReg);
 }
 
 static uint32_t makeLoadOrStore(const LoadStoreInfo& info)
@@ -999,9 +999,9 @@
 	return (instruction | (sizeBits << 30) | (opcBits << 22) | (imm12Bits << 10));
 }
 
-static bool parseLoadOrStore(uint32_t instruction, LoadStoreInfo& info) 
+static bool parseLoadOrStore(uint32_t instruction, LoadStoreInfo& info)
 {
-	if ( (instruction & 0x3B000000) != 0x39000000 ) 
+	if ( (instruction & 0x3B000000) != 0x39000000 )
 		return false;
 	info.isFloat = ( (instruction & 0x04000000) != 0 );
 	info.reg = (instruction & 0x1F);
@@ -1090,14 +1090,14 @@
 			return false;
 	}
 	info.offset = ((instruction >> 10) & 0x0FFF) * info.size;
-	return true;	
+	return true;
 }
 
 struct AdrpInfo {
 	uint32_t	destReg;
 };
 
-static bool parseADRP(uint32_t instruction, AdrpInfo& info) 
+static bool parseADRP(uint32_t instruction, AdrpInfo& info)
 {
 	if ( (instruction & 0x9F000000) != 0x90000000 )
 		return false;
@@ -1111,7 +1111,7 @@
 	uint32_t	addend;
 };
 
-static bool parseADD(uint32_t instruction, AddInfo& info) 
+static bool parseADD(uint32_t instruction, AddInfo& info)
 {
 	if ( (instruction & 0xFFC00000) != 0x91000000 )
 		return false;
@@ -1124,7 +1124,7 @@
 
 
 #if 0
-static uint32_t makeLDR_scaledOffset(const LoadStoreInfo& info) 
+static uint32_t makeLDR_scaledOffset(const LoadStoreInfo& info)
 {
 	assert((info.reg & 0xFFFFFFE0) == 0);
 	assert((info.baseReg & 0xFFFFFFE0) == 0);
@@ -1172,7 +1172,7 @@
 	return (0x39000000 | (sizeBits<<30) | (vBit<<26) | (opcBits<<22) | (scaledOffset<<10) | (info.baseReg<<5) | info.reg);
 }
 
-static uint32_t makeLDR_literal(uint32_t destReg, uint32_t loadSize, bool isFloat, uint64_t targetAddress, uint64_t instructionAddress) 
+static uint32_t makeLDR_literal(uint32_t destReg, uint32_t loadSize, bool isFloat, uint64_t targetAddress, uint64_t instructionAddress)
 {
 	int64_t delta = targetAddress - instructionAddress;
 	assert(delta < 1024*1024);
@@ -1239,8 +1239,8 @@
 }
 #endif // SUPPORT_ARCH_arm64
 
-void OutputFile::setInfo(ld::Internal& state, const ld::Atom* atom, uint8_t* buffer, const std::map<uint32_t, const Fixup*>& usedByHints, 
-						uint32_t offsetInAtom, uint32_t delta, InstructionInfo* info) 
+void OutputFile::setInfo(ld::Internal& state, const ld::Atom* atom, uint8_t* buffer, const std::map<uint32_t, const Fixup*>& usedByHints,
+						uint32_t offsetInAtom, uint32_t delta, InstructionInfo* info)
 {
 	info->offsetInAtom = offsetInAtom + delta;
 	std::map<uint32_t, const Fixup*>::const_iterator pos = usedByHints.find(info->offsetInAtom);
@@ -1266,7 +1266,7 @@
 	info->instructionContent = &buffer[info->offsetInAtom];
 	info->instructionAddress = atom->finalAddress() + info->offsetInAtom;
 	info->instruction = get32LE(info->instructionContent);
-}	
+}
 
 #if SUPPORT_ARCH_arm64
 static bool isPageKind(const ld::Fixup* fixup, bool mustBeGOT=false)
@@ -1284,7 +1284,7 @@
 			return true;
 		case ld::Fixup::kindSetTargetAddress:
 			f = fixup;
-			do { 
+			do {
 				++f;
 			} while ( ! f->lastInCluster() );
 			switch (f->kind ) {
@@ -1320,7 +1320,7 @@
 			return true;
 		case ld::Fixup::kindSetTargetAddress:
 			f = fixup;
-			do { 
+			do {
 				++f;
 			} while ( ! f->lastInCluster() );
 			switch (f->kind ) {
@@ -1347,13 +1347,13 @@
 	if ( !(cond) ) { \
 		warning("ignoring linker optimization hint at %s+0x%X because " #cond, atom->name(), fit->offsetInAtom); \
 		break; \
-	} 
+	}
 
 void OutputFile::applyFixUps(ld::Internal& state, uint64_t mhAddress, const ld::Atom* atom, uint8_t* buffer)
 {
 	//fprintf(stderr, "applyFixUps() on %s\n", atom->name());
 	int64_t accumulator = 0;
-	const ld::Atom* toTarget = NULL;	
+	const ld::Atom* toTarget = NULL;
 	const ld::Atom* fromTarget;
 	int64_t delta;
 	uint32_t instruction;
@@ -1369,7 +1369,7 @@
 	for (ld::Fixup::iterator fit = atom->fixupsBegin(), end=atom->fixupsEnd(); fit != end; ++fit) {
 		uint8_t* fixUpLocation = &buffer[fit->offsetInAtom];
 		ld::Fixup::LOH_arm64 lohExtra;
-		switch ( (ld::Fixup::Kind)(fit->kind) ) { 
+		switch ( (ld::Fixup::Kind)(fit->kind) ) {
 			case ld::Fixup::kindNone:
 			case ld::Fixup::kindNoneFollowOn:
 			case ld::Fixup::kindNoneGroupSubordinate:
@@ -1378,9 +1378,9 @@
 			case ld::Fixup::kindNoneGroupSubordinatePersonality:
 				break;
 			case ld::Fixup::kindSetTargetAddress:
-				accumulator = addressOf(state, fit, &toTarget);			
+				accumulator = addressOf(state, fit, &toTarget);
 				thumbTarget = targetIsThumb(state, fit);
-				if ( thumbTarget ) 
+				if ( thumbTarget )
 					accumulator |= 1;
 				if ( fit->contentAddendOnly || fit->contentDetlaToAddendOnly )
 					accumulator = 0;
@@ -1395,10 +1395,10 @@
 					// <rdar://problem/8342028> ARM main executables main contain .long constants pointing
 					// into themselves such as jump tables.  These .long should not have thumb bit set
 					// even though the target is a thumb instruction. We can tell it is an interior pointer
-					// because we are processing an addend. 
+					// because we are processing an addend.
 					if ( thumbTarget && (toTarget == atom) && ((int32_t)fit->u.addend > 0) ) {
 						accumulator &= (-2);
-						//warning("removing thumb bit from intra-atom pointer in %s %s+0x%0X", 
+						//warning("removing thumb bit from intra-atom pointer in %s %s+0x%0X",
 						//		atom->section().sectionName(), atom->name(), fit->offsetInAtom);
 					}
 					accumulator += fit->u.addend;
@@ -1410,7 +1410,7 @@
 			case ld::Fixup::kindSetTargetImageOffset:
 				accumulator = addressOf(state, fit, &toTarget) - mhAddress;
 				thumbTarget = targetIsThumb(state, fit);
-				if ( thumbTarget ) 
+				if ( thumbTarget )
 					accumulator |= 1;
 				break;
 			case ld::Fixup::kindSetTargetSectionOffset:
@@ -1570,7 +1570,7 @@
 				if ( _options.outputKind() != Options::kObjectFile ) {
 					// change call site to a NOP
 					fixUpLocation[-1] = 0x90;	// 1-byte nop
-					fixUpLocation[0] = 0x0F;	// 4-byte nop 
+					fixUpLocation[0] = 0x0F;	// 4-byte nop
 					fixUpLocation[1] = 0x1F;
 					fixUpLocation[2] = 0x40;
 					fixUpLocation[3] = 0x00;
@@ -1650,7 +1650,7 @@
 			case ld::Fixup::kindStoreTargetAddressLittleEndian32:
 				accumulator = addressOf(state, fit, &toTarget);
 				thumbTarget = targetIsThumb(state, fit);
-				if ( thumbTarget ) 
+				if ( thumbTarget )
 					accumulator |= 1;
 				if ( fit->contentAddendOnly )
 					accumulator = 0;
@@ -1765,7 +1765,7 @@
 			case ld::Fixup::kindStoreTargetAddressX86BranchPCRel32:
 			case ld::Fixup::kindStoreTargetAddressX86PCRel32GOTLoad:
 			case ld::Fixup::kindStoreTargetAddressX86PCRel32TLVLoad:
-				accumulator = addressOf(state, fit, &toTarget);	
+				accumulator = addressOf(state, fit, &toTarget);
 				if ( fit->contentDetlaToAddendOnly )
 					accumulator = 0;
 				if ( fit->contentAddendOnly )
@@ -1825,7 +1825,7 @@
 						}
 					}
 				}
-				if ( thumbTarget ) 
+				if ( thumbTarget )
 					accumulator |= 1;
 				if ( fit->contentDetlaToAddendOnly )
 					accumulator = 0;
@@ -1835,7 +1835,7 @@
 				delta = accumulator - (atom->finalAddress() + fit->offsetInAtom + 8);
 				rangeCheckARMBranch24(delta, state, atom, fit);
 				instruction = get32LE(fixUpLocation);
-				// Make sure we are calling arm with bl, thumb with blx		
+				// Make sure we are calling arm with bl, thumb with blx
 				is_bl = ((instruction & 0xFF000000) == 0xEB000000);
 				is_blx = ((instruction & 0xFE000000) == 0xFA000000);
 				is_b = !is_blx && ((instruction & 0x0F000000) == 0x0A000000);
@@ -1844,19 +1844,19 @@
 					uint32_t disp = (uint32_t)(delta >> 2) & 0x00FFFFFF;
 					uint32_t h_bit = (uint32_t)(delta << 23) & 0x01000000;
 					newInstruction = opcode | h_bit | disp;
-				} 
+				}
 				else if ( (is_bl | is_blx) && !thumbTarget ) {
 					uint32_t opcode = 0xEB000000;  // force to be bl
 					uint32_t disp = (uint32_t)(delta >> 2) & 0x00FFFFFF;
 					newInstruction = opcode | disp;
-				} 
+				}
 				else if ( is_b && thumbTarget ) {
 					if ( fit->contentDetlaToAddendOnly )
 						newInstruction = (instruction & 0xFF000000) | ((uint32_t)(delta >> 2) & 0x00FFFFFF);
 					else
 						throwf("no pc-rel bx arm instruction. Can't fix up branch to %s in %s",
 								referenceTargetAtomName(state, fit), atom->name());
-				} 
+				}
 				else if ( !is_bl && !is_blx && thumbTarget ) {
 					throwf("don't know how to convert instruction %x referencing %s to thumb",
 						 instruction, referenceTargetAtomName(state, fit));
@@ -1870,7 +1870,7 @@
 				accumulator = addressOf(state, fit, &toTarget);
 				thumbTarget = targetIsThumb(state, fit);
 				if ( toTarget->contentType() == ld::Atom::typeBranchIsland ) {
-					// branching to island, so see if ultimate target is in range 
+					// branching to island, so see if ultimate target is in range
 					// and if so branch to ultimate target instead.
 					for (ld::Fixup::iterator islandfit = toTarget->fixupsBegin(), end=toTarget->fixupsEnd(); islandfit != end; ++islandfit) {
 						if ( islandfit->kind == ld::Fixup::kindIslandTarget ) {
@@ -1901,7 +1901,7 @@
 						}
 					}
 				}
-				if ( thumbTarget ) 
+				if ( thumbTarget )
 					accumulator |= 1;
 				if ( fit->contentDetlaToAddendOnly )
 					accumulator = 0;
@@ -1930,7 +1930,7 @@
 				delta = accumulator - (atom->finalAddress() + fit->offsetInAtom + 4);
 				// <rdar://problem/16652542> support bl in very large .o files
 				if ( fit->contentDetlaToAddendOnly ) {
-					while ( delta < (-16777216LL) ) 
+					while ( delta < (-16777216LL) )
 						delta += 0x2000000;
 				}
 				rangeCheckThumbBranch22(delta, state, atom, fit);
@@ -1952,7 +1952,7 @@
 							instruction = 0xD000F000; // keep bl
 						else
 							instruction = 0xC000F000; // change to blx
-					} 
+					}
 					else if ( is_blx ) {
 						if ( thumbTarget )
 							instruction = 0xD000F000; // change to bl
@@ -1965,19 +1965,19 @@
 							throwf("armv7 has no pc-rel bx thumb instruction. Can't fix up branch to %s in %s",
 									referenceTargetAtomName(state, fit), atom->name());
 						}
-					} 
+					}
 					else {
-						if ( !thumbTarget ) 
+						if ( !thumbTarget )
 							throwf("don't know how to convert branch instruction %x referencing %s to bx",
 									instruction, referenceTargetAtomName(state, fit));
 						instruction = 0x9000F000; // keep b
-					} 
+					}
 					uint32_t nextDisp = (j1 << 13) | (j2 << 11) | imm11;
 					uint32_t firstDisp = (s << 10) | imm10;
 					newInstruction = instruction | (nextDisp << 16) | firstDisp;
 					//warning("s=%d, j1=%d, j2=%d, imm10=0x%0X, imm11=0x%0X, instruction=0x%08X, first=0x%04X, next=0x%04X, new=0x%08X, disp=0x%llX for %s to %s\n",
 					//	s, j1, j2, imm10, imm11, instruction, firstDisp, nextDisp, newInstruction, delta, atom->name(), toTarget->name());
-					set32LE(fixUpLocation, newInstruction);				
+					set32LE(fixUpLocation, newInstruction);
 				}
 				else {
 					// The instruction is really two instructions:
@@ -1989,10 +1989,10 @@
 					uint32_t nextDisp = (uint32_t)(delta >> 1) & 0x7FF;
 					if ( is_bl && !thumbTarget ) {
 						instruction = 0xE800F000;
-					} 
+					}
 					else if ( is_blx && thumbTarget ) {
 						instruction = 0xF800F000;
-					} 
+					}
 					else if ( is_b ) {
 						instruction = 0x9000F000; // keep b
 						if ( !thumbTarget && !fit->contentDetlaToAddendOnly ) {
@@ -2004,7 +2004,7 @@
 						instruction = instruction & 0xF800F800;
 					}
 					newInstruction = instruction | (nextDisp << 16) | firstDisp;
-					set32LE(fixUpLocation, newInstruction);				
+					set32LE(fixUpLocation, newInstruction);
 				}
 				break;
 			case ld::Fixup::kindStoreARMLow16:
@@ -2013,7 +2013,7 @@
 					uint32_t imm12 = accumulator & 0x00000FFF;
 					instruction = get32LE(fixUpLocation);
 					newInstruction = (instruction & 0xFFF0F000) | (imm4 << 16) | imm12;
-					set32LE(fixUpLocation, newInstruction);		
+					set32LE(fixUpLocation, newInstruction);
 				}
 				break;
 			case ld::Fixup::kindStoreARMHigh16:
@@ -2022,7 +2022,7 @@
 					uint32_t imm12 = (accumulator & 0x0FFF0000) >> 16;
 					instruction = get32LE(fixUpLocation);
 					newInstruction = (instruction & 0xFFF0F000) | (imm4 << 16) | imm12;
-					set32LE(fixUpLocation, newInstruction);		
+					set32LE(fixUpLocation, newInstruction);
 				}
 				break;
 			case ld::Fixup::kindStoreThumbLow16:
@@ -2033,7 +2033,7 @@
 					uint32_t imm8 =  accumulator & 0x000000FF;
 					instruction = get32LE(fixUpLocation);
 					newInstruction = (instruction & 0x8F00FBF0) | imm4 | (i << 10) | (imm3 << 28) | (imm8 << 16);
-					set32LE(fixUpLocation, newInstruction);		
+					set32LE(fixUpLocation, newInstruction);
 				}
 				break;
 			case ld::Fixup::kindStoreThumbHigh16:
@@ -2044,7 +2044,7 @@
 					uint32_t imm8 = (accumulator & 0x00FF0000) >> 16;
 					instruction = get32LE(fixUpLocation);
 					newInstruction = (instruction & 0x8F00FBF0) | imm4 | (i << 10) | (imm3 << 28) | (imm8 << 16);
-					set32LE(fixUpLocation, newInstruction);		
+					set32LE(fixUpLocation, newInstruction);
 				}
 				break;
 #if SUPPORT_ARCH_arm64
@@ -2111,30 +2111,30 @@
 									// vector and byte LDR/STR have same "size" bits, need to check other bits to differenciate
 									implictShift = 4;
 									if ( (offset & 0xF) != 0 ) {
-											throwf("128-bit LDR/STR not 16-byte aligned: from %s (0x%08llX) to %s (0x%08llX)", 
-												atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fit), 
+											throwf("128-bit LDR/STR not 16-byte aligned: from %s (0x%08lX) to %s (0x%08lX)",
+												atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fit),
 												addressOf(state, fit, &toTarget));
 									}
 								}
 								break;
 							case 1:
 								if ( (offset & 0x1) != 0 ) {
-										throwf("16-bit LDR/STR not 2-byte aligned: from %s (0x%08llX) to %s (0x%08llX)", 
-											atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fit), 
+										throwf("16-bit LDR/STR not 2-byte aligned: from %s (0x%08lX) to %s (0x%08lX)",
+											atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fit),
 											addressOf(state, fit, &toTarget));
 								}
 								break;
 							case 2:
 								if ( (offset & 0x3) != 0 ) {
-										throwf("32-bit LDR/STR not 4-byte aligned: from %s (0x%08llX) to %s (0x%08llX)", 
-											atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fit), 
+										throwf("32-bit LDR/STR not 4-byte aligned: from %s (0x%08lX) to %s (0x%08lX)",
+											atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fit),
 											addressOf(state, fit, &toTarget));
 								}
 								break;
 							case 3:
 								if ( (offset & 0x7) != 0 ) {
-										throwf("64-bit LDR/STR not 8-byte aligned: from %s (0x%08llX) to %s (0x%08llX)", 
-											atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fit), 
+										throwf("64-bit LDR/STR not 8-byte aligned: from %s (0x%08lX) to %s (0x%08lX)",
+											atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fit),
 											addressOf(state, fit, &toTarget));
 								}
 								break;
@@ -2192,7 +2192,7 @@
 #endif
 		}
 	}
-	
+
 #if SUPPORT_ARCH_arm64
 	// after all fixups are done on atom, if there are potential optimizations, do those
 	if ( (usedByHints.size() != 0) && (_options.outputKind() != Options::kObjectFile) && !_options.ignoreOptimizationHints() ) {
@@ -2217,10 +2217,10 @@
 					}
 			}
 		}
-		
+
 		// apply hints pass 1
 		for (ld::Fixup::iterator fit = atom->fixupsBegin(), end=atom->fixupsEnd(); fit != end; ++fit) {
-			if ( fit->kind != ld::Fixup::kindLinkerOptimizationHint ) 
+			if ( fit->kind != ld::Fixup::kindLinkerOptimizationHint )
 				continue;
 			InstructionInfo infoA;
 			InstructionInfo infoB;
@@ -2238,7 +2238,7 @@
 			ld::Fixup::LOH_arm64 alt;
 			alt.addend = fit->u.addend;
 			setInfo(state, atom, buffer, usedByHints, fit->offsetInAtom, (alt.info.delta1 << 2), &infoA);
-			if ( alt.info.count > 0 ) 
+			if ( alt.info.count > 0 )
 				setInfo(state, atom, buffer, usedByHints, fit->offsetInAtom, (alt.info.delta2 << 2), &infoB);
 			if ( alt.info.count > 1 )
 				setInfo(state, atom, buffer, usedByHints, fit->offsetInAtom, (alt.info.delta3 << 2), &infoC);
@@ -2285,11 +2285,11 @@
 						set32LE(infoA.instructionContent, makeNOP());
 						set32LE(infoB.instructionContent, makeLDR_literal(ldrInfoB, infoA.targetAddress, infoB.instructionAddress));
 						if ( _options.verboseOptimizationHints() )
-							fprintf(stderr, "adrp-ldr at 0x%08llX transformed to LDR literal, usableSegment=%d usableSegment\n", infoB.instructionAddress, usableSegment);
+							fprintf(stderr, "adrp-ldr at 0x%08lX transformed to LDR literal, usableSegment=%d usableSegment\n", infoB.instructionAddress, usableSegment);
 					}
 					else {
 						if ( _options.verboseOptimizationHints() )
-							fprintf(stderr, "adrp-ldr at 0x%08llX not transformed, isLDR=%d, literalableSize=%d, inRange=%d, usableSegment=%d, scaledOffset=%d\n", 
+							fprintf(stderr, "adrp-ldr at 0x%08lX not transformed, isLDR=%d, literalableSize=%d, inRange=%d, usableSegment=%d, scaledOffset=%d\n",
 								infoB.instructionAddress, isLDR, literalableSize, withinOneMeg(infoB.instructionAddress, infoA.targetAddress), usableSegment, ldrInfoB.offset);
 					}
 					break;
@@ -2316,32 +2316,32 @@
 						set32LE(infoB.instructionContent, makeNOP());
 						set32LE(infoC.instructionContent, makeLDR_literal(ldrInfoC, infoA.targetAddress+ldrInfoC.offset, infoC.instructionAddress));
 						if ( _options.verboseOptimizationHints() ) {
-							fprintf(stderr, "adrp-add-ldr at 0x%08llX T1 transformed to LDR literal\n", infoC.instructionAddress);
+							fprintf(stderr, "adrp-add-ldr at 0x%08lX T1 transformed to LDR literal\n", infoC.instructionAddress);
 						}
 					}
 					else if ( usableSegment && withinOneMeg(infoA.instructionAddress, infoA.targetAddress+ldrInfoC.offset) ) {
 						// can to T4 transformation and turn ADRP/ADD into ADR
 						set32LE(infoA.instructionContent, makeADR(ldrInfoC.baseReg, infoA.targetAddress+ldrInfoC.offset, infoA.instructionAddress));
-						set32LE(infoB.instructionContent, makeNOP());	
+						set32LE(infoB.instructionContent, makeNOP());
 						ldrInfoC.offset = 0; // offset is now in ADR instead of ADD or LDR
 						set32LE(infoC.instructionContent, makeLoadOrStore(ldrInfoC));
-						set32LE(infoC.instructionContent, infoC.instruction & 0xFFC003FF);	
+						set32LE(infoC.instructionContent, infoC.instruction & 0xFFC003FF);
 						if ( _options.verboseOptimizationHints() )
-							fprintf(stderr, "adrp-add-ldr at 0x%08llX T4 transformed to ADR/LDR\n", infoB.instructionAddress);						
+							fprintf(stderr, "adrp-add-ldr at 0x%08lX T4 transformed to ADR/LDR\n", infoB.instructionAddress);
 					}
 					else if ( ((infoB.targetAddress % ldrInfoC.size) == 0) && (ldrInfoC.offset == 0) ) {
 						// can do T2 transformation by merging ADD into LD
 						// Leave ADRP as-is
-						set32LE(infoB.instructionContent, makeNOP());	
+						set32LE(infoB.instructionContent, makeNOP());
 						ldrInfoC.offset += addInfoB.addend;
 						ldrInfoC.baseReg = adrpInfoA.destReg;
 						set32LE(infoC.instructionContent, makeLoadOrStore(ldrInfoC));
 						if ( _options.verboseOptimizationHints() )
-							fprintf(stderr, "adrp-add-ldr at 0x%08llX T2 transformed to ADRP/LDR \n", infoC.instructionAddress);
+							fprintf(stderr, "adrp-add-ldr at 0x%08lX T2 transformed to ADRP/LDR \n", infoC.instructionAddress);
 					}
 					else {
 						if ( _options.verboseOptimizationHints() )
-							fprintf(stderr, "adrp-add-ldr at 0x%08llX could not be transformed, loadSize=%d, literalableSize=%d, inRange=%d, usableSegment=%d, targetFourByteAligned=%d, imm12=%d\n", 
+							fprintf(stderr, "adrp-add-ldr at 0x%08lX could not be transformed, loadSize=%d, literalableSize=%d, inRange=%d, usableSegment=%d, targetFourByteAligned=%d, imm12=%d\n",
 									infoC.instructionAddress, ldrInfoC.size, literalableSize, withinOneMeg(infoC.instructionAddress, infoA.targetAddress+ldrInfoC.offset), usableSegment, targetFourByteAligned, ldrInfoC.offset);
 					}
 					break;
@@ -2357,15 +2357,15 @@
 					LOH_ASSERT(isADD);
 					LOH_ASSERT(adrpInfoA.destReg == addInfoB.srcReg);
 					if ( usableSegment && withinOneMeg(infoA.targetAddress, infoA.instructionAddress) ) {
-						// can do T4 transformation and use ADR 
+						// can do T4 transformation and use ADR
 						set32LE(infoA.instructionContent, makeADR(addInfoB.destReg, infoA.targetAddress, infoA.instructionAddress));
-						set32LE(infoB.instructionContent, makeNOP());	
+						set32LE(infoB.instructionContent, makeNOP());
 						if ( _options.verboseOptimizationHints() )
-							fprintf(stderr, "adrp-add at 0x%08llX transformed to ADR\n", infoB.instructionAddress);
+							fprintf(stderr, "adrp-add at 0x%08lX transformed to ADR\n", infoB.instructionAddress);
 					}
 					else {
 						if ( _options.verboseOptimizationHints() )
-							fprintf(stderr, "adrp-add at 0x%08llX not transformed, isAdd=%d, inRange=%d, usableSegment=%d\n", 
+							fprintf(stderr, "adrp-add at 0x%08lX not transformed, isAdd=%d, inRange=%d, usableSegment=%d\n",
 								infoB.instructionAddress, isADD, withinOneMeg(infoA.targetAddress, infoA.instructionAddress), usableSegment);
 					}
 					break;
@@ -2395,12 +2395,12 @@
 							set32LE(infoA.instructionContent, makeNOP());
 							set32LE(infoB.instructionContent, makeLDR_literal(ldrInfoB, infoA.targetAddress, infoB.instructionAddress));
 							if ( _options.verboseOptimizationHints() ) {
-								fprintf(stderr, "adrp-ldr-got-ldr at 0x%08llX T5 transformed to LDR literal of GOT plus LDR\n", infoC.instructionAddress);
+								fprintf(stderr, "adrp-ldr-got-ldr at 0x%08lX T5 transformed to LDR literal of GOT plus LDR\n", infoC.instructionAddress);
 							}
 						}
 						else {
-							if ( _options.verboseOptimizationHints() ) 
-								fprintf(stderr, "adrp-ldr-got-ldr at 0x%08llX no optimization done\n", infoC.instructionAddress);
+							if ( _options.verboseOptimizationHints() )
+								fprintf(stderr, "adrp-ldr-got-ldr at 0x%08lX no optimization done\n", infoC.instructionAddress);
 						}
 					}
 					else if ( isADD ) {
@@ -2411,19 +2411,19 @@
 						literalableSize  = ( (ldrInfoC.size != 1) && (ldrInfoC.size != 2) );
 						if ( usableSegment && literalableSize && targetFourByteAligned && withinOneMeg(infoC.instructionAddress, infoA.targetAddress + ldrInfoC.offset) ) {
 							// can do T1 transform
-							set32LE(infoA.instructionContent, makeNOP());	
-							set32LE(infoB.instructionContent, makeNOP());	
+							set32LE(infoA.instructionContent, makeNOP());
+							set32LE(infoB.instructionContent, makeNOP());
 							set32LE(infoC.instructionContent, makeLDR_literal(ldrInfoC, infoA.targetAddress + ldrInfoC.offset, infoC.instructionAddress));
-							if ( _options.verboseOptimizationHints() ) 
-								fprintf(stderr, "adrp-ldr-got-ldr at 0x%08llX T1 transformed to LDR literal\n", infoC.instructionAddress);
+							if ( _options.verboseOptimizationHints() )
+								fprintf(stderr, "adrp-ldr-got-ldr at 0x%08lX T1 transformed to LDR literal\n", infoC.instructionAddress);
 						}
 						else if ( usableSegment && withinOneMeg(infoA.instructionAddress, infoA.targetAddress) ) {
 							// can do T4 transform
 							set32LE(infoA.instructionContent, makeADR(ldrInfoC.baseReg, infoA.targetAddress, infoA.instructionAddress));
-							set32LE(infoB.instructionContent, makeNOP());	
+							set32LE(infoB.instructionContent, makeNOP());
 							set32LE(infoC.instructionContent, makeLoadOrStore(ldrInfoC));
 							if ( _options.verboseOptimizationHints() ) {
-								fprintf(stderr, "adrp-ldr-got-ldr at 0x%08llX T4 transformed to ADR/LDR\n", infoC.instructionAddress);
+								fprintf(stderr, "adrp-ldr-got-ldr at 0x%08lX T4 transformed to ADR/LDR\n", infoC.instructionAddress);
 							}
 						}
 						else if ( ((infoA.targetAddress % ldrInfoC.size) == 0) && ((addInfoB.addend + ldrInfoC.offset) < 4096) ) {
@@ -2433,19 +2433,19 @@
 							ldrInfoC.offset += addInfoB.addend;
 							set32LE(infoC.instructionContent, makeLoadOrStore(ldrInfoC));
 							if ( _options.verboseOptimizationHints() ) {
-								fprintf(stderr, "adrp-ldr-got-ldr at 0x%08llX T2 transformed to ADRP/NOP/LDR\n", infoC.instructionAddress);
+								fprintf(stderr, "adrp-ldr-got-ldr at 0x%08lX T2 transformed to ADRP/NOP/LDR\n", infoC.instructionAddress);
 							}
 						}
 						else {
 							// T3 transform already done by ld::passes:got:doPass()
 							if ( _options.verboseOptimizationHints() ) {
-								fprintf(stderr, "adrp-ldr-got-ldr at 0x%08llX T3 transformed to ADRP/ADD/LDR\n", infoC.instructionAddress);
+								fprintf(stderr, "adrp-ldr-got-ldr at 0x%08lX T3 transformed to ADRP/ADD/LDR\n", infoC.instructionAddress);
 							}
 						}
 					}
 					else {
-						if ( _options.verboseOptimizationHints() ) 							
-							fprintf(stderr, "adrp-ldr-got-ldr at 0x%08llX not ADD or LDR\n", infoC.instructionAddress);
+						if ( _options.verboseOptimizationHints() )
+							fprintf(stderr, "adrp-ldr-got-ldr at 0x%08lX not ADD or LDR\n", infoC.instructionAddress);
 					}
 					break;
 				case LOH_ARM64_ADRP_ADD_STR:
@@ -2466,25 +2466,25 @@
 					if ( usableSegment && withinOneMeg(infoA.instructionAddress, infoA.targetAddress+ldrInfoC.offset) ) {
 						// can to T4 transformation and turn ADRP/ADD into ADR
 						set32LE(infoA.instructionContent, makeADR(ldrInfoC.baseReg, infoA.targetAddress+ldrInfoC.offset, infoA.instructionAddress));
-						set32LE(infoB.instructionContent, makeNOP());	
+						set32LE(infoB.instructionContent, makeNOP());
 						ldrInfoC.offset = 0; // offset is now in ADR instead of ADD or LDR
 						set32LE(infoC.instructionContent, makeLoadOrStore(ldrInfoC));
-						set32LE(infoC.instructionContent, infoC.instruction & 0xFFC003FF);	
+						set32LE(infoC.instructionContent, infoC.instruction & 0xFFC003FF);
 						if ( _options.verboseOptimizationHints() )
-							fprintf(stderr, "adrp-add-str at 0x%08llX T4 transformed to ADR/STR\n", infoB.instructionAddress);						
+							fprintf(stderr, "adrp-add-str at 0x%08lX T4 transformed to ADR/STR\n", infoB.instructionAddress);
 					}
 					else if ( ((infoB.targetAddress % ldrInfoC.size) == 0) && (ldrInfoC.offset == 0) ) {
 						// can do T2 transformation by merging ADD into STR
 						// Leave ADRP as-is
-						set32LE(infoB.instructionContent, makeNOP());	
+						set32LE(infoB.instructionContent, makeNOP());
 						ldrInfoC.offset += addInfoB.addend;
 						set32LE(infoC.instructionContent, makeLoadOrStore(ldrInfoC));
 						if ( _options.verboseOptimizationHints() )
-							fprintf(stderr, "adrp-add-str at 0x%08llX T2 transformed to ADRP/STR \n", infoC.instructionAddress);
+							fprintf(stderr, "adrp-add-str at 0x%08lX T2 transformed to ADRP/STR \n", infoC.instructionAddress);
 					}
 					else {
 						if ( _options.verboseOptimizationHints() )
-							fprintf(stderr, "adrp-add-str at 0x%08llX could not be transformed, loadSize=%d, inRange=%d, usableSegment=%d, imm12=%d\n", 
+							fprintf(stderr, "adrp-add-str at 0x%08lX could not be transformed, loadSize=%d, inRange=%d, usableSegment=%d, imm12=%d\n",
 									infoC.instructionAddress, ldrInfoC.size, withinOneMeg(infoC.instructionAddress, infoA.targetAddress+ldrInfoC.offset), usableSegment, ldrInfoC.offset);
 					}
 					break;
@@ -2513,12 +2513,12 @@
 							set32LE(infoA.instructionContent, makeNOP());
 							set32LE(infoB.instructionContent, makeLDR_literal(ldrInfoB, infoA.targetAddress, infoB.instructionAddress));
 							if ( _options.verboseOptimizationHints() ) {
-								fprintf(stderr, "adrp-ldr-got-str at 0x%08llX T5 transformed to LDR literal of GOT plus STR\n", infoC.instructionAddress);
+								fprintf(stderr, "adrp-ldr-got-str at 0x%08lX T5 transformed to LDR literal of GOT plus STR\n", infoC.instructionAddress);
 							}
 						}
 						else {
-							if ( _options.verboseOptimizationHints() ) 
-								fprintf(stderr, "adrp-ldr-got-str at 0x%08llX no optimization done\n", infoC.instructionAddress);
+							if ( _options.verboseOptimizationHints() )
+								fprintf(stderr, "adrp-ldr-got-str at 0x%08lX no optimization done\n", infoC.instructionAddress);
 						}
 					}
 					else if ( isADD ) {
@@ -2530,10 +2530,10 @@
 						if ( usableSegment && withinOneMeg(infoA.instructionAddress, infoA.targetAddress) ) {
 							// can do T4 transform
 							set32LE(infoA.instructionContent, makeADR(ldrInfoC.baseReg, infoA.targetAddress, infoA.instructionAddress));
-							set32LE(infoB.instructionContent, makeNOP());	
+							set32LE(infoB.instructionContent, makeNOP());
 							set32LE(infoC.instructionContent, makeLoadOrStore(ldrInfoC));
 							if ( _options.verboseOptimizationHints() ) {
-								fprintf(stderr, "adrp-ldr-got-str at 0x%08llX T4 transformed to ADR/STR\n", infoC.instructionAddress);
+								fprintf(stderr, "adrp-ldr-got-str at 0x%08lX T4 transformed to ADR/STR\n", infoC.instructionAddress);
 							}
 						}
 						else if ( ((infoA.targetAddress % ldrInfoC.size) == 0) && (ldrInfoC.offset == 0) ) {
@@ -2543,19 +2543,19 @@
 							ldrInfoC.offset += addInfoB.addend;
 							set32LE(infoC.instructionContent, makeLoadOrStore(ldrInfoC));
 							if ( _options.verboseOptimizationHints() ) {
-								fprintf(stderr, "adrp-ldr-got-str at 0x%08llX T4 transformed to ADRP/NOP/STR\n", infoC.instructionAddress);
+								fprintf(stderr, "adrp-ldr-got-str at 0x%08lX T4 transformed to ADRP/NOP/STR\n", infoC.instructionAddress);
 							}
 						}
 						else {
 							// T3 transform already done by ld::passes:got:doPass()
 							if ( _options.verboseOptimizationHints() ) {
-								fprintf(stderr, "adrp-ldr-got-str at 0x%08llX T3 transformed to ADRP/ADD/STR\n", infoC.instructionAddress);
+								fprintf(stderr, "adrp-ldr-got-str at 0x%08lX T3 transformed to ADRP/ADD/STR\n", infoC.instructionAddress);
 							}
 						}
 					}
 					else {
-						if ( _options.verboseOptimizationHints() ) 							
-							fprintf(stderr, "adrp-ldr-got-str at 0x%08llX not ADD or LDR\n", infoC.instructionAddress);
+						if ( _options.verboseOptimizationHints() )
+							fprintf(stderr, "adrp-ldr-got-str at 0x%08lX not ADD or LDR\n", infoC.instructionAddress);
 					}
 					break;
 				case LOH_ARM64_ADRP_LDR_GOT:
@@ -2574,7 +2574,7 @@
 								set32LE(infoA.instructionContent, makeNOP());
 								set32LE(infoB.instructionContent, makeLDR_literal(ldrInfoB, infoA.targetAddress, infoB.instructionAddress));
 								if ( _options.verboseOptimizationHints() ) {
-									fprintf(stderr, "adrp-ldr-got at 0x%08llX T5 transformed to NOP/LDR\n", infoC.instructionAddress);
+									fprintf(stderr, "adrp-ldr-got at 0x%08lX T5 transformed to NOP/LDR\n", infoC.instructionAddress);
 								}
 							}
 						}
@@ -2584,36 +2584,36 @@
 								set32LE(infoA.instructionContent, makeADR(addInfoB.destReg, infoA.targetAddress, infoA.instructionAddress));
 								set32LE(infoB.instructionContent, makeNOP());
 								if ( _options.verboseOptimizationHints() ) {
-									fprintf(stderr, "adrp-ldr-got at 0x%08llX T4 transformed to ADR/STR\n", infoC.instructionAddress);
+									fprintf(stderr, "adrp-ldr-got at 0x%08lX T4 transformed to ADR/STR\n", infoC.instructionAddress);
 								}
 							}
 						}
 						else {
 							if ( _options.verboseOptimizationHints() )
-								fprintf(stderr, "adrp-ldr-got at 0x%08llX not LDR or ADD\n", infoB.instructionAddress);
+								fprintf(stderr, "adrp-ldr-got at 0x%08lX not LDR or ADD\n", infoB.instructionAddress);
 						}
 					}
 					else {
 						if ( _options.verboseOptimizationHints() )
-							fprintf(stderr, "adrp-ldr-got at 0x%08llX not ADRP\n", infoA.instructionAddress);
+							fprintf(stderr, "adrp-ldr-got at 0x%08lX not ADRP\n", infoA.instructionAddress);
 					}
 					break;
 				default:
-						if ( _options.verboseOptimizationHints() ) 							
-							fprintf(stderr, "unknown hint kind %d alt.info.kind at 0x%08llX\n", alt.info.kind, infoA.instructionAddress);
+						if ( _options.verboseOptimizationHints() )
+							fprintf(stderr, "unknown hint kind %d alt.info.kind at 0x%08lX\n", alt.info.kind, infoA.instructionAddress);
 					break;
 			}
 		}
 		// apply hints pass 2
 		for (ld::Fixup::iterator fit = atom->fixupsBegin(), end=atom->fixupsEnd(); fit != end; ++fit) {
-			if ( fit->kind != ld::Fixup::kindLinkerOptimizationHint ) 
+			if ( fit->kind != ld::Fixup::kindLinkerOptimizationHint )
 				continue;
 			InstructionInfo infoA;
 			InstructionInfo infoB;
 			ld::Fixup::LOH_arm64 alt;
 			alt.addend = fit->u.addend;
 			setInfo(state, atom, buffer, usedByHints, fit->offsetInAtom, (alt.info.delta1 << 2), &infoA);
-			if ( alt.info.count > 0 ) 
+			if ( alt.info.count > 0 )
 				setInfo(state, atom, buffer, usedByHints, fit->offsetInAtom, (alt.info.delta2 << 2), &infoB);
 
 			switch ( alt.info.kind ) {
@@ -2622,13 +2622,13 @@
 					LOH_ASSERT(isPageKind(infoB.fixup));
 					if ( (infoA.instruction & 0x9F000000) != 0x90000000 ) {
 						if ( _options.verboseOptimizationHints() )
-							fprintf(stderr, "may-reused-adrp at 0x%08llX no longer an ADRP, now 0x%08X\n", infoA.instructionAddress, infoA.instruction);
+							fprintf(stderr, "may-reused-adrp at 0x%08lX no longer an ADRP, now 0x%08X\n", infoA.instructionAddress, infoA.instruction);
 						sAdrpNA++;
 						break;
 					}
 					if ( (infoB.instruction & 0x9F000000) != 0x90000000 ) {
 						if ( _options.verboseOptimizationHints() )
-							fprintf(stderr, "may-reused-adrp at 0x%08llX no longer an ADRP, now 0x%08X\n", infoB.instructionAddress, infoA.instruction);
+							fprintf(stderr, "may-reused-adrp at 0x%08lX no longer an ADRP, now 0x%08X\n", infoB.instructionAddress, infoA.instruction);
 						sAdrpNA++;
 						break;
 					}
@@ -2640,7 +2640,7 @@
 						sAdrpNotNoped++;
 					}
 					break;
-			}				
+			}
 		}
 	}
 #endif // SUPPORT_ARCH_arm64
@@ -2994,7 +2994,7 @@
 			}
 		}
 	}
-	
+
 	if ( _options.verboseOptimizationHints() ) {
 		//fprintf(stderr, "ADRP optimized away:   %d\n", sAdrpNA);
 		//fprintf(stderr, "ADRPs changed to NOPs: %d\n", sAdrpNoped);
@@ -3055,7 +3055,7 @@
 			threadStartsReservedSpace = (threadStartsSection->size - 4) / 4;
 			threadStarts.reserve(threadStartsReservedSpace);
 		}
-		
+
 		auto getAddress = [this](int64_t index) {
 			if (index <= 0)
 				return _rebaseInfo[-index]._address;
@@ -3067,7 +3067,7 @@
 			&& ! findSegment(state, getAddress(_threadedRebaseBindIndices.front()),
 							 &curSegStart, &curSegEnd, &curSegIndex) )
 			throw "binding address outside range of any segment";
-		
+
 		auto applyBind = [&](int64_t currentIndex, int64_t nextIndex) {
 			uint64_t currentAddress = getAddress(currentIndex);
 			uint64_t nextAddress = getAddress(nextIndex);
@@ -3088,7 +3088,7 @@
 				}
 			}
 
-			if (logThreadedFixups) fprintf(stderr, "fixup: %s, address=0x%llX\n", curSection->sectionName(), currentAddress);
+			if (logThreadedFixups) fprintf(stderr, "fixup: %s, address=0x%lX\n", curSection->sectionName(), currentAddress);
 
 			bool makeChainToNextAddress = true;
 			if ( allowThreadsToCrossPages ) {
@@ -3227,10 +3227,10 @@
 				if ( ! findSegment(state, nextAddress, &curSegStart, &curSegEnd, &curSegIndex) )
 					throw "binding address outside range of any segment";
 			}
-			
+
 			applyBind(currentIndex, nextIndex);
 		}
-		
+
 		applyBind(_threadedRebaseBindIndices.back(), _threadedRebaseBindIndices.back());
 
 		if ( _options.makeThreadedStartsSection() ) {
@@ -3249,13 +3249,13 @@
 			}
 			uint64_t threadStartsFileOffset = threadStartsAtom->finalAddress() - threadStartsSection->address + threadStartsSection->fileOffset;
 			// Skip the header
-			if (logThreadedFixups) fprintf(stderr, "thread start[0x%llX]: header=0x%X\n", threadStartsFileOffset, get32LE(&wholeBuffer[threadStartsFileOffset]));
+			if (logThreadedFixups) fprintf(stderr, "thread start[0x%lX]: header=0x%X\n", threadStartsFileOffset, get32LE(&wholeBuffer[threadStartsFileOffset]));
 			threadStartsFileOffset += sizeof(uint32_t);
 			for (uint64_t threadStart : threadStarts) {
 				uint64_t offset = threadStart - baseAddress;
 				assert(offset < 0x100000000);
 				set32LE(&wholeBuffer[threadStartsFileOffset], offset);
-				if (logThreadedFixups) fprintf(stderr, "thread start[0x%llX]: address=0x%llX -> offset=0x%llX\n", threadStartsFileOffset, threadStart, offset);
+				if (logThreadedFixups) fprintf(stderr, "thread start[0x%lX]: address=0x%lX -> offset=0x%lX\n", threadStartsFileOffset, threadStart, offset);
 				threadStartsFileOffset += sizeof(uint32_t);
 			}
 		}
@@ -3450,7 +3450,7 @@
 		assert(curLoc->next == lastSteps);
 		return;
 	}
-	
+
 	// no way to make chain, add a new chain start
 	uint16_t newChainStartOffset = (uint8_t*)finalLoc - pageBufferStart;
 	ChainedFixupPageInfo& pageInfo = segInfo.pages[pageIndex];
@@ -3476,11 +3476,11 @@
 			// the bitcode section should also be excluded in the UUID computation.
 			// Bitcode section should appears before LINKEDIT
 			// Exclude section cmd
-			if ( log ) fprintf(stderr, "bundle cmd start=0x%08llX, bundle cmd end=0x%08llX\n",
+			if ( log ) fprintf(stderr, "bundle cmd start=0x%08lX, bundle cmd end=0x%08lX\n",
 							   bitcodeCmdOffset, bitcodeCmdEnd);
 			excludeRegions.emplace_back(std::pair<uint64_t, uint64_t>(bitcodeCmdOffset, bitcodeCmdEnd));
 			// Exclude section content
-			if ( log ) fprintf(stderr, "bundle start=0x%08llX, bundle end=0x%08llX\n",
+			if ( log ) fprintf(stderr, "bundle start=0x%08lX, bundle end=0x%08lX\n",
 							   bitcodeSectOffset, bitcodePaddingEnd);
 			excludeRegions.emplace_back(std::pair<uint64_t, uint64_t>(bitcodeSectOffset, bitcodePaddingEnd));
 		}
@@ -3509,8 +3509,8 @@
 			uint64_t lastStabNlistFileOffset   = symbolTableFileOffset + stabsOffsetEnd;
 			uint64_t firstStabStringFileOffset = stringPoolFileOffset  + stabsStringsOffsetStart;
 			uint64_t lastStabStringFileOffset  = stringPoolFileOffset  + tabsStringsOffsetEnd;
-			if ( log ) fprintf(stderr, "stabNlist offset=0x%08llX, size=0x%08llX\n", firstStabNlistFileOffset, lastStabNlistFileOffset-firstStabNlistFileOffset);
-			if ( log ) fprintf(stderr, "stabString offset=0x%08llX, size=0x%08llX\n", firstStabStringFileOffset, lastStabStringFileOffset-firstStabStringFileOffset);
+			if ( log ) fprintf(stderr, "stabNlist offset=0x%08lX, size=0x%08lX\n", firstStabNlistFileOffset, lastStabNlistFileOffset-firstStabNlistFileOffset);
+			if ( log ) fprintf(stderr, "stabString offset=0x%08lX, size=0x%08lX\n", firstStabStringFileOffset, lastStabStringFileOffset-firstStabStringFileOffset);
 			assert(firstStabNlistFileOffset <= firstStabStringFileOffset);
 			excludeRegions.emplace_back(std::pair<uint64_t, uint64_t>(firstStabNlistFileOffset, lastStabNlistFileOffset));
 			// <rdar://problem/50666172> don't MD5 the zero padding at the end of the string pool, after the stabs strings
@@ -3523,12 +3523,12 @@
 			uint64_t linkeditSegCmdSize;
 			_headersAndLoadCommandAtom->linkeditCmdInfo(linkeditSegCmdOffset, linkeditSegCmdSize);
 			excludeRegions.emplace_back(std::pair<uint64_t, uint64_t>(linkeditSegCmdOffset, linkeditSegCmdOffset+linkeditSegCmdSize));
-			if ( log ) fprintf(stderr, "linkedit SegCmdOffset=0x%08llX, size=0x%08llX\n", linkeditSegCmdOffset, linkeditSegCmdSize);
+			if ( log ) fprintf(stderr, "linkedit SegCmdOffset=0x%08lX, size=0x%08lX\n", linkeditSegCmdOffset, linkeditSegCmdSize);
 			uint64_t symbolTableCmdOffset;
 			uint64_t symbolTableCmdSize;
 			_headersAndLoadCommandAtom->symbolTableCmdInfo(symbolTableCmdOffset, symbolTableCmdSize);
 			excludeRegions.emplace_back(std::pair<uint64_t, uint64_t>(symbolTableCmdOffset, symbolTableCmdOffset+symbolTableCmdSize));
-			if ( log ) fprintf(stderr, "linkedit SegCmdOffset=0x%08llX, size=0x%08llX\n", symbolTableCmdOffset, symbolTableCmdSize);
+			if ( log ) fprintf(stderr, "linkedit SegCmdOffset=0x%08lX, size=0x%08lX\n", symbolTableCmdOffset, symbolTableCmdSize);
 		}
 		if ( !excludeRegions.empty() ) {
 			CC_MD5_CTX md5state;
@@ -3549,12 +3549,12 @@
 				uint64_t regionStart = region.first;
 				uint64_t regionEnd = region.second;
 				assert(checksumStart <= regionStart && regionStart <= regionEnd && "Region overlapped");
-				if ( log ) fprintf(stderr, "checksum 0x%08llX -> 0x%08llX\n", checksumStart, regionStart);
+				if ( log ) fprintf(stderr, "checksum 0x%08lX -> 0x%08lX\n", checksumStart, regionStart);
 				CC_MD5_Update(&md5state, &wholeBuffer[checksumStart], regionStart - checksumStart);
 				checksumStart = regionEnd;
 			}
 			if ( checksumStart < _fileSize ) {
-				if ( log ) fprintf(stderr, "checksum 0x%08llX -> 0x%08llX\n", checksumStart, _fileSize);
+				if ( log ) fprintf(stderr, "checksum 0x%08lX -> 0x%08lX\n", checksumStart, _fileSize);
 				CC_MD5_Update(&md5state, &wholeBuffer[checksumStart], _fileSize-checksumStart);
 			}
 			CC_MD5_Final(digest, &md5state);
@@ -3589,7 +3589,7 @@
 	// we are in a sig handler, don't do clean ups
 	_exit(1);
 }
-	
+
 void OutputFile::writeOutputFile(ld::Internal& state)
 {
 	// for UNIX conformance, error if file exists and is not writable
@@ -3627,7 +3627,7 @@
 #ifdef __APPLE__ // ld64-port
 			}
 #endif /* __APPLE__ */
-		} 
+		}
 		else {
 			outputIsRegularFile = false;
 		}
@@ -3651,9 +3651,9 @@
 #endif /* __APPLE__ */
 		}
 	}
-	
+
 	//fprintf(stderr, "outputIsMappableFile=%d, outputIsRegularFile=%d, path=%s\n", outputIsMappableFile, outputIsRegularFile, _options.outputFilePath());
-	
+
 	int fd;
 	// Construct a temporary path of the form {outputFilePath}.ld_XXXXXX
 	const char filenameTemplate[] = ".ld_XXXXXX";
@@ -3665,16 +3665,16 @@
 
 		strcpy(tmpOutput, _options.outputFilePath());
 		// If the path is too long to add a suffix for a temporary name then
-		// just fall back to using the output path. 
+		// just fall back to using the output path.
 		if (strlen(tmpOutput)+strlen(filenameTemplate) < PATH_MAX) {
 			strcat(tmpOutput, filenameTemplate);
 			fd = mkstemp(tmpOutput);
 			sDescriptorOfPathToRemove = fd;
-		} 
+		}
 		else {
 			fd = open(tmpOutput, O_RDWR|O_CREAT, permissions);
 		}
-		if ( fd == -1 ) 
+		if ( fd == -1 )
 			throwf("can't open output file for writing '%s', errno=%d", tmpOutput, errno);
 		if ( ftruncate(fd, _fileSize) == -1 ) {
 			int err = errno;
@@ -3684,24 +3684,24 @@
 			else
 				throwf("can't grow file for writing '%s', errno=%d", _options.outputFilePath(), err);
 		}
-		
+
 		wholeBuffer = (uint8_t *)mmap(NULL, _fileSize, PROT_WRITE|PROT_READ, MAP_SHARED, fd, 0);
 		if ( wholeBuffer == MAP_FAILED )
-			throwf("can't create buffer of %llu bytes for output", _fileSize);
-	} 
+			throwf("can't create buffer of %lu bytes for output", _fileSize);
+	}
 	else {
 		if ( outputIsRegularFile )
 			fd = open(_options.outputFilePath(),  O_RDWR|O_CREAT, permissions);
 		else
 			fd = open(_options.outputFilePath(),  O_WRONLY);
-		if ( fd == -1 ) 
+		if ( fd == -1 )
 			throwf("can't open output file for writing: %s, errno=%d", _options.outputFilePath(), errno);
 		// try to allocate buffer for entire output file content
 		wholeBuffer = (uint8_t*)calloc(_fileSize, 1);
 		if ( wholeBuffer == NULL )
-			throwf("can't create buffer of %llu bytes for output", _fileSize);
+			throwf("can't create buffer of %lu bytes for output", _fileSize);
 	}
-	
+
 	if ( _options.UUIDMode() == Options::kUUIDRandom ) {
 #ifdef HAVE_UUID_UUID_H // ld64-port
 		uint8_t bits[16];
@@ -3713,8 +3713,8 @@
 	}
 
 	writeAtoms(state, wholeBuffer);
-	
-	// compute UUID 
+
+	// compute UUID
 	if ( _options.UUIDMode() == Options::kUUIDContent )
 		computeContentUUID(state, wholeBuffer);
 
@@ -3727,7 +3727,7 @@
 			unlink(tmpOutput);
 			throwf("can't move output file in place, errno=%d", errno);
 		}
-	} 
+	}
 	else {
 		if ( ::write(fd, wholeBuffer, _fileSize) == -1 ) {
 			throwf("can't write to output file: %s, errno=%d", _options.outputFilePath(), errno);
@@ -3793,7 +3793,7 @@
 	for (std::vector<ld::Internal::FinalSection*>::iterator sit = state.sections.begin(); sit != state.sections.end(); ++sit) {
 		ld::Internal::FinalSection* sect = *sit;
 		bool setMachoSectionIndex = !sect->isSectionHidden() && (sect->type() != ld::Section::typeTentativeDefs);
-		if ( setMachoSectionIndex ) 
+		if ( setMachoSectionIndex )
 			++machoSectionIndex;
 		for (std::vector<const ld::Atom*>::iterator ait = sect->atoms.begin(); ait != sect->atoms.end(); ++ait) {
 			const ld::Atom* atom = *ait;
@@ -3805,7 +3805,7 @@
 				(const_cast<ld::Atom*>(atom))->setMachoSection(machoSectionIndex); // use section index of previous section
 			else if ( sect->type() == ld::Section::typeFirstSection )
 				(const_cast<ld::Atom*>(atom))->setMachoSection(machoSectionIndex+1); // use section index of next section
-				
+
 			// in -r mode, clarify symbolTableNotInFinalLinkedImages
 			if ( _options.outputKind() == Options::kObjectFile ) {
 				if ( (_options.architecture() == CPU_TYPE_X86_64)
@@ -3839,18 +3839,18 @@
 				&& (_options.outputKind() == Options::kDynamicLibrary) ) {
 					(const_cast<ld::Atom*>(atom))->setScope(ld::Atom::scopeGlobal);
 			}
-			
+
 			// <rdar://problem/6783167> support auto hidden weak symbols: .weak_def_can_be_hidden
 			if ( atom->autoHide() && (_options.outputKind() != Options::kObjectFile) ) {
 				// adding auto-hide symbol to .exp file should keep it global
 				if ( !_options.hasExportMaskList() || !_options.shouldExport(atom->name()) )
 					(const_cast<ld::Atom*>(atom))->setScope(ld::Atom::scopeLinkageUnit);
 			}
-			
+
 			// <rdar://problem/8626058> ld should consistently warn when resolvers are not exported
 			if ( (atom->contentType() == ld::Atom::typeResolver) && (atom->scope() == ld::Atom::scopeLinkageUnit) )
 				warning("resolver functions should be external, but '%s' is hidden", atom->name());
-			
+
 			if ( sect->type() == ld::Section::typeImportProxies ) {
 				if ( atom->combine() == ld::Atom::combineByName )
 					this->usesWeakExternalSymbols = true;
@@ -3870,11 +3870,11 @@
 			if ( atom->symbolTableInclusion() == ld::Atom::symbolTableNotIn ) {
 				continue;  // don't add to symbol table
 			}
-			if ( (atom->symbolTableInclusion() == ld::Atom::symbolTableInWithRandomAutoStripLabel) 
+			if ( (atom->symbolTableInclusion() == ld::Atom::symbolTableInWithRandomAutoStripLabel)
 				&& (_options.outputKind() != Options::kObjectFile) ) {
 				continue;  // don't add to symbol table
 			}
-			
+
 			if ( (atom->definition() == ld::Atom::definitionTentative) && (_options.outputKind() == Options::kObjectFile) ) {
 				if ( _options.makeTentativeDefinitionsReal() ) {
 					// -r -d turns tentative defintions into real def
@@ -3889,7 +3889,7 @@
 
 			switch ( atom->scope() ) {
 				case ld::Atom::scopeTranslationUnit:
-					if ( _options.keepLocalSymbol(atom->name()) ) {	
+					if ( _options.keepLocalSymbol(atom->name()) ) {
 						_localAtoms.push_back(atom);
 					}
 					else {
@@ -3899,7 +3899,7 @@
 						}
 						else
 							(const_cast<ld::Atom*>(atom))->setSymbolTableInclusion(ld::Atom::symbolTableNotIn);
-					}	
+					}
 					break;
 				case ld::Atom::scopeGlobal:
 					_exportedAtoms.push_back(atom);
@@ -3925,7 +3925,7 @@
 						}
 					}
 					else {
-						if ( _options.keepLocalSymbol(atom->name()) ) 
+						if ( _options.keepLocalSymbol(atom->name()) )
 							_localAtoms.push_back(atom);
 						// <rdar://problem/5804214> ld should never have a symbol in the non-lazy indirect symbol table with index 0
 						// this works by making __mh_execute_header be a local symbol which takes symbol index 0
@@ -3938,7 +3938,7 @@
 			}
 		}
 	}
-	
+
 	// <rdar://problem/6978069> ld adds undefined symbol from .exp file to binary
 	if ( (_options.outputKind() == Options::kKextBundle) && _options.hasExportRestrictList() ) {
 		// search for referenced undefines
@@ -3962,9 +3962,9 @@
 			}
 		}
 		// remove any unreferenced _importedAtoms
-		_importedAtoms.erase(std::remove_if(_importedAtoms.begin(), _importedAtoms.end(), NotInSet(referencedProxyAtoms)), _importedAtoms.end());			
+		_importedAtoms.erase(std::remove_if(_importedAtoms.begin(), _importedAtoms.end(), NotInSet(referencedProxyAtoms)), _importedAtoms.end());
 	}
-	
+
 	// sort by name
 	std::sort(_exportedAtoms.begin(), _exportedAtoms.end(), AtomByNameSorter());
 	std::sort(_importedAtoms.begin(), _importedAtoms.end(), AtomByNameSorter());
@@ -4145,9 +4145,9 @@
 void OutputFile::addLinkEdit(ld::Internal& state)
 {
 	// for historical reasons, -preload orders LINKEDIT content differently
-	if  ( _options.outputKind() == Options::kPreload ) 
+	if  ( _options.outputKind() == Options::kPreload )
 		return addPreloadLinkEdit(state);
-	
+
 	switch ( _options.architecture() ) {
 #if SUPPORT_ARCH_i386
 		case CPU_TYPE_I386:
@@ -4166,16 +4166,16 @@
 			if ( _hasDyldInfo ) {
 				_rebasingInfoAtom = new RebaseInfoAtom<x86>(_options, state, *this);
 				rebaseSection = state.addAtom(*_rebasingInfoAtom);
-				
+
 				_bindingInfoAtom = new BindingInfoAtom<x86>(_options, state, *this);
 				bindingSection = state.addAtom(*_bindingInfoAtom);
-				
+
 				_weakBindingInfoAtom = new WeakBindingInfoAtom<x86>(_options, state, *this);
 				weakBindingSection = state.addAtom(*_weakBindingInfoAtom);
-				
+
 				_lazyBindingInfoAtom = new LazyBindingInfoAtom<x86>(_options, state, *this);
 				lazyBindingSection = state.addAtom(*_lazyBindingInfoAtom);
-				
+
 				_exportInfoAtom = new ExportInfoAtom<x86>(_options, state, *this);
 				exportSection = state.addAtom(*_exportInfoAtom);
 			}
@@ -4235,16 +4235,16 @@
 			if ( _hasDyldInfo ) {
 				_rebasingInfoAtom = new RebaseInfoAtom<x86_64>(_options, state, *this);
 				rebaseSection = state.addAtom(*_rebasingInfoAtom);
-				
+
 				_bindingInfoAtom = new BindingInfoAtom<x86_64>(_options, state, *this);
 				bindingSection = state.addAtom(*_bindingInfoAtom);
-				
+
 				_weakBindingInfoAtom = new WeakBindingInfoAtom<x86_64>(_options, state, *this);
 				weakBindingSection = state.addAtom(*_weakBindingInfoAtom);
-				
+
 				_lazyBindingInfoAtom = new LazyBindingInfoAtom<x86_64>(_options, state, *this);
 				lazyBindingSection = state.addAtom(*_lazyBindingInfoAtom);
-				
+
 				_exportInfoAtom = new ExportInfoAtom<x86_64>(_options, state, *this);
 				exportSection = state.addAtom(*_exportInfoAtom);
 			}
@@ -4304,16 +4304,16 @@
 			if ( _hasDyldInfo ) {
 				_rebasingInfoAtom = new RebaseInfoAtom<arm>(_options, state, *this);
 				rebaseSection = state.addAtom(*_rebasingInfoAtom);
-				
+
 				_bindingInfoAtom = new BindingInfoAtom<arm>(_options, state, *this);
 				bindingSection = state.addAtom(*_bindingInfoAtom);
-				
+
 				_weakBindingInfoAtom = new WeakBindingInfoAtom<arm>(_options, state, *this);
 				weakBindingSection = state.addAtom(*_weakBindingInfoAtom);
-				
+
 				_lazyBindingInfoAtom = new LazyBindingInfoAtom<arm>(_options, state, *this);
 				lazyBindingSection = state.addAtom(*_lazyBindingInfoAtom);
-				
+
 				_exportInfoAtom = new ExportInfoAtom<arm>(_options, state, *this);
 				exportSection = state.addAtom(*_exportInfoAtom);
 			}
@@ -4373,16 +4373,16 @@
 			if ( _hasDyldInfo ) {
 				_rebasingInfoAtom = new RebaseInfoAtom<arm64>(_options, state, *this);
 				rebaseSection = state.addAtom(*_rebasingInfoAtom);
-				
+
 				_bindingInfoAtom = new BindingInfoAtom<arm64>(_options, state, *this);
 				bindingSection = state.addAtom(*_bindingInfoAtom);
-				
+
 				_weakBindingInfoAtom = new WeakBindingInfoAtom<arm64>(_options, state, *this);
 				weakBindingSection = state.addAtom(*_weakBindingInfoAtom);
-				
+
 				_lazyBindingInfoAtom = new LazyBindingInfoAtom<arm64>(_options, state, *this);
 				lazyBindingSection = state.addAtom(*_lazyBindingInfoAtom);
-				
+
 				_exportInfoAtom = new ExportInfoAtom<arm64>(_options, state, *this);
 				exportSection = state.addAtom(*_exportInfoAtom);
 			}
@@ -4500,10 +4500,10 @@
 	unsigned int nonPublicReExportCount = 0;
 	for (std::vector<ld::dylib::File*>::iterator it = state.dylibs.begin(); it != state.dylibs.end(); ++it) {
 		ld::dylib::File* aDylib = *it;
-		if ( aDylib->willBeReExported() && ! aDylib->hasPublicInstallName() ) 
+		if ( aDylib->willBeReExported() && ! aDylib->hasPublicInstallName() )
 			++nonPublicReExportCount;
 	}
-	
+
 	// look at each dylib supplied in state
 	__block std::unordered_map<const char*, ld::dylib::File*, CStringHash, CStringEquals> allReExports;
 	bool hasReExports = false;
@@ -4599,14 +4599,14 @@
 			return pos->second;
 		assert(0 && "dylib not assigned ordinal");
 	}
-	
+
 	// handle undefined dynamic_lookup
 	if ( _options.undefinedTreatment() == Options::kUndefinedDynamicLookup ) {
 		if ( _options.sharedRegionEligible() )
 			throwf("-undefined dynamic_lookup cannot be used to find '%s' in dylib in dyld shared cache", target->name());
 		return BIND_SPECIAL_DYLIB_FLAT_LOOKUP;
 	}
-	
+
 	// handle -U _foo
 	if ( _options.allowedUndefined(target->name()) )
 		return BIND_SPECIAL_DYLIB_FLAT_LOOKUP;
@@ -4622,7 +4622,7 @@
 
 bool OutputFile::isStore(ld::Fixup::Kind kind)
 {
-	switch ( kind ) { 
+	switch ( kind ) {
 		case ld::Fixup::kindNone:
 		case ld::Fixup::kindNoneFollowOn:
 		case ld::Fixup::kindNoneGroupSubordinate:
@@ -4653,7 +4653,7 @@
 
 bool OutputFile::isPointerToTarget(ld::Fixup::Kind kind)
 {
-	switch ( kind ) { 
+	switch ( kind ) {
 		case ld::Fixup::kindSetTargetAddress:
 		case ld::Fixup::kindStoreTargetAddressLittleEndian32:
 		case ld::Fixup::kindStoreTargetAddressLittleEndian64:
@@ -4671,7 +4671,7 @@
 }
 bool OutputFile::isPointerFromTarget(ld::Fixup::Kind kind)
 {
-	switch ( kind ) { 
+	switch ( kind ) {
 		case ld::Fixup::kindSubtractTargetAddress:
 			return true;
 		default:
@@ -4730,13 +4730,13 @@
 		if ( _options.makeEncryptable() && (strcmp(sect->segmentName(), "__TEXT") == 0) && (strcmp(sect->sectionName(), "__oslogstring") != 0) ) {
 			_encryptedTEXTendOffset = pageAlign(sect->fileOffset + sect->size);
 		}
-		bool objc1ClassRefSection = ( (sect->type() == ld::Section::typeCStringPointer) 
+		bool objc1ClassRefSection = ( (sect->type() == ld::Section::typeCStringPointer)
 									&& (strcmp(sect->sectionName(), "__cls_refs") == 0)
 									&& (strcmp(sect->segmentName(), "__OBJC") == 0) );
 		for (std::vector<const ld::Atom*>::iterator ait = sect->atoms.begin(); ait != sect->atoms.end(); ++ait) {
 			const ld::Atom*		atom = *ait;
-			
-			// Record regular atoms that override a dylib's weak definitions 
+
+			// Record regular atoms that override a dylib's weak definitions
 			if ( (atom->scope() == ld::Atom::scopeGlobal) && atom->overridesDylibsWeakDef() ) {
 				if ( _options.makeCompressedDyldInfo() ) {
 					uint8_t wtype = BIND_TYPE_OVERRIDE_OF_WEAKDEF_IN_DYLIB;
@@ -4750,7 +4750,7 @@
 				if ( _options.warnWeakExports()	)
 					warning("overrides weak external symbol: %s", atom->name());
 			}
-			
+
 			ld::Fixup*			fixupWithTarget = NULL;
 			ld::Fixup*			fixupWithMinusTarget = NULL;
 			ld::Fixup*			fixupWithStore = NULL;
@@ -4832,7 +4832,7 @@
 						break;
 #endif
 					default:
-                        break;    
+                        break;
 				}
 				if ( fit->isStore() ) {
 					fixupWithStore = fit;
@@ -4871,7 +4871,7 @@
 								this->addThreadedRebaseInfo(state, sect, atom, fixupWithTarget, fixupWithMinusTarget, fixupWithStore,
 															target, minusTarget, targetAddend, minusTargetAddend);
 							}
-							else { 
+							else {
 								this->addClassicRelocs(state, sect, atom, fixupWithTarget, fixupWithMinusTarget, fixupWithStore,
 													target, minusTarget, targetAddend, minusTargetAddend);
 							}
@@ -5074,7 +5074,7 @@
 	_chainedFixupBinds.setMaxRebase(maxRebaseAddress);
 }
 
-void OutputFile::noteTextReloc(const ld::Atom* atom, const ld::Atom* target) 
+void OutputFile::noteTextReloc(const ld::Atom* atom, const ld::Atom* target)
 {
 	if ( (atom->contentType() == ld::Atom::typeStub) || (atom->contentType() == ld::Atom::typeStubHelper) ) {
 		// silently let stubs (synthesized by linker) use text relocs
@@ -5082,8 +5082,8 @@
 	else if ( _options.allowTextRelocs() ) {
 		if ( _options.warnAboutTextRelocs() )
 			warning("text reloc in %s to %s", atom->name(), target->name());
-	} 
-	else if ( _options.positionIndependentExecutable() && (_options.outputKind() == Options::kDynamicExecutable) 
+	}
+	else if ( _options.positionIndependentExecutable() && (_options.outputKind() == Options::kDynamicExecutable)
 			 && _options.platforms().minOS(ld::version2010Fall)) {
 		if ( ! this->pieDisabled ) {
 			switch ( _options.architecture()) {
@@ -5098,8 +5098,8 @@
 #endif
             default:
 				warning("PIE disabled. Absolute addressing (perhaps -mdynamic-no-pic) not allowed in code signed PIE, "
-				"but used in %s from %s. " 
-				"To fix this warning, don't compile with -mdynamic-no-pic or link with -Wl,-no_pie", 
+				"but used in %s from %s. "
+				"To fix this warning, don't compile with -mdynamic-no-pic or link with -Wl,-no_pie",
 				atom->name(), atom->safeFilePath());
 			}
 		}
@@ -5116,9 +5116,9 @@
 	}
 }
 
-void OutputFile::addDyldInfo(ld::Internal& state,  ld::Internal::FinalSection* sect, const ld::Atom* atom,  
+void OutputFile::addDyldInfo(ld::Internal& state,  ld::Internal::FinalSection* sect, const ld::Atom* atom,
 								ld::Fixup* fixupWithTarget, ld::Fixup* fixupWithMinusTarget, ld::Fixup* fixupWithStore,
-								const ld::Atom* target, const ld::Atom* minusTarget, 
+								const ld::Atom* target, const ld::Atom* minusTarget,
 								uint64_t targetAddend, uint64_t minusTargetAddend)
 {
 	if ( sect->isSectionHidden() )
@@ -5170,7 +5170,7 @@
 			// This is a compile time constant and could have been optimized away by compiler
 			return;
 		}
-		
+
 		// check if target of pointer-diff is global and weak
 		if ( (target->scope() == ld::Atom::scopeGlobal) && (target->combine() == ld::Atom::combineByName) && (target->definition() == ld::Atom::definitionRegular) ) {
 			if ( (atom->section().type() == ld::Section::typeCFI)
@@ -5192,9 +5192,9 @@
 	if ( (atom == target) && !_options.outputSlidable() )
 		return;
 
-	// cluster has no target, so needs no rebasing or binding	
+	// cluster has no target, so needs no rebasing or binding
 	if ( target == NULL )
-		return; 
+		return;
 
 	const uint64_t pointerSize = (_options.architecture() & CPU_ARCH_ABI64) ? 8 : 4;
 	bool inReadOnlySeg = ((_options.initialSegProtection(sect->segmentName()) & VM_PROT_WRITE) == 0);
@@ -5227,7 +5227,7 @@
 				needsWeakBinding = true;
 			}
 			else {
-				// weak def in this linkage unit.  
+				// weak def in this linkage unit.
 				// just rebase, plus have weak binding info in case of collision
 				// this will be done by other cluster on lazy pointer atom
 			}
@@ -5252,13 +5252,13 @@
 					throwf("illegal data reference to %s in lazy loaded dylib %s", target->name(), dylib->path());
 				if ( target->contentType() == ld::Atom::typeTLV ) {
 					if ( sect->type() != ld::Section::typeTLVPointers )
-						throwf("illegal data reference in %s to thread local variable %s in dylib %s", 
+						throwf("illegal data reference in %s to thread local variable %s in dylib %s",
 								atom->name(), target->name(), dylib->path());
 				}
-				if ( inReadOnlySeg ) 
+				if ( inReadOnlySeg )
 					type = BIND_TYPE_TEXT_ABSOLUTE32;
 				needsBinding = true;
-				if ( target->combine() == ld::Atom::combineByName ) 
+				if ( target->combine() == ld::Atom::combineByName )
 					needsWeakBinding = true;
 				break;
 			case ld::Atom::definitionRegular:
@@ -5268,7 +5268,7 @@
 					needsRebase = true;
 				}
 				// references to internal symbol never need binding
-				if ( target->scope() != ld::Atom::scopeGlobal ) 
+				if ( target->scope() != ld::Atom::scopeGlobal )
 					break;
 				// reference to global weak def needs weak binding
 				if ( (target->combine() == ld::Atom::combineByName) && (target->definition() == ld::Atom::definitionRegular) )
@@ -5300,7 +5300,7 @@
 				break;
 		}
 	}
-	
+
 	// <rdar://problem/13828711> if target is an import alias, use base of alias
 	if ( target->isAlias() && (target->definition() == ld::Atom::definitionProxy) ) {
 		for (ld::Fixup::iterator fit = target->fixupsBegin(), end=target->fixupsEnd(); fit != end; ++fit) {
@@ -5351,8 +5351,8 @@
 					uint64_t sctEnd = (sct->address+sct->size);
 					if ( (sct->address <= targetAddress) && (targetAddress < sctEnd) ) {
 						if ( (targetAddress+checkAddend) > sctEnd ) {
-							warning("data symbol %s from %s has pointer to %s + 0x%08llX. "  
-									"That large of an addend may disable %s from being put in the dyld shared cache.", 
+							warning("data symbol %s from %s has pointer to %s + 0x%08lX. "
+									"That large of an addend may disable %s from being put in the dyld shared cache.",
 									atom->name(), atom->safeFilePath(), target->name(), addend, _options.installPath() );
 						}
 					}
@@ -5362,11 +5362,11 @@
 		if ( ((address & (pointerSize-1)) != 0) && (rebaseType == REBASE_TYPE_POINTER) ) {
 			switch ( _options.unalignedPointerTreatment() ) {
 				case Options::kUnalignedPointerError:
-					throwf("pointer not aligned at address 0x%llX (%s + %lld from %s)",
+					throwf("pointer not aligned at address 0x%lX (%s + %ld from %s)",
 							address, atom->name(), (address - atom->finalAddress()), atom->safeFilePath());
 					break;
 				case Options::kUnalignedPointerWarning:
-					warning("pointer not aligned at address 0x%llX (%s + %lld from %s)",
+					warning("pointer not aligned at address 0x%lX (%s + %ld from %s)",
 							address, atom->name(), (address - atom->finalAddress()), atom->safeFilePath());
 					break;
 				case Options::kUnalignedPointerIgnore:
@@ -5386,11 +5386,11 @@
 		if ( ((address & (pointerSize-1)) != 0) && (type == BIND_TYPE_POINTER) ) {
 			switch ( _options.unalignedPointerTreatment() ) {
 				case Options::kUnalignedPointerError:
-					throwf("pointer not aligned at address 0x%llX (%s + %lld from %s)",
+					throwf("pointer not aligned at address 0x%lX (%s + %ld from %s)",
 							address, atom->name(), (address - atom->finalAddress()), atom->safeFilePath());
 					break;
 				case Options::kUnalignedPointerWarning:
-					warning("pointer not aligned at address 0x%llX (%s + %lld from %s)",
+					warning("pointer not aligned at address 0x%lX (%s + %ld from %s)",
 							address, atom->name(), (address - atom->finalAddress()), atom->safeFilePath());
 					break;
 				case Options::kUnalignedPointerIgnore:
@@ -5577,7 +5577,7 @@
 			sect->hasLocalRelocs = true;  // so dyld knows to change permissions on __TEXT segment
 		}
 		if ( ((address & (minAlignment-1)) != 0) ) {
-			throwf("pointer not aligned to at least 4-bytes at address 0x%llX (%s + %lld from %s)",
+			throwf("pointer not aligned to at least 4-bytes at address 0x%lX (%s + %ld from %s)",
 				   address, atom->name(), (address - atom->finalAddress()), atom->safeFilePath());
 		}
 		_rebaseInfo.push_back(RebaseInfo(rebaseType, address));
@@ -5585,14 +5585,14 @@
 }
 
 
-void OutputFile::addClassicRelocs(ld::Internal& state, ld::Internal::FinalSection* sect, const ld::Atom* atom, 
+void OutputFile::addClassicRelocs(ld::Internal& state, ld::Internal::FinalSection* sect, const ld::Atom* atom,
 								ld::Fixup* fixupWithTarget, ld::Fixup* fixupWithMinusTarget, ld::Fixup* fixupWithStore,
-								const ld::Atom* target, const ld::Atom* minusTarget, 
+								const ld::Atom* target, const ld::Atom* minusTarget,
 								uint64_t targetAddend, uint64_t minusTargetAddend)
 {
 	if ( sect->isSectionHidden() )
 		return;
-	
+
 	// non-lazy-pointer section is encoded in indirect symbol table - not using relocations
 	if ( sect->type() == ld::Section::typeNonLazyPointer ) {
 		// except kexts and static pie which *do* use relocations
@@ -5609,7 +5609,7 @@
 				return;
 		}
 	}
-	
+
 	// no need to rebase or bind PCRel stores
 	if ( this->isPcRelStore(fixupWithStore) ) {
 		// as long as target is in same linkage unit
@@ -5640,9 +5640,9 @@
 		return;
 	}
 
-	// cluster has no target, so needs no rebasing or binding	
+	// cluster has no target, so needs no rebasing or binding
 	if ( target == NULL )
-		return; 
+		return;
 
 	assert(_localRelocsAtom != NULL);
 	uint64_t relocAddress =  atom->finalAddress() + fixupWithTarget->offsetInAtom - _localRelocsAtom->relocBaseAddress(state);
@@ -5666,7 +5666,7 @@
 #endif
 		case ld::Fixup::kindStoreTargetAddressBigEndian32:
 		case ld::Fixup::kindStoreTargetAddressBigEndian64:
-			// is pointer 
+			// is pointer
 			switch ( target->definition() ) {
 				case ld::Atom::definitionProxy:
 					needsExternReloc = true;
@@ -5674,22 +5674,22 @@
 				case ld::Atom::definitionRegular:
 				case ld::Atom::definitionTentative:
 					// only slideable images need local relocs
-					if ( _options.outputSlidable() ) 
+					if ( _options.outputSlidable() )
 						needsLocalReloc = true;
 					// references to internal symbol never need binding
-					if ( target->scope() != ld::Atom::scopeGlobal ) 
+					if ( target->scope() != ld::Atom::scopeGlobal )
 						break;
 					// reference to global weak def needs weak binding in dynamic images
-					if ( (target->combine() == ld::Atom::combineByName) 
+					if ( (target->combine() == ld::Atom::combineByName)
 						&& (target->definition() == ld::Atom::definitionRegular)
 						&& (_options.outputKind() != Options::kStaticExecutable)
-						&& (_options.outputKind() != Options::kPreload) 
+						&& (_options.outputKind() != Options::kPreload)
 						&& (atom != target) ) {
 						needsExternReloc = true;
 					}
 					else if ( _options.outputKind() == Options::kDynamicExecutable ) {
 						// in main executables, the only way regular symbols are indirected is if -interposable is used
-						if ( _options.interposable(target->name()) ) 
+						if ( _options.interposable(target->name()) )
 							needsExternReloc = true;
 					}
 					else {
@@ -5739,14 +5739,14 @@
 				}
 			}
 			break;
-		
+
 		case ld::Fixup::kindStoreARMLow16:
 		case ld::Fixup::kindStoreThumbLow16:
 			// no way to encode rebasing of binding for these instructions
 			if ( _options.outputSlidable() || (target->definition() == ld::Atom::definitionProxy) )
 				throwf("no supported runtime lo16 relocation in %s from %s to %s", atom->name(), atom->safeFilePath(), target->name());
 			break;
-				
+
 		case ld::Fixup::kindStoreARMHigh16:
 		case ld::Fixup::kindStoreThumbHigh16:
 			// no way to encode rebasing of binding for these instructions
@@ -5786,8 +5786,8 @@
 		// x86_64 and ARM64 use external relocations for everthing that has a symbol
 		return ( target->symbolTableInclusion() != ld::Atom::symbolTableNotIn );
 	}
-	
-	// <rdar://problem/9513487> support arm branch interworking in -r mode 
+
+	// <rdar://problem/9513487> support arm branch interworking in -r mode
 	if ( (_options.architecture() == CPU_TYPE_ARM) && (_options.outputKind() == Options::kObjectFile) ) {
 		if ( atom->isThumb() != target->isThumb() ) {
 			switch ( fixupWithTarget->kind ) {
@@ -5801,9 +5801,9 @@
 			}
 		}
 	}
-	
+
 	if ( (_options.architecture() == CPU_TYPE_I386) && (_options.outputKind() == Options::kObjectFile) ) {
-		if ( target->contentType() == ld::Atom::typeTLV ) 
+		if ( target->contentType() == ld::Atom::typeTLV )
 			return true;
 	}
 
@@ -5841,35 +5841,35 @@
 
 
 
-void OutputFile::addSectionRelocs(ld::Internal& state, ld::Internal::FinalSection* sect, const ld::Atom* atom, 
-								ld::Fixup* fixupWithTarget, ld::Fixup* fixupWithMinusTarget,  
+void OutputFile::addSectionRelocs(ld::Internal& state, ld::Internal::FinalSection* sect, const ld::Atom* atom,
+								ld::Fixup* fixupWithTarget, ld::Fixup* fixupWithMinusTarget,
 								ld::Fixup* fixupWithAddend, ld::Fixup* fixupWithStore,
 #if SUPPORT_ARCH_arm64e
 								  ld::Fixup* fixupWithAuthData,
 #endif
-								const ld::Atom* target, const ld::Atom* minusTarget, 
+								const ld::Atom* target, const ld::Atom* minusTarget,
 								uint64_t targetAddend, uint64_t minusTargetAddend)
 {
 	if ( sect->isSectionHidden() )
 		return;
-	
+
 	// in -r mode where there will be no labels on __eh_frame section, there is no need for relocations
 	if ( (sect->type() == ld::Section::typeCFI) && _options.removeEHLabels() )
 		return;
-		
+
 	// non-lazy-pointer section is encoded in indirect symbol table - not using relocations
-	if ( sect->type() == ld::Section::typeNonLazyPointer ) 
+	if ( sect->type() == ld::Section::typeNonLazyPointer )
 		return;
 
 	// tentative defs don't have any relocations
-	if ( sect->type() == ld::Section::typeTentativeDefs ) 
+	if ( sect->type() == ld::Section::typeTentativeDefs )
 		return;
 
 	assert(target != NULL);
 	assert(fixupWithTarget != NULL);
 	bool targetUsesExternalReloc = this->useExternalSectionReloc(atom, target, fixupWithTarget);
 	bool minusTargetUsesExternalReloc = (minusTarget != NULL) && this->useExternalSectionReloc(atom, minusTarget, fixupWithMinusTarget);
-	
+
 	// in x86_64 and arm64 .o files an external reloc means the content contains just the addend
 	if ( (_options.architecture() == CPU_TYPE_X86_64)
 	  || (_options.architecture() == CPU_TYPE_ARM64)
@@ -5885,12 +5885,12 @@
 	}
 	else {
 		// for other archs, content is addend only with (non pc-rel) pointers
-		// pc-rel instructions are funny. If the target is _foo+8 and _foo is 
+		// pc-rel instructions are funny. If the target is _foo+8 and _foo is
 		// external, then the pc-rel instruction *evalutates* to the address 8.
 		if ( targetUsesExternalReloc ) {
 			// TLV support for i386 acts like RIP relative addressing
-			// The addend is the offset from the PICBase to the end of the instruction 
-			if ( (_options.architecture() == CPU_TYPE_I386) 
+			// The addend is the offset from the PICBase to the end of the instruction
+			if ( (_options.architecture() == CPU_TYPE_I386)
 				 && (_options.outputKind() == Options::kObjectFile)
 			     && (fixupWithStore->kind == ld::Fixup::kindStoreX86PCRel32TLVLoad) ) {
 				fixupWithTarget->contentAddendOnly = true;
@@ -5906,9 +5906,9 @@
 			}
 		}
 	}
-	
+
 	if ( fixupWithStore != NULL ) {
-		_sectionsRelocationsAtom->addSectionReloc(sect, fixupWithStore->kind, atom, fixupWithStore->offsetInAtom, 
+		_sectionsRelocationsAtom->addSectionReloc(sect, fixupWithStore->kind, atom, fixupWithStore->offsetInAtom,
 													targetUsesExternalReloc, minusTargetUsesExternalReloc,
 #if SUPPORT_ARCH_arm64e
 												  fixupWithAuthData,
@@ -5922,7 +5922,7 @@
 {
 	if ( !_options.sharedRegionEligible() )
 		return;
-		
+
 	for (std::vector<ld::Internal::FinalSection*>::iterator sit = state.sections.begin(); sit != state.sections.end(); ++sit) {
 		ld::Internal::FinalSection* sect = *sit;
 		if ( sect->isSectionHidden() )
@@ -5939,12 +5939,12 @@
             bool thumbTarget;
 			bool hadSubtract = false;
 			for (ld::Fixup::iterator fit = atom->fixupsBegin(), end=atom->fixupsEnd(); fit != end; ++fit) {
-				if ( fit->firstInCluster() ) 
+				if ( fit->firstInCluster() )
 					target = NULL;
 				if ( this->setsTarget(*fit) ) {
 					accumulator = addressOf(state, fit, &target);
 					thumbTarget = targetIsThumb(state, fit);
-					if ( thumbTarget ) 
+					if ( thumbTarget )
 						accumulator |= 1;
 				}
 				switch ( fit->kind ) {
@@ -5983,7 +5983,7 @@
 					case ld::Fixup::kindStoreTargetAddressX86PCRel32TLVLoad:
 					case ld::Fixup::kindStoreTargetAddressX86PCRel32TLVLoadNowLEA:
                     case ld::Fixup::kindStoreARMLow16:
-                    case ld::Fixup::kindStoreThumbLow16: 
+                    case ld::Fixup::kindStoreThumbLow16:
 #if SUPPORT_ARCH_arm64
 					case ld::Fixup::kindStoreARM64Page21:
 					case ld::Fixup::kindStoreARM64GOTLoadPage21:
@@ -5998,12 +5998,12 @@
 					case ld::Fixup::kindStoreARM64PCRelToGOT:
 #endif
 						assert(target != NULL);
-						if ( strcmp(sect->segmentName(), target->section().segmentName()) != 0 ) {	
+						if ( strcmp(sect->segmentName(), target->section().segmentName()) != 0 ) {
 							_splitSegInfos.push_back(SplitSegInfoEntry(atom->finalAddress()+fit->offsetInAtom,fit->kind));
 						}
 						break;
-                    case ld::Fixup::kindStoreARMHigh16: 
-                    case ld::Fixup::kindStoreThumbHigh16: 
+                    case ld::Fixup::kindStoreARMHigh16:
+                    case ld::Fixup::kindStoreThumbHigh16:
 						assert(target != NULL);
 						if ( strcmp(sect->segmentName(), target->section().segmentName()) != 0 ) {
                             // hi16 needs to know upper 4-bits of low16 to compute carry
@@ -6036,7 +6036,7 @@
 	static const bool log = false;
 	if ( !_options.sharedRegionEligible() )
 		return;
-	
+
 	for (std::vector<ld::Internal::FinalSection*>::iterator sit = state.sections.begin(); sit != state.sections.end(); ++sit) {
 		ld::Internal::FinalSection* sect = *sit;
 		if ( sect->isSectionHidden() )
@@ -6044,7 +6044,7 @@
 		if ( (_options.outputKind() == Options::kDynamicLibrary) && (strcmp(sect->sectionName(), "__interpose") == 0) && (strncmp(sect->segmentName(),"__DATA",6) == 0) )
 			warning("__interpose sections cannot be used in dylibs put in the dyld cache");
 		bool codeSection = (sect->type() == ld::Section::typeCode);
-		if (log) fprintf(stderr, "sect: %s, address=0x%llX\n", sect->sectionName(), sect->address);
+		if (log) fprintf(stderr, "sect: %s, address=0x%lX\n", sect->sectionName(), sect->address);
 		for (std::vector<const ld::Atom*>::iterator ait = sect->atoms.begin(); ait != sect->atoms.end(); ++ait) {
 			const ld::Atom* atom = *ait;
 			const ld::Atom* target = NULL;
@@ -6072,7 +6072,7 @@
 				if ( this->setsTarget(*fit) ) {
 					accumulator = addressAndTarget(state, fit, &target);
 					thumbTarget = targetIsThumb(state, fit);
-					if ( thumbTarget ) 
+					if ( thumbTarget )
 						accumulator |= 1;
 					toOffset = accumulator - state.atomToSection[target]->address;
 					if ( target->definition() != ld::Atom::definitionProxy ) {
@@ -6213,7 +6213,7 @@
 						if ( !hadSubtract && addend )
 							toOffset += addend;
 						assert(toSectionIndex != 255);
-						if (log) fprintf(stderr, "from (%d.%s + 0x%llX) to (%d.%s + 0x%llX), kind=%d, atomAddr=0x%llX, sectAddr=0x%llx\n",
+						if (log) fprintf(stderr, "from (%d.%s + 0x%lX) to (%d.%s + 0x%lX), kind=%d, atomAddr=0x%lX, sectAddr=0x%lx\n",
 										fromSectionIndex, sect->sectionName(), fromOffset, toSectionIndex, state.atomToSection[target]->sectionName(),
 										toOffset, kind, atom->finalAddress(), sect->address);
 						_splitSegV2Infos.push_back(SplitSegInfoV2Entry(fromSectionIndex, fromOffset, toSectionIndex, toOffset, kind));
@@ -6228,7 +6228,7 @@
 void OutputFile::writeMapFile(ld::Internal& state)
 {
 	if ( _options.generatedMapPath() != NULL ) {
-		FILE* mapFile = fopen(_options.generatedMapPath(), "w"); 
+		FILE* mapFile = fopen(_options.generatedMapPath(), "w");
 		if ( mapFile != NULL ) {
 			// write output path
 			fprintf(mapFile, "# Path: %s\n", _options.outputFilePath());
@@ -6247,7 +6247,7 @@
 			std::map<const ld::File*, uint32_t> readerToFileOrdinal;
 			for (std::vector<ld::Internal::FinalSection*>::iterator sit = state.sections.begin(); sit != state.sections.end(); ++sit) {
 				ld::Internal::FinalSection* sect = *sit;
-				if ( sect->isSectionHidden() ) 
+				if ( sect->isSectionHidden() )
 					continue;
 				for (std::vector<const ld::Atom*>::iterator ait = sect->atoms.begin(); ait != sect->atoms.end(); ++ait) {
 					const ld::Atom* atom = *ait;
@@ -6282,20 +6282,20 @@
 			}
 			// write table of sections
 			fprintf(mapFile, "# Sections:\n");
-			fprintf(mapFile, "# Address\tSize    \tSegment\tSection\n"); 
+			fprintf(mapFile, "# Address\tSize    \tSegment\tSection\n");
 			for (std::vector<ld::Internal::FinalSection*>::iterator sit = state.sections.begin(); sit != state.sections.end(); ++sit) {
 				ld::Internal::FinalSection* sect = *sit;
-				if ( sect->isSectionHidden() ) 
+				if ( sect->isSectionHidden() )
 					continue;
-				fprintf(mapFile, "0x%08llX\t0x%08llX\t%s\t%s\n", sect->address, sect->size, 
+				fprintf(mapFile, "0x%08lX\t0x%08lX\t%s\t%s\n", sect->address, sect->size,
 							sect->segmentName(), sect->sectionName());
 			}
 			// write table of symbols
 			fprintf(mapFile, "# Symbols:\n");
-			fprintf(mapFile, "# Address\tSize    \tFile  Name\n"); 
+			fprintf(mapFile, "# Address\tSize    \tFile  Name\n");
 			for (std::vector<ld::Internal::FinalSection*>::iterator sit = state.sections.begin(); sit != state.sections.end(); ++sit) {
 				ld::Internal::FinalSection* sect = *sit;
-				if ( sect->isSectionHidden() ) 
+				if ( sect->isSectionHidden() )
 					continue;
 				//bool isCstring = (sect->type() == ld::Section::typeCString);
 				for (std::vector<const ld::Atom*>::iterator ait = sect->atoms.begin(); ait != sect->atoms.end(); ++ait) {
@@ -6352,7 +6352,7 @@
 						}
 						name = buffer;
 					}
-					fprintf(mapFile, "0x%08llX\t0x%08llX\t[%3u] %s\n", atom->finalAddress(), atom->size(), 
+					fprintf(mapFile, "0x%08lX\t0x%08lX\t[%3u] %s\n", atom->finalAddress(), atom->size(),
 							readerToFileOrdinal[atom->originalFile()], name);
 				}
 			}
@@ -6386,7 +6386,7 @@
 						buffer[4095] = '\0';
 						name = buffer;
 					}
-					fprintf(mapFile, "<<dead>> \t0x%08llX\t[%3u] %s\n",  atom->size(),
+					fprintf(mapFile, "<<dead>> \t0x%08lX\t[%3u] %s\n",  atom->size(),
 							readerToFileOrdinal[atom->originalFile()], name);
 				}
 			}
@@ -6429,27 +6429,27 @@
 		std::vector<const ld::dylib::File*> weakList;
 
 		for (const ld::dylib::File* dylib :  _dylibsToLoad) {
-			
+
 			if (dylib->willBeUpwardDylib()) {
-			
+
 				upwardList.push_back(dylib);
 			} else if (dylib->willBeReExported()) {
-			 
+
 				reexportList.push_back(dylib);
 			} else if (dylib->forcedWeakLinked() || dylib->allSymbolsAreWeakImported()) {
-			
+
 				weakList.push_back(dylib);
 				dynamicList.push_back(dylib);
 			} else {
-			
+
 				dynamicList.push_back(dylib);
 			}
 		}
-		
+
 		/*
 		 * Build the JSON entry.
 		 */
-		
+
 		std::string	jsonEntry = "{";
 
 		jsonEntry += "\"uuid\":\"" + std::string(uuidString) + "\",";
@@ -6471,7 +6471,7 @@
 			}
 			jsonEntry += "]";
 		}
-		
+
 		if (upwardList.size() > 0) {
 			jsonEntry += ",\"upward-dynamic\":[";
 			for (const ld::dylib::File* dylib :  upwardList) {
@@ -6482,7 +6482,7 @@
 			}
 			jsonEntry += "]";
 		}
-		
+
 		if (reexportList.size() > 0) {
 			jsonEntry += ",\"re-exports\":[";
 			for (const ld::dylib::File* dylib :  reexportList) {
@@ -6493,7 +6493,7 @@
 			}
 			jsonEntry += "]";
 		}
-		
+
 		if (weakList.size() > 0) {
 			jsonEntry += ",\"weak\":[";
 			for (const ld::dylib::File* dylib :  weakList) {
@@ -6504,7 +6504,7 @@
 			}
 			jsonEntry += "]";
 		}
-		
+
 		if (state.archivePaths.size() > 0) {
 			jsonEntry += ",\"archives\":[";
 			for (const std::string& archivePath : state.archivePaths) {
@@ -6527,12 +6527,12 @@
 		}
 
 		jsonEntry += "}\n";
-		
+
 		// Write the JSON entry to the trace file.
 		_options.writeToTraceFile(jsonEntry.c_str(), jsonEntry.size());
 	}
 }
-	
+
 // used to sort atoms with debug notes
 class DebugNoteSorter
 {
@@ -6614,7 +6614,7 @@
 			if ( atom->symbolTableInclusion() == ld::Atom::symbolTableInWithRandomAutoStripLabel )
 				continue;
 			// no stabs for absolute symbols
-			if ( atom->definition() == ld::Atom::definitionAbsolute ) 
+			if ( atom->definition() == ld::Atom::definitionAbsolute )
 				continue;
 			// no stabs for .eh atoms
 			if ( atom->contentType() == ld::Atom::typeCFI )
@@ -6655,7 +6655,7 @@
 			}
 		}
 	}
-	
+
 	// sort by file ordinal then atom ordinal
 	std::sort(atomsNeedingDebugNotes.begin(), atomsNeedingDebugNotes.end(), DebugNoteSorter());
 
@@ -6680,7 +6680,7 @@
 		astStab.string	= path;
 		state.stabs.push_back(astStab);
 	}
-	
+
 	// synthesize "debug notes" and add them to master stabs vector
 	const char* dirPath = NULL;
 	const char* filename = NULL;
@@ -6697,7 +6697,7 @@
 			const char* newDirPath;
 			const char* newFilename;
 			const char* lastSlash = strrchr(newPath, '/');
-			if ( lastSlash == NULL ) 
+			if ( lastSlash == NULL )
 				continue;
 			newFilename = lastSlash+1;
 			char* temp = strdup(newPath);
@@ -6739,7 +6739,7 @@
 				objStab.atom		= NULL;
 				objStab.type		= N_OSO;
 				// <rdar://problem/6337329> linker should put cpusubtype in n_sect field of nlist entry for N_OSO debug note entries
-				objStab.other		= atomFile->cpuSubType(); 
+				objStab.other		= atomFile->cpuSubType();
 				objStab.desc		= 1;
 				if ( atomObjFile != NULL ) {
 					objStab.string	= canonicalOSOPath(atomObjFile->debugInfoPath());
@@ -6985,6 +6985,6 @@
 
 
 
-} // namespace tool 
-} // namespace ld 
+} // namespace tool
+} // namespace ld
 
diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/parsers/libunwind/DwarfParser.hpp cctools-port-format/cctools/ld64/src/ld/parsers/libunwind/DwarfParser.hpp
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/parsers/libunwind/DwarfParser.hpp	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/parsers/libunwind/DwarfParser.hpp	2020-11-26 20:24:41.362874452 -0800
@@ -21,7 +21,7 @@
  *
  * @APPLE_LICENSE_HEADER_END@
  */
- 
+
 //
 // processor specific parsing of dwarf unwind instructions
 //
@@ -46,18 +46,18 @@
 
 ///
 /// CFI_Parser does basic parsing of a CFI (Call Frame Information) records.
-/// See Dwarf Spec for details: 
+/// See Dwarf Spec for details:
 ///    http://www.linux-foundation.org/spec/booksets/LSB-Core-generic/LSB-Core-generic/ehframechpt.html
 ///
 template <typename A>
 class CFI_Parser
 {
 public:
-	typedef typename A::pint_t		pint_t;	
+	typedef typename A::pint_t		pint_t;
 
 	///
 	/// Information encoded in a CIE (Common Information Entry)
-	///  
+	///
 	struct CIE_Info {
 		pint_t		cieStart;
 		pint_t		cieLength;
@@ -72,10 +72,10 @@
 		bool		isSignalFrame;
 		bool		fdesHaveAugmentationData;
 	};
-	
+
 	///
 	/// Information about an FDE (Frame Description Entry)
-	///  
+	///
 	struct FDE_Info {
 		pint_t		fdeStart;
 		pint_t		fdeLength;
@@ -87,7 +87,7 @@
 
 	///
 	/// Used by linker when parsing __eh_frame section
-	///  
+	///
 	struct FDE_Reference {
 		pint_t		address;
 		uint32_t	offsetInFDE;
@@ -103,12 +103,12 @@
 		pint_t			cieAddress;
 		FDE_Reference	personality;
 	};
-	
-	
+
+
 	///
-	/// Information about a frame layout and registers saved determined 
+	/// Information about a frame layout and registers saved determined
 	/// by "running" the dwarf FDE "instructions"
-	///  
+	///
 	enum { kMaxRegisterNumber = 300 };
 	enum RegisterSavedWhere { kRegisterUnused, kRegisterInCFA, kRegisterOffsetFromCFA,
 							kRegisterInRegister, kRegisterAtExpression, kRegisterIsExpression } ;
@@ -117,7 +117,7 @@
 		int64_t				value;
 	};
 	struct PrologInfo {
-		uint32_t			cfaRegister;		
+		uint32_t			cfaRegister;
 		int32_t				cfaRegisterOffset;	// CFA = (cfaRegister)+cfaRegisterOffset
 		int64_t				cfaExpression;		// CFA = expression
 		uint32_t			spExtraArgSize;
@@ -140,21 +140,21 @@
 	static bool findFDE(A& addressSpace, pint_t pc, pint_t ehSectionStart, uint32_t sectionLength, pint_t fdeHint, FDE_Info* fdeInfo, CIE_Info* cieInfo);
 	static const char* decodeFDE(A& addressSpace, pint_t fdeStart, FDE_Info* fdeInfo, CIE_Info* cieInfo);
 	static bool parseFDEInstructions(A& addressSpace, const FDE_Info& fdeInfo, const CIE_Info& cieInfo, pint_t upToPC, PrologInfo* results);
-	static const char* getCFIs(A& addressSpace, pint_t ehSectionStart, uint32_t sectionLength, 
+	static const char* getCFIs(A& addressSpace, pint_t ehSectionStart, uint32_t sectionLength,
 								std::vector<FDE_Atom_Info>& fdes, std::vector<CIE_Atom_Info>& cies);
 	static uint32_t getCFICount(A& addressSpace, pint_t ehSectionStart, uint32_t sectionLength);
 
 	static const char* parseCIE(A& addressSpace, pint_t cie, CIE_Info* cieInfo);
 
 private:
-	static bool parseInstructions(A& addressSpace, pint_t instructions, pint_t instructionsEnd, const CIE_Info& cieInfo, 
+	static bool parseInstructions(A& addressSpace, pint_t instructions, pint_t instructionsEnd, const CIE_Info& cieInfo,
 								pint_t pcoffset, PrologInfoStackEntry*& rememberStack, PrologInfo* results);
 };
 
 
 ///
-/// Parse a FDE into a CIE_Info and an FDE_Info 
-///  
+/// Parse a FDE into a CIE_Info and an FDE_Info
+///
 template <typename A>
 const char* CFI_Parser<A>::decodeFDE(A& addressSpace, pint_t fdeStart, FDE_Info* fdeInfo, CIE_Info* cieInfo)
 {
@@ -166,10 +166,10 @@
 		cfiLength = addressSpace.get64(p);
 		p += 8;
 	}
-	if ( cfiLength == 0 ) 
+	if ( cfiLength == 0 )
 		return "FDE has zero length";	// end marker
 	uint32_t ciePointer = addressSpace.get32(p);
-	if ( ciePointer == 0 ) 
+	if ( ciePointer == 0 )
 		return "FDE is really a CIE";	// this is a CIE not an FDE
 	pint_t nextCFI = p + cfiLength;
 	pint_t cieStart = p-ciePointer;
@@ -208,7 +208,7 @@
 
 ///
 /// Scan an eh_frame section to find an FDE for a pc
-///  
+///
 template <typename A>
 bool CFI_Parser<A>::findFDE(A& addressSpace, pint_t pc, pint_t ehSectionStart, uint32_t sectionLength, pint_t fdeHint, FDE_Info* fdeInfo, CIE_Info* cieInfo)
 {
@@ -225,7 +225,7 @@
 			cfiLength = addressSpace.get64(p);
 			p += 8;
 		}
-		if ( cfiLength == 0 ) 
+		if ( cfiLength == 0 )
 			return false;	// end marker
 		uint32_t id = addressSpace.get32(p);
 		if ( id == 0 ) {
@@ -298,7 +298,7 @@
 
 ///
 /// Extract info from a CIE
-///  
+///
 template <typename A>
 const char* CFI_Parser<A>::parseCIE(A& addressSpace, pint_t cie, CIE_Info* cieInfo)
 {
@@ -323,10 +323,10 @@
 		p += 8;
 		cieContentEnd = p + cieLength;
 	}
-	if ( cieLength == 0 ) 
-		return NULL;	
+	if ( cieLength == 0 )
+		return NULL;
 	// CIE ID is always 0
-	if ( addressSpace.get32(p) != 0 ) 
+	if ( addressSpace.get32(p) != 0 )
 		return "CIE ID is not zero";
 	p += 4;
 	// Version is always 1 or 3
@@ -348,7 +348,7 @@
 	// parse augmentation data based on augmentation string
 	const char* result = NULL;
 	if ( addressSpace.get8(strStart) == 'z' ) {
-		// parse augmentation data length 
+		// parse augmentation data length
 		addressSpace.getULEB128(p, cieContentEnd);
 		for (pint_t s=strStart; addressSpace.get8(s) != '\0'; ++s) {
 			switch ( addressSpace.get8(s) ) {
@@ -397,7 +397,7 @@
 			cfiLength = addressSpace.get64(p);
 			p += 8;
 		}
-		if ( cfiLength == 0 ) 
+		if ( cfiLength == 0 )
 			return count;	// end marker
 		++count;
 		p += cfiLength;
@@ -408,7 +408,7 @@
 
 
 template <typename A>
-const char* CFI_Parser<A>::getCFIs(A& addressSpace, pint_t ehSectionStart, uint32_t sectionLength, 
+const char* CFI_Parser<A>::getCFIs(A& addressSpace, pint_t ehSectionStart, uint32_t sectionLength,
 								  std::vector<FDE_Atom_Info>& fdes, std::vector<CIE_Atom_Info>& cies)
 {
 	const pint_t ehSectionEnd = ehSectionStart + sectionLength;
@@ -421,14 +421,14 @@
 			cfiLength = addressSpace.get64(p);
 			p += 8;
 		}
-		if ( cfiLength == 0 ) 
+		if ( cfiLength == 0 )
 			return NULL;	// end marker
 		uint32_t id = addressSpace.get32(p);
 		if ( id == 0 ) {
 			// is CIE
 			CIE_Info cieInfo;
 			const char* err = parseCIE(addressSpace, currentCFI, &cieInfo);
-			if ( err != NULL ) 
+			if ( err != NULL )
 				return err;
 			CIE_Atom_Info entry;
 			entry.cieAddress = currentCFI;
@@ -453,7 +453,7 @@
 				return "FDE points to CIE outside __eh_frame section";
 			CIE_Info cieInfo;
 			const char* err = parseCIE(addressSpace, cieStart, &cieInfo);
-			if ( err != NULL ) 
+			if ( err != NULL )
 				return err;
 			entry.cie.address = cieStart;
 			entry.cie.offsetInFDE = p-currentCFI;
@@ -487,11 +487,11 @@
 	return NULL; // success
 }
 
-	
+
 
 ///
 /// "run" the dwarf instructions and create the abstact PrologInfo for an FDE
-///  
+///
 template <typename A>
 bool CFI_Parser<A>::parseFDEInstructions(A& addressSpace, const FDE_Info& fdeInfo, const CIE_Info& cieInfo, pint_t upToPC, PrologInfo* results)
 {
@@ -500,16 +500,16 @@
 	PrologInfoStackEntry* rememberStack = NULL;
 
 	// parse CIE then FDE instructions
-	return parseInstructions(addressSpace, cieInfo.cieInstructions, cieInfo.cieStart+cieInfo.cieLength, 
+	return parseInstructions(addressSpace, cieInfo.cieInstructions, cieInfo.cieStart+cieInfo.cieLength,
 						cieInfo, (pint_t)(-1), rememberStack, results)
-	    && parseInstructions(addressSpace, fdeInfo.fdeInstructions, fdeInfo.fdeStart+fdeInfo.fdeLength, 
+	    && parseInstructions(addressSpace, fdeInfo.fdeInstructions, fdeInfo.fdeStart+fdeInfo.fdeLength,
 							cieInfo, upToPC-fdeInfo.pcStart, rememberStack, results);
 }
 
 
 ///
 /// "run" the dwarf instructions
-///  
+///
 template <typename A>
 bool CFI_Parser<A>::parseInstructions(A& addressSpace, pint_t instructions, pint_t instructionsEnd, const CIE_Info& cieInfo,
 									pint_t pcoffset, PrologInfoStackEntry*& rememberStack, PrologInfo* results)
@@ -518,8 +518,8 @@
 	pint_t p = instructions;
 	uint32_t codeOffset = 0;
 	PrologInfo initialState = *results;
-	if ( logDwarf ) fprintf(stderr, "parseInstructions(instructions=0x%0llX)\n", (uint64_t)instructionsEnd);
-	
+	if ( logDwarf ) fprintf(stderr, "parseInstructions(instructions=0x%0lX)\n", (uint64_t)instructionsEnd);
+
 	// see Dwarf Spec, section 6.4.2 for details on unwind opcodes
 	while ( (p < instructionsEnd) && (codeOffset < pcoffset) ) {
 		uint64_t reg;
@@ -560,11 +560,11 @@
 					fprintf(stderr, "malformed DW_CFA_offset_extended dwarf unwind, reg too big\n");
 					return false;
 				}
-				if ( results->savedRegisters[reg].location != kRegisterUnused ) 
+				if ( results->savedRegisters[reg].location != kRegisterUnused )
 					results->registerSavedMoreThanOnce = true;
 				results->savedRegisters[reg].location = kRegisterInCFA;
 				results->savedRegisters[reg].value = offset;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_offset_extended(reg=%lld, offset=%lld)\n", reg, offset);
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_offset_extended(reg=%ld, offset=%ld)\n", reg, offset);
 				break;
 			case DW_CFA_restore_extended:
 				reg = addressSpace.getULEB128(p, instructionsEnd);;
@@ -573,7 +573,7 @@
 					return false;
 				}
 				results->savedRegisters[reg] = initialState.savedRegisters[reg];
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_restore_extended(reg=%lld)\n", reg);
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_restore_extended(reg=%ld)\n", reg);
 				break;
 			case DW_CFA_undefined:
 				reg = addressSpace.getULEB128(p, instructionsEnd);
@@ -582,7 +582,7 @@
 					return false;
 				}
 				results->savedRegisters[reg].location = kRegisterUnused;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_undefined(reg=%lld)\n", reg);
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_undefined(reg=%ld)\n", reg);
 				break;
 			case DW_CFA_same_value:
 				reg = addressSpace.getULEB128(p, instructionsEnd);
@@ -597,7 +597,7 @@
 				results->savedRegisters[reg].location = kRegisterUnused;
 				// set flag to disable conversion to compact unwind
 				results->sameValueUsed = true;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_same_value(reg=%lld)\n", reg);
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_same_value(reg=%ld)\n", reg);
 				break;
 			case DW_CFA_register:
 				reg = addressSpace.getULEB128(p, instructionsEnd);
@@ -614,7 +614,7 @@
 				results->savedRegisters[reg].value = reg2;
 				// set flag to disable conversion to compact unwind
 				results->registersInOtherRegisters = true;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_register(reg=%lld, reg2=%lld)\n", reg, reg2);
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_register(reg=%ld, reg2=%ld)\n", reg, reg2);
 				break;
 			case DW_CFA_remember_state:
 				// avoid operator new, because that would be an upward dependency
@@ -650,9 +650,9 @@
 				}
 				results->cfaRegister = reg;
 				results->cfaRegisterOffset = offset;
-				if ( offset > 0x80000000 ) 
+				if ( offset > 0x80000000 )
 					results->cfaOffsetWasNegative = true;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_def_cfa(reg=%lld, offset=%lld)\n", reg, offset);
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_def_cfa(reg=%ld, offset=%ld)\n", reg, offset);
 				break;
 			case DW_CFA_def_cfa_register:
 				reg = addressSpace.getULEB128(p, instructionsEnd);
@@ -661,7 +661,7 @@
 					return false;
 				}
 				results->cfaRegister = reg;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_def_cfa_register(%lld)\n", reg);
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_def_cfa_register(%ld)\n", reg);
 				break;
 			case DW_CFA_def_cfa_offset:
 				results->cfaRegisterOffset = addressSpace.getULEB128(p, instructionsEnd);
@@ -673,7 +673,7 @@
 				results->cfaExpression = p;
 				length = addressSpace.getULEB128(p, instructionsEnd);
 				p += length;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_def_cfa_expression(expression=0x%llX, length=%llu)\n", 
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_def_cfa_expression(expression=0x%lX, length=%lu)\n",
 													results->cfaExpression, length);
 				break;
 			case DW_CFA_expression:
@@ -686,7 +686,7 @@
 				results->savedRegisters[reg].value = p;
 				length = addressSpace.getULEB128(p, instructionsEnd);
 				p += length;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_expression(reg=%lld, expression=0x%llX, length=%llu)\n", 
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_expression(reg=%ld, expression=0x%lX, length=%lu)\n",
 													reg, results->savedRegisters[reg].value, length);
 				break;
 			case DW_CFA_offset_extended_sf:
@@ -696,11 +696,11 @@
 					return false;
 				}
 				offset = addressSpace.getSLEB128(p, instructionsEnd) * cieInfo.dataAlignFactor;
-				if ( results->savedRegisters[reg].location != kRegisterUnused ) 
+				if ( results->savedRegisters[reg].location != kRegisterUnused )
 					results->registerSavedMoreThanOnce = true;
 				results->savedRegisters[reg].location = kRegisterInCFA;
 				results->savedRegisters[reg].value = offset;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_offset_extended_sf(reg=%lld, offset=%lld)\n", reg, offset);
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_offset_extended_sf(reg=%ld, offset=%ld)\n", reg, offset);
 				break;
 			case DW_CFA_def_cfa_sf:
 				reg = addressSpace.getULEB128(p, instructionsEnd);
@@ -711,7 +711,7 @@
 				}
 				results->cfaRegister = reg;
 				results->cfaRegisterOffset = offset;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_def_cfa_sf(reg=%lld, offset=%lld)\n", reg, offset);
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_def_cfa_sf(reg=%ld, offset=%ld)\n", reg, offset);
 				break;
 			case DW_CFA_def_cfa_offset_sf:
 				results->cfaRegisterOffset = addressSpace.getSLEB128(p, instructionsEnd) * cieInfo.dataAlignFactor;
@@ -723,7 +723,7 @@
 				offset = addressSpace.getULEB128(p, instructionsEnd) * cieInfo.dataAlignFactor;
 				results->savedRegisters[reg].location = kRegisterOffsetFromCFA;
 				results->savedRegisters[reg].value = offset;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_val_offset(reg=%lld, offset=%lld\n", reg, offset);
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_val_offset(reg=%ld, offset=%ld\n", reg, offset);
 				break;
 			case DW_CFA_val_offset_sf:
 				reg = addressSpace.getULEB128(p, instructionsEnd);
@@ -734,7 +734,7 @@
 				offset = addressSpace.getSLEB128(p, instructionsEnd) * cieInfo.dataAlignFactor;
 				results->savedRegisters[reg].location = kRegisterOffsetFromCFA;
 				results->savedRegisters[reg].value = offset;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_val_offset_sf(reg=%lld, offset=%lld\n", reg, offset);
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_val_offset_sf(reg=%ld, offset=%ld\n", reg, offset);
 				break;
 			case DW_CFA_val_expression:
 				reg = addressSpace.getULEB128(p, instructionsEnd);
@@ -746,13 +746,13 @@
 				results->savedRegisters[reg].value = p;
 				length = addressSpace.getULEB128(p, instructionsEnd);
 				p += length;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_val_expression(reg=%lld, expression=0x%llX, length=%lld)\n", 
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_val_expression(reg=%ld, expression=0x%lX, length=%ld)\n",
 													reg, results->savedRegisters[reg].value, length);
 				break;
 			case DW_CFA_GNU_args_size:
 				offset = addressSpace.getULEB128(p, instructionsEnd);
 				results->spExtraArgSize = offset;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_GNU_args_size(%lld)\n", offset);
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_GNU_args_size(%ld)\n", offset);
 				break;
 			case DW_CFA_GNU_negative_offset_extended:
 				reg = addressSpace.getULEB128(p, instructionsEnd);
@@ -761,11 +761,11 @@
 					return false;
 				}
 				offset = addressSpace.getULEB128(p, instructionsEnd) * cieInfo.dataAlignFactor;
-				if ( results->savedRegisters[reg].location != kRegisterUnused ) 
+				if ( results->savedRegisters[reg].location != kRegisterUnused )
 					results->registerSavedMoreThanOnce = true;
 				results->savedRegisters[reg].location = kRegisterInCFA;
 				results->savedRegisters[reg].value = -offset;
-				if ( logDwarf ) fprintf(stderr, "DW_CFA_GNU_negative_offset_extended(%lld)\n", offset);
+				if ( logDwarf ) fprintf(stderr, "DW_CFA_GNU_negative_offset_extended(%ld)\n", offset);
 				break;
 			default:
 				operand = opcode & 0x3F;
@@ -775,8 +775,8 @@
 						offset = addressSpace.getULEB128(p, instructionsEnd) * cieInfo.dataAlignFactor;
 						if ( results->savedRegisters[reg].location != kRegisterUnused ) {
 							// look for idiom of PC saved twice in CIE to mean disable compact unwind encoding
-							if ( (pcoffset == (pint_t)(-1)) 
-								&& (results->savedRegisters[reg].location == kRegisterInCFA) 
+							if ( (pcoffset == (pint_t)(-1))
+								&& (results->savedRegisters[reg].location == kRegisterInCFA)
 								&& (results->savedRegisters[reg].value == offset)  )
 								results->registerSavedTwiceInCIE = reg;
 							else
@@ -784,7 +784,7 @@
 						}
 						results->savedRegisters[reg].location = kRegisterInCFA;
 						results->savedRegisters[reg].value = offset;
-						if ( logDwarf ) fprintf(stderr, "DW_CFA_offset(reg=%d, offset=%lld)\n", operand, offset);
+						if ( logDwarf ) fprintf(stderr, "DW_CFA_offset(reg=%d, offset=%ld)\n", operand, offset);
 						break;
 					case DW_CFA_advance_loc:
 						codeOffset += operand * cieInfo.codeAlignFactor;
@@ -796,9 +796,9 @@
 						//return true; // gcc-4.5 starts the epilog with this
 						reg = operand;
 						results->savedRegisters[reg] = initialState.savedRegisters[reg];
-						if ( logDwarf ) fprintf(stderr, "DW_CFA_restore(reg=%lld)\n", reg);
+						if ( logDwarf ) fprintf(stderr, "DW_CFA_restore(reg=%ld)\n", reg);
 						break;
-					default: 
+					default:
 						if ( logDwarf ) fprintf(stderr, "unknown CFA opcode 0x%02X\n", opcode);
 						return false;
 				}
@@ -809,7 +809,7 @@
 }
 
 
-} // namespace libunwind 
+} // namespace libunwind
 
 
 #endif // __DWARF_PARSER_HPP__
diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/parsers/macho_relocatable_file.cpp cctools-port-format/cctools/ld64/src/ld/parsers/macho_relocatable_file.cpp
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/parsers/macho_relocatable_file.cpp	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/parsers/macho_relocatable_file.cpp	2020-11-26 20:27:04.490874452 -0800
@@ -1,16 +1,16 @@
-/* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*- 
+/* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*-
  *
  * Copyright (c) 2009-2010 Apple Inc. All rights reserved.
  *
  * @APPLE_LICENSE_HEADER_START@
- * 
+ *
  * This file contains Original Code and/or Modifications of Original Code
  * as defined in and that are subject to the Apple Public Source License
  * Version 2.0 (the 'License'). You may not use this file except in
  * compliance with the License. Please obtain a copy of the License at
  * http://www.opensource.apple.com/apsl/ and read it before using this
  * file.
- * 
+ *
  * The Original Code and all software distributed under the License are
  * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
  * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
@@ -18,10 +18,10 @@
  * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
  * Please see the License for the specific language governing rights and
  * limitations under the License.
- * 
+ *
  * @APPLE_LICENSE_HEADER_END@
  */
- 
+
 
 #include <stdint.h>
 #include <stdlib.h>
@@ -78,9 +78,9 @@
 												_sectionsArray(NULL), _atomsArray(NULL),
 												_sectionsArrayCount(0), _atomsArrayCount(0), _aliasAtomsArrayCount(0),
 												_debugInfoKind(ld::relocatable::File::kDebugInfoNone),
-												_dwarfTranslationUnitPath(NULL), 
-												_dwarfDebugInfoSect(NULL), _dwarfDebugAbbrevSect(NULL), 
-												_dwarfDebugLineSect(NULL), _dwarfDebugStringSect(NULL), 
+												_dwarfTranslationUnitPath(NULL),
+												_dwarfDebugInfoSect(NULL), _dwarfDebugAbbrevSect(NULL),
+												_dwarfDebugLineSect(NULL), _dwarfDebugStringSect(NULL),
 												_hasObjC(false),
 												_swiftVersion(0),
 												_swiftLanguageVersion(0),
@@ -98,9 +98,9 @@
 																					{ return false; }
 	virtual const ld::VersionSet&						platforms()	const			{ return _platforms; }
 
-	// overrides of ld::relocatable::File 
+	// overrides of ld::relocatable::File
 	virtual bool										hasObjC() const					{ return _hasObjC; }
-	virtual bool										objcHasCategoryClassPropertiesField() const 
+	virtual bool										objcHasCategoryClassPropertiesField() const
     																					{ return _objcHasCategoryClassPropertiesField; }
 	virtual uint32_t									cpuSubType() const				{ return _cpuSubType; }
 	virtual DebugInfoKind								debugInfo() const				{ return _debugInfoKind; }
@@ -114,7 +114,7 @@
 	virtual uint16_t									swiftLanguageVersion() const	{ return _swiftLanguageVersion; }
 	virtual ld::Bitcode*								getBitcode() const				{ return _bitcode.get(); }
 	virtual SourceKind									sourceKind() const				{ return _srcKind; }
-	
+
 	virtual const uint8_t*								fileContent() const				{ return _fileContent; }
 	virtual const std::vector<AstTimeAndPath>*			astFiles() const 				{ return &_astFiles; }
 
@@ -126,7 +126,7 @@
 	friend class CFISection<A>::OAS;
 
 	typedef typename A::P					P;
-	
+
 	const uint8_t*							_fileContent;
 	Section<A>**							_sectionsArray;
 	uint8_t*								_atomsArray;
@@ -179,26 +179,26 @@
 	virtual bool					dontDeadStripIfReferencesLive() { return ( (this->_machOSection != NULL) && (this->_machOSection->flags() & S_ATTR_LIVE_SUPPORT) );  }
 	virtual	Atom<A>*				findAtomByAddress(pint_t addr) { return this->findContentAtomByAddress(addr, this->_beginAtoms, this->_endAtoms); }
 	virtual bool					addFollowOnFixups() const	{ return ! _file.canScatterAtoms(); }
-	virtual uint32_t				appendAtoms(class Parser<A>& parser, uint8_t* buffer, 
-												struct Parser<A>::LabelAndCFIBreakIterator& it, 
+	virtual uint32_t				appendAtoms(class Parser<A>& parser, uint8_t* buffer,
+												struct Parser<A>::LabelAndCFIBreakIterator& it,
 												const struct Parser<A>::CFI_CU_InfoArrays&) = 0;
-	virtual uint32_t				computeAtomCount(class Parser<A>& parser, 
-														struct Parser<A>::LabelAndCFIBreakIterator& it, 
+	virtual uint32_t				computeAtomCount(class Parser<A>& parser,
+														struct Parser<A>::LabelAndCFIBreakIterator& it,
 														const struct Parser<A>::CFI_CU_InfoArrays&) = 0;
 	virtual void					makeFixups(class Parser<A>& parser, const struct Parser<A>::CFI_CU_InfoArrays&);
 	virtual bool					addRelocFixup(class Parser<A>& parser, const macho_relocation_info<P>*);
 	virtual unsigned long			contentHash(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const { return 0; }
-	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const { return false; }
 	virtual	bool					ignoreLabel(const char* label) const { return false; }
 	static const char*				makeSectionName(const macho_section<typename A::P>* s);
 
-protected:	
+protected:
 						Section(File<A>& f, const macho_section<typename A::P>* s)
 							: ld::Section(makeSegmentName(s), makeSectionName(s), sectionType(s)),
 								_file(f), _machOSection(s), _beginAtoms(NULL), _endAtoms(NULL), _hasAliases(false) { }
 						Section(File<A>& f, const char* segName, const char* sectName, ld::Section::Type t, bool hidden=false)
-							: ld::Section(segName, sectName, t, hidden), _file(f), _machOSection(NULL), 
+							: ld::Section(segName, sectName, t, hidden), _file(f), _machOSection(NULL),
 								_beginAtoms(NULL), _endAtoms(NULL), _hasAliases(false) { }
 
 
@@ -210,7 +210,7 @@
 	static bool						writable(const macho_section<typename A::P>* s);
 	static bool						exectuable(const macho_section<typename A::P>* s);
 	static ld::Section::Type		sectionType(const macho_section<typename A::P>* s);
-	
+
 	File<A>&						_file;
 	const macho_section<P>*			_machOSection;
 	class Atom<A>*					_beginAtoms;
@@ -237,7 +237,7 @@
 
 	///
 	/// ObjectFileAddressSpace is used as a template parameter to UnwindCursor for parsing
-	/// dwarf CFI information in an object file.   
+	/// dwarf CFI information in an object file.
 	///
 	class OAS
 	{
@@ -247,10 +247,10 @@
 			typedef typename A::P::E		E;
 			typedef typename A::P::uint_t	sint_t;
 
-							OAS(CFISection<A>& ehFrameSection, const uint8_t* ehFrameBuffer) : 
+							OAS(CFISection<A>& ehFrameSection, const uint8_t* ehFrameBuffer) :
 								_ehFrameSection(ehFrameSection),
-								_ehFrameContent(ehFrameBuffer), 
-								_ehFrameStartAddr(ehFrameSection.machoSection()->addr()), 
+								_ehFrameContent(ehFrameBuffer),
+								_ehFrameStartAddr(ehFrameSection.machoSection()->addr()),
 								_ehFrameEndAddr(ehFrameSection.machoSection()->addr()+ehFrameSection.machoSection()->size()) {}
 
 			uint8_t			get8(pint_t addr) { return *((uint8_t*)mappedAddress(addr)); }
@@ -263,7 +263,7 @@
 			pint_t			getEncodedP(pint_t& addr, pint_t end, uint8_t encoding);
 	private:
 		const void*			mappedAddress(pint_t addr);
-		
+
 		CFISection<A>&				_ehFrameSection;
 		const uint8_t*				_ehFrameContent;
 		pint_t						_ehFrameStartAddr;
@@ -273,7 +273,7 @@
 
 	typedef typename A::P::uint_t			pint_t;
 	typedef libunwind::CFI_Atom_Info<OAS>	CFI_Atom_Info;
-	
+
 	void				cfiParse(class Parser<A>& parser, uint8_t* buffer, CFI_Atom_Info cfiArray[], uint32_t& cfiCount, const pint_t cuStarts[], uint32_t cuCount);
 	bool				needsRelocating();
 
@@ -294,12 +294,12 @@
 	typedef typename A::P::uint_t	pint_t;
 	typedef typename A::P			P;
 	typedef typename A::P::E		E;
-					
+
 	virtual uint32_t		computeAtomCount(class Parser<A>& parser, struct Parser<A>::LabelAndCFIBreakIterator& it, const struct Parser<A>::CFI_CU_InfoArrays&) { return 0; }
 	virtual uint32_t		appendAtoms(class Parser<A>& parser, uint8_t* buffer, struct Parser<A>::LabelAndCFIBreakIterator& it, const struct Parser<A>::CFI_CU_InfoArrays&) { return 0; }
 	virtual void			makeFixups(class Parser<A>& parser, const struct Parser<A>::CFI_CU_InfoArrays&);
 	virtual bool			addFollowOnFixups() const	{ return false; }
-	
+
 	struct Info {
 		pint_t		functionStartAddress;
 		uint32_t	functionSymbolIndex;
@@ -314,10 +314,10 @@
 	uint32_t				count();
 	void					parse(class Parser<A>& parser, uint32_t cnt, Info array[]);
 	static bool				encodingMeansUseDwarf(compact_unwind_encoding_t enc);
-	
-	
+
+
 private:
-	
+
 	const char*				personalityName(class Parser<A>& parser, const macho_relocation_info<P>* reloc);
 
 	static int				infoSorter(const void* l, const void* r);
@@ -335,10 +335,10 @@
 	virtual ld::Atom::ContentType	contentType()		{ return ld::Atom::typeZeroFill; }
 	virtual bool		addFollowOnFixups() const	{ return false; }
 	virtual Atom<A>*	findAtomByAddress(typename A::P::uint_t addr) { throw "TentativeDefinitionSection::findAtomByAddress() should never be called"; }
-	virtual uint32_t	computeAtomCount(class Parser<A>& parser, struct Parser<A>::LabelAndCFIBreakIterator& it, 
+	virtual uint32_t	computeAtomCount(class Parser<A>& parser, struct Parser<A>::LabelAndCFIBreakIterator& it,
 											const struct Parser<A>::CFI_CU_InfoArrays&);
-	virtual uint32_t	appendAtoms(class Parser<A>& parser, uint8_t* buffer, 
-										struct Parser<A>::LabelAndCFIBreakIterator& it, 
+	virtual uint32_t	appendAtoms(class Parser<A>& parser, uint8_t* buffer,
+										struct Parser<A>::LabelAndCFIBreakIterator& it,
 										const struct Parser<A>::CFI_CU_InfoArrays&);
 	virtual void		makeFixups(class Parser<A>& parser, const struct Parser<A>::CFI_CU_InfoArrays&) {}
 private:
@@ -359,14 +359,14 @@
 	virtual ld::Atom::Alignment		alignmentForAddress(typename A::P::uint_t addr) { return ld::Atom::Alignment(0); }
 	virtual bool		addFollowOnFixups() const	{ return false; }
 	virtual Atom<A>*	findAtomByAddress(typename A::P::uint_t addr) { throw "AbsoluteSymbolSection::findAtomByAddress() should never be called"; }
-	virtual uint32_t	computeAtomCount(class Parser<A>& parser, struct Parser<A>::LabelAndCFIBreakIterator& it, 
+	virtual uint32_t	computeAtomCount(class Parser<A>& parser, struct Parser<A>::LabelAndCFIBreakIterator& it,
 											const struct Parser<A>::CFI_CU_InfoArrays&);
-	virtual uint32_t	appendAtoms(class Parser<A>& parser, uint8_t* buffer, 
-										struct Parser<A>::LabelAndCFIBreakIterator& it, 
+	virtual uint32_t	appendAtoms(class Parser<A>& parser, uint8_t* buffer,
+										struct Parser<A>::LabelAndCFIBreakIterator& it,
 										const struct Parser<A>::CFI_CU_InfoArrays&);
 	virtual void		makeFixups(class Parser<A>& parser, const struct Parser<A>::CFI_CU_InfoArrays&) {}
 	virtual Atom<A>*	findAbsAtomForValue(typename A::P::uint_t);
-	
+
 private:
 	typedef typename A::P::uint_t	pint_t;
 	typedef typename A::P			P;
@@ -380,10 +380,10 @@
 						SymboledSection(Parser<A>& parser, File<A>& f, const macho_section<typename A::P>* s);
 	virtual ld::Atom::ContentType	contentType() { return _type; }
 	virtual bool					dontDeadStrip();
-	virtual uint32_t	computeAtomCount(class Parser<A>& parser, struct Parser<A>::LabelAndCFIBreakIterator& it, 
+	virtual uint32_t	computeAtomCount(class Parser<A>& parser, struct Parser<A>::LabelAndCFIBreakIterator& it,
 											const struct Parser<A>::CFI_CU_InfoArrays&);
-	virtual uint32_t	appendAtoms(class Parser<A>& parser, uint8_t* buffer, 
-									struct Parser<A>::LabelAndCFIBreakIterator& it, 
+	virtual uint32_t	appendAtoms(class Parser<A>& parser, uint8_t* buffer,
+									struct Parser<A>::LabelAndCFIBreakIterator& it,
 									const struct Parser<A>::CFI_CU_InfoArrays&);
 protected:
 	typedef typename A::P::uint_t	pint_t;
@@ -420,13 +420,13 @@
 protected:
 	typedef typename A::P::uint_t	pint_t;
 	typedef typename A::P			P;
-	
+
 	virtual bool						addFollowOnFixups() const		{ return false; }
 	virtual const char*					unlabeledAtomName(Parser<A>& parser, pint_t addr) = 0;
 	virtual ld::Atom::SymbolTableInclusion	symbolTableInclusion();
 	virtual	pint_t						elementSizeAtAddress(pint_t addr) = 0;
 	virtual ld::Atom::Scope				scopeAtAddress(Parser<A>& parser, pint_t addr) { return ld::Atom::scopeLinkageUnit; }
-	virtual bool						useElementAt(Parser<A>& parser, 
+	virtual bool						useElementAt(Parser<A>& parser,
 												struct Parser<A>::LabelAndCFIBreakIterator& it, pint_t addr) = 0;
 	virtual ld::Atom::Definition		definition()					{ return ld::Atom::definitionRegular; }
 	virtual ld::Atom::Combine			combine(Parser<A>& parser, pint_t addr) = 0;
@@ -444,9 +444,9 @@
 	typedef typename A::P::uint_t	pint_t;
 	typedef typename A::P			P;
 	typedef typename A::P::E		E;
-	
-	virtual bool					useElementAt(Parser<A>& parser, 
-										struct Parser<A>::LabelAndCFIBreakIterator& it, pint_t addr) 
+
+	virtual bool					useElementAt(Parser<A>& parser,
+										struct Parser<A>::LabelAndCFIBreakIterator& it, pint_t addr)
 														{ return true; }
 };
 
@@ -466,7 +466,7 @@
 	virtual	pint_t					elementSizeAtAddress(pint_t addr)		{ return 4; }
 	virtual ld::Atom::Combine		combine(Parser<A>&, pint_t)				{ return ld::Atom::combineByNameAndContent; }
 	virtual unsigned long			contentHash(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const;
-	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const;
 	virtual	bool					ignoreLabel(const char* label) const;
 };
@@ -486,7 +486,7 @@
 	virtual	pint_t					elementSizeAtAddress(pint_t addr)		{ return 8; }
 	virtual ld::Atom::Combine		combine(Parser<A>&, pint_t)				{ return ld::Atom::combineByNameAndContent; }
 	virtual unsigned long			contentHash(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const;
-	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const;
 	virtual	bool					ignoreLabel(const char* label) const;
 };
@@ -506,7 +506,7 @@
 	virtual	pint_t					elementSizeAtAddress(pint_t addr)		{ return 16; }
 	virtual ld::Atom::Combine		combine(Parser<A>&, pint_t)				{ return ld::Atom::combineByNameAndContent; }
 	virtual unsigned long			contentHash(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const;
-	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const;
 	virtual	bool					ignoreLabel(const char* label) const;
 };
@@ -531,7 +531,7 @@
 	virtual ld::Atom::Combine		combine(Parser<A>&, pint_t);
 	virtual	bool					ignoreLabel(const char* label) const 	{ return true; }
 	virtual unsigned long			contentHash(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const;
-	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const;
 
 private:
@@ -557,7 +557,7 @@
 	virtual ld::Atom::Combine		combine(Parser<A>&, pint_t);
 	virtual	bool					ignoreLabel(const char* label) const 	{ return true; }
 	virtual unsigned long			contentHash(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const;
-	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const;
 
 private:
@@ -580,7 +580,7 @@
 	virtual ld::Atom::Combine		combine(Parser<A>&, pint_t)				{ return ld::Atom::combineByNameAndReferences; }
 	virtual	bool					ignoreLabel(const char* label) const	{ return true; }
 	virtual unsigned long			contentHash(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const;
-	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const;
 private:
 	enum ContentType { contentUTF8, contentUTF16, contentUnknown };
@@ -609,7 +609,7 @@
 	virtual	bool					ignoreLabel(const char* label) const	{ return true; }
 	virtual unsigned long			contentHash(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const
 																			{ return 0; }
-	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const { return false; }
 	virtual bool					addRelocFixup(class Parser<A>& parser, const macho_relocation_info<P>*);
 };
@@ -630,7 +630,7 @@
 	virtual ld::Atom::Combine		combine(Parser<A>&, pint_t)				{ return ld::Atom::combineByNameAndReferences; }
 	virtual	bool					ignoreLabel(const char* label) const	{ return true; }
 	virtual unsigned long			contentHash(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const;
-	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const;
 private:
 	const char*						targetClassName(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const;
@@ -672,7 +672,7 @@
 	virtual ld::Atom::Combine		combine(Parser<A>&, pint_t)				{ return ld::Atom::combineByNameAndReferences; }
 	virtual	bool					ignoreLabel(const char* label) const	{ return true; }
 	virtual unsigned long			contentHash(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const;
-	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const;
 	virtual const char*				targetCString(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const;
 };
@@ -709,11 +709,11 @@
 	virtual const char*				unlabeledAtomName(Parser<A>&, pint_t)	{ return "cstring"; }
 	virtual	pint_t					elementSizeAtAddress(pint_t addr);
 	virtual	bool					ignoreLabel(const char* label) const;
-	virtual bool					useElementAt(Parser<A>& parser, 
+	virtual bool					useElementAt(Parser<A>& parser,
 												struct Parser<A>::LabelAndCFIBreakIterator& it, pint_t addr);
 	virtual ld::Atom::Combine		combine(Parser<A>&, pint_t)				{ return ld::Atom::combineByNameAndContent; }
 	virtual unsigned long			contentHash(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const;
-	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const;
 
 };
@@ -731,7 +731,7 @@
 
 	virtual ld::Atom::Combine		combine(Parser<A>&, pint_t)				{ return ld::Atom::combineByNameAndContent; }
 	virtual unsigned long			contentHash(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) const;
-	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+	virtual bool					canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const;
 };
 
@@ -752,9 +752,9 @@
 	virtual uint64_t							objectAddress() const { return _objAddress; }
 	virtual void								copyRawContent(uint8_t buffer[]) const;
 	virtual const uint8_t*						rawContentPointer() const { return contentPointer(); }
-	virtual unsigned long						contentHash(const ld::IndirectBindingTable& ind) const 
+	virtual unsigned long						contentHash(const ld::IndirectBindingTable& ind) const
 															{ if ( _hash == 0 ) _hash = sect().contentHash(this, ind); return _hash; }
-	virtual bool								canCoalesceWith(const ld::Atom& rhs, const ld::IndirectBindingTable& ind) const 
+	virtual bool								canCoalesceWith(const ld::Atom& rhs, const ld::IndirectBindingTable& ind) const
 															{ return sect().canCoalesceWith(this, rhs, ind); }
 	virtual ld::Fixup::iterator					fixupsBegin() const	{ return &machofile()._fixups[_fixupsStartIndex]; }
 	virtual ld::Fixup::iterator					fixupsEnd()	const	{ return &machofile()._fixups[_fixupsStartIndex+_fixupsCount]; }
@@ -767,9 +767,9 @@
 private:
 
 	enum {	kFixupStartIndexBits = 32,
-			kLineInfoStartIndexBits = 32, 
+			kLineInfoStartIndexBits = 32,
 			kUnwindInfoStartIndexBits = 24,
-			kFixupCountBits = 24, 
+			kFixupCountBits = 24,
 			kLineInfoCountBits = 12,
 			kUnwindInfoCountBits = 4
 		}; // must sum to 128
@@ -784,43 +784,43 @@
 			void								setLineInfoRange(uint32_t s, uint32_t c);
 			bool								roomForMoreLineInfoCount() { return (_lineInfoCount < ((1<<kLineInfoCountBits)-1)); }
 			void								incrementLineInfoCount() { assert(roomForMoreLineInfoCount()); ++_lineInfoCount; }
-			void								incrementFixupCount() { if (_fixupsCount == ((1 << kFixupCountBits)-1)) 
+			void								incrementFixupCount() { if (_fixupsCount == ((1 << kFixupCountBits)-1))
 																			throwf("too may fixups in %s", name()); ++_fixupsCount; }
 			const uint8_t*						contentPointer() const;
 			uint32_t							fixupCount() const { return _fixupsCount; }
 			void								verifyAlignment(const macho_section<typename A::P>&) const;
-	
+
 	typedef typename A::P						P;
 	typedef typename A::P::E					E;
 	typedef typename A::P::uint_t				pint_t;
 												// constuct via all attributes
-												Atom(Section<A>& sct, const char* nm, pint_t addr, uint64_t sz, 
-													ld::Atom::Definition d, ld::Atom::Combine c, ld::Atom::Scope s, 
-													ld::Atom::ContentType ct, ld::Atom::SymbolTableInclusion i, 
-													bool dds, bool thumb, bool al, ld::Atom::Alignment a) 
-														: ld::Atom((ld::Section&)sct, d, c, s, ct, i, dds, thumb, al, a), 
-															_size(sz), _objAddress(addr), _name(nm), _hash(0), 
+												Atom(Section<A>& sct, const char* nm, pint_t addr, uint64_t sz,
+													ld::Atom::Definition d, ld::Atom::Combine c, ld::Atom::Scope s,
+													ld::Atom::ContentType ct, ld::Atom::SymbolTableInclusion i,
+													bool dds, bool thumb, bool al, ld::Atom::Alignment a)
+														: ld::Atom((ld::Section&)sct, d, c, s, ct, i, dds, thumb, al, a),
+															_size(sz), _objAddress(addr), _name(nm), _hash(0),
 															_fixupsStartIndex(0), _lineInfoStartIndex(0),
-															_unwindInfoStartIndex(0), _fixupsCount(0),  
+															_unwindInfoStartIndex(0), _fixupsCount(0),
 															_lineInfoCount(0), _unwindInfoCount(0) { }
 												// construct via symbol table entry
-												Atom(Section<A>& sct, Parser<A>& parser, const macho_nlist<P>& sym, 
+												Atom(Section<A>& sct, Parser<A>& parser, const macho_nlist<P>& sym,
 																uint64_t sz, bool alias=false)
-														: ld::Atom((ld::Section&)sct, parser.definitionFromSymbol(sym), 
+														: ld::Atom((ld::Section&)sct, parser.definitionFromSymbol(sym),
 																parser.combineFromSymbol(sym), parser.scopeFromSymbol(sym),
-																parser.resolverFromSymbol(sym) ? ld::Atom::typeResolver : sct.contentType(), 
-																parser.inclusionFromSymbol(sym), 
+																parser.resolverFromSymbol(sym) ? ld::Atom::typeResolver : sct.contentType(),
+																parser.inclusionFromSymbol(sym),
 																(parser.dontDeadStripFromSymbol(sym) && !sct.dontDeadStripIfReferencesLive()) || sct.dontDeadStrip(),
-																parser.isThumbFromSymbol(sym), alias, 
+																parser.isThumbFromSymbol(sym), alias,
 																sct.alignmentForAddress(sym.n_value()),
 																parser.coldFromSymbol(sym)),
-															_size(sz), _objAddress(sym.n_value()), 
-															_name(parser.nameFromSymbol(sym)), _hash(0), 
+															_size(sz), _objAddress(sym.n_value()),
+															_name(parser.nameFromSymbol(sym)), _hash(0),
 															_fixupsStartIndex(0), _lineInfoStartIndex(0),
-															_unwindInfoStartIndex(0), _fixupsCount(0),  
-															_lineInfoCount(0), _unwindInfoCount(0) { 
+															_unwindInfoStartIndex(0), _fixupsCount(0),
+															_lineInfoCount(0), _unwindInfoCount(0) {
 																// <rdar://problem/6783167> support auto-hidden weak symbols
-																if ( _scope == ld::Atom::scopeGlobal && 
+																if ( _scope == ld::Atom::scopeGlobal &&
 																		(sym.n_desc() & (N_WEAK_DEF|N_WEAK_REF)) == (N_WEAK_DEF|N_WEAK_REF) )
 																	this->setAutoHide();
 																this->verifyAlignment(*sct.machoSection());
@@ -833,19 +833,19 @@
 	friend class Section<A>;
 	friend class CStringSection<A>;
 	friend class AbsoluteSymbolSection<A>;
-	
+
 	pint_t										_size;
 	pint_t										_objAddress;
 	const char*									_name;
 	mutable unsigned long						_hash;
 
 	uint64_t									_fixupsStartIndex		: kFixupStartIndexBits,
-												_lineInfoStartIndex		: kLineInfoStartIndexBits,			
+												_lineInfoStartIndex		: kLineInfoStartIndexBits,
 												_unwindInfoStartIndex	: kUnwindInfoStartIndexBits,
 												_fixupsCount			: kFixupCountBits,
 												_lineInfoCount			: kLineInfoCountBits,
 												_unwindInfoCount		: kUnwindInfoCountBits;
-												
+
 	static std::map<const ld::Atom*, const ld::File*> _s_fileOverride;
 };
 
@@ -863,49 +863,49 @@
 	std::map<const ld::Atom*, const ld::File*>::iterator pos = _s_fileOverride.find(this);
 	if ( pos != _s_fileOverride.end() )
 		return pos->second;
-		
+
 	return &sect().file();
 }
 
 template <typename A>
 void Atom<A>::setFixupsRange(uint32_t startIndex, uint32_t count)
-{ 
-	if ( count >= (1 << kFixupCountBits) ) 
+{
+	if ( count >= (1 << kFixupCountBits) )
 		throwf("too many fixups in function %s", this->name());
-	if ( startIndex >= (1 << kFixupStartIndexBits) ) 
+	if ( startIndex >= (1 << kFixupStartIndexBits) )
 		throwf("too many fixups in file");
 	assert(((startIndex+count) <= sect().file()._fixups.size()) && "fixup index out of range");
-	_fixupsStartIndex = startIndex; 
-	_fixupsCount = count; 
+	_fixupsStartIndex = startIndex;
+	_fixupsCount = count;
 }
 
 template <typename A>
 void Atom<A>::setUnwindInfoRange(uint32_t startIndex, uint32_t count)
 {
-	if ( count >= (1 << kUnwindInfoCountBits) ) 
+	if ( count >= (1 << kUnwindInfoCountBits) )
 		throwf("too many compact unwind infos in function %s", this->name());
-	if ( startIndex >= (1 << kUnwindInfoStartIndexBits) ) 
+	if ( startIndex >= (1 << kUnwindInfoStartIndexBits) )
 		throwf("too many compact unwind infos (%d) in file", startIndex);
 	assert((startIndex+count) <= sect().file()._unwindInfos.size() && "unwindinfo index out of range");
-	_unwindInfoStartIndex = startIndex; 
-	_unwindInfoCount = count; 
+	_unwindInfoStartIndex = startIndex;
+	_unwindInfoCount = count;
 }
 
 template <typename A>
 void Atom<A>::extendUnwindInfoRange()
 {
-	if ( _unwindInfoCount+1 >= (1 << kUnwindInfoCountBits) ) 
+	if ( _unwindInfoCount+1 >= (1 << kUnwindInfoCountBits) )
 		throwf("too many compact unwind infos in function %s", this->name());
 	_unwindInfoCount += 1;
 }
 
 template <typename A>
 void Atom<A>::setLineInfoRange(uint32_t startIndex, uint32_t count)
-{ 
+{
 	assert((count < (1 << kLineInfoCountBits)) && "too many line infos");
 	assert((startIndex+count) < sect().file()._lineInfos.size() && "line info index out of range");
-	_lineInfoStartIndex = startIndex; 
-	_lineInfoCount = count; 
+	_lineInfoStartIndex = startIndex;
+	_lineInfoCount = count;
 }
 
 template <typename A>
@@ -913,7 +913,7 @@
 {
 	const macho_section<P>* sct = this->sect().machoSection();
 	if ( this->_objAddress > sct->addr() + sct->size() )
-		throwf("malformed .o file, symbol has address 0x%0llX which is outside range of its section", (uint64_t)this->_objAddress);
+		throwf("malformed .o file, symbol has address 0x%0lX which is outside range of its section", (uint64_t)this->_objAddress);
 	uint32_t fileOffset = sct->offset() - sct->addr() + this->_objAddress;
 	return this->sect().file().fileContent()+fileOffset;
 }
@@ -961,13 +961,13 @@
 class AliasAtom : public ld::Atom
 {
 public:
-										AliasAtom(const char* name, bool hidden, const ld::File* file, const char* aliasOfName) : 
+										AliasAtom(const char* name, bool hidden, const ld::File* file, const char* aliasOfName) :
 											ld::Atom(_s_section, ld::Atom::definitionRegular, ld::Atom::combineNever,
-													(hidden ? ld::Atom::scopeLinkageUnit : ld::Atom::scopeGlobal), 
-													ld::Atom::typeUnclassified, ld::Atom::symbolTableIn, 
+													(hidden ? ld::Atom::scopeLinkageUnit : ld::Atom::scopeGlobal),
+													ld::Atom::typeUnclassified, ld::Atom::symbolTableIn,
 													false, false, true, 0),
 											_file(file),
-											_name(name), 
+											_name(name),
 											_fixup(0, ld::Fixup::k1of1, ld::Fixup::kindNoneFollowOn, ld::Fixup::bindingByNameUnbound, aliasOfName) { }
 
 	virtual const ld::File*				file() const		{ return _file; }
@@ -992,20 +992,20 @@
 
 
 template <typename A>
-class Parser 
+class Parser
 {
 public:
-	static bool										validFile(const uint8_t* fileContent, bool subtypeMustMatch=false, 
+	static bool										validFile(const uint8_t* fileContent, bool subtypeMustMatch=false,
 																cpu_subtype_t subtype=0);
 	static const char*								fileKind(const uint8_t* fileContent);
 	static ld::Platform								findPlatform(const macho_header<typename A::P>* header,  uint64_t fileLength, uint32_t* minOsVers);
 	static bool										hasObjC2Categories(const uint8_t* fileContent);
 	static bool										hasObjC1Categories(const uint8_t* fileContent);
 	static bool										getNonLocalSymbols(const uint8_t* fileContnet, std::vector<const char*> &syms);
-	static ld::relocatable::File*					parse(const uint8_t* fileContent, uint64_t fileLength, 
+	static ld::relocatable::File*					parse(const uint8_t* fileContent, uint64_t fileLength,
 															const char* path, time_t modTime, ld::File::Ordinal ordinal,
 															 const ParserOptions& opts) {
-																Parser p(fileContent, fileLength, path, modTime, 
+																Parser p(fileContent, fileLength, path, modTime,
 																		ordinal, opts.warnUnwindConversionProblems,
 																		opts.keepDwarfUnwind, opts.forceDwarfConversion,
 																		opts.neverConvertDwarf, opts.verboseOptimizationHints);
@@ -1024,7 +1024,7 @@
 	};
 
 	struct TargetDesc {
-		Atom<A>*	atom;		
+		Atom<A>*	atom;
 		const char*	name;		// only used if targetAtom is NULL
 		int64_t		addend;
 		bool		weakImport;	// only used if targetAtom is NULL
@@ -1036,16 +1036,16 @@
 	struct FixupInAtom {
 		FixupInAtom(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, Atom<A>* target) :
 			fixup(src.offsetInAtom, c, k, target), atom(src.atom) { src.atom->incrementFixupCount(); }
-			
+
 		FixupInAtom(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, ld::Fixup::TargetBinding b, Atom<A>* target) :
 			fixup(src.offsetInAtom, c, k, b, target), atom(src.atom) { src.atom->incrementFixupCount(); }
-			
+
 		FixupInAtom(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, bool wi, const char* name) :
 			fixup(src.offsetInAtom, c, k, wi, name), atom(src.atom) { src.atom->incrementFixupCount(); }
-					
+
 		FixupInAtom(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, ld::Fixup::TargetBinding b, const char* name) :
 			fixup(src.offsetInAtom, c, k, b, name), atom(src.atom) { src.atom->incrementFixupCount(); }
-					
+
 		FixupInAtom(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, uint64_t addend) :
 			fixup(src.offsetInAtom, c, k, addend), atom(src.atom) { src.atom->incrementFixupCount(); }
 
@@ -1061,24 +1061,24 @@
 		Atom<A>*		atom;
 	};
 
-	void addFixup(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, Atom<A>* target) { 
-		_allFixups.push_back(FixupInAtom(src, c, k, target)); 
+	void addFixup(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, Atom<A>* target) {
+		_allFixups.push_back(FixupInAtom(src, c, k, target));
+	}
+
+	void addFixup(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, ld::Fixup::TargetBinding b, Atom<A>* target) {
+		_allFixups.push_back(FixupInAtom(src, c, k, b, target));
+	}
+
+	void addFixup(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, bool wi, const char* name) {
+		_allFixups.push_back(FixupInAtom(src, c, k, wi, name));
 	}
-	
-	void addFixup(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, ld::Fixup::TargetBinding b, Atom<A>* target) { 
-		_allFixups.push_back(FixupInAtom(src, c, k, b, target)); 
-	}
-	
-	void addFixup(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, bool wi, const char* name) { 
-		_allFixups.push_back(FixupInAtom(src, c, k, wi, name)); 
-	}
-	
-	void addFixup(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, ld::Fixup::TargetBinding b, const char* name) { 
-		_allFixups.push_back(FixupInAtom(src, c, k, b, name)); 
-	}
-	
-	void addFixup(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, uint64_t addend) { 
-		_allFixups.push_back(FixupInAtom(src, c, k, addend)); 
+
+	void addFixup(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, ld::Fixup::TargetBinding b, const char* name) {
+		_allFixups.push_back(FixupInAtom(src, c, k, b, name));
+	}
+
+	void addFixup(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k, uint64_t addend) {
+		_allFixups.push_back(FixupInAtom(src, c, k, addend));
 	}
 
 #if SUPPORT_ARCH_arm64e
@@ -1087,8 +1087,8 @@
 	}
 #endif
 
-	void addFixup(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k) { 
-		_allFixups.push_back(FixupInAtom(src, c, k)); 
+	void addFixup(const SourceLocation& src, ld::Fixup::Cluster c, ld::Fixup::Kind k) {
+		_allFixups.push_back(FixupInAtom(src, c, k));
 	}
 
 	const char*										path() { return _path; }
@@ -1147,24 +1147,24 @@
 	const uint8_t*									optimizationHintsEnd() { return _lohEnd; }
 	bool											hasOptimizationHints() { return _lohStart != _lohEnd; }
 
-	
+
 	void							addFixups(const SourceLocation& src, ld::Fixup::Kind kind, const TargetDesc& target);
 	void							addFixups(const SourceLocation& src, ld::Fixup::Kind kind, const TargetDesc& target, const TargetDesc& picBase);
-	
+
 
 
 	struct LabelAndCFIBreakIterator {
 		typedef typename CFISection<A>::CFI_Atom_Info CFI_Atom_Info;
-								LabelAndCFIBreakIterator(const uint32_t* ssa, uint32_t ssc, const pint_t* cfisa, 
+								LabelAndCFIBreakIterator(const uint32_t* ssa, uint32_t ssc, const pint_t* cfisa,
 														uint32_t cfisc, bool ols)
-									: sortedSymbolIndexes(ssa), sortedSymbolCount(ssc), cfiStartsArray(cfisa), 
+									: sortedSymbolIndexes(ssa), sortedSymbolCount(ssc), cfiStartsArray(cfisa),
 										cfiStartsCount(cfisc), fileHasOverlappingSymbols(ols),
 										newSection(false), cfiIndex(0), symIndex(0) {}
-		bool					next(Parser<A>& parser, const Section<A>& sect, uint32_t sectNum, pint_t startAddr, pint_t endAddr, 
+		bool					next(Parser<A>& parser, const Section<A>& sect, uint32_t sectNum, pint_t startAddr, pint_t endAddr,
 										pint_t* addr, pint_t* size, const macho_nlist<P>** sym);
 		pint_t					peek(Parser<A>& parser, pint_t startAddr, pint_t endAddr);
 		void					beginSection() { newSection = true; symIndex = 0; }
-		
+
 		const uint32_t* const		sortedSymbolIndexes;
 		const uint32_t				sortedSymbolCount;
 		const pint_t*				cfiStartsArray;
@@ -1178,8 +1178,8 @@
 	struct CFI_CU_InfoArrays {
 			typedef typename CFISection<A>::CFI_Atom_Info CFI_Atom_Info;
 			typedef typename CUSection<A>::Info CU_Info;
-						CFI_CU_InfoArrays(const CFI_Atom_Info* cfiAr, uint32_t cfiC, CU_Info* cuAr, uint32_t cuC) 
-							: cfiArray(cfiAr), cuArray(cuAr), cfiCount(cfiC), cuCount(cuC) {} 
+						CFI_CU_InfoArrays(const CFI_Atom_Info* cfiAr, uint32_t cfiC, CU_Info* cuAr, uint32_t cuC)
+							: cfiArray(cfiAr), cuArray(cuAr), cfiCount(cfiC), cuCount(cuC) {}
 		const CFI_Atom_Info* const	cfiArray;
 			CU_Info* const			cuArray;
 		const uint32_t				cfiCount;
@@ -1190,9 +1190,9 @@
 
 private:
 	friend class Section<A>;
-	
-	enum SectionType { sectionTypeIgnore, sectionTypeLiteral4, sectionTypeLiteral8, sectionTypeLiteral16, 
-						sectionTypeNonLazy, sectionTypeCFI, sectionTypeCString, sectionTypeCStringPointer, 
+
+	enum SectionType { sectionTypeIgnore, sectionTypeLiteral4, sectionTypeLiteral8, sectionTypeLiteral16,
+						sectionTypeNonLazy, sectionTypeCFI, sectionTypeCString, sectionTypeCStringPointer,
 						sectionTypeUTF16Strings, sectionTypeCFString, sectionTypeObjC2ClassRefs, typeObjC2CategoryList,
 						sectionTypeObjC1Classes, sectionTypeSymboled, sectionTypeObjC1ClassRefs,
 						sectionTypeTentativeDefinitions, sectionTypeAbsoluteSymbols, sectionTypeTLVDefs,
@@ -1203,7 +1203,7 @@
 	{
 		const macho_section<P>* sect;
 		SectionType				type;
-		
+
 		static int sorter(const void* l, const void* r) {
 			const MachOSectionAndSectionClass<P>* left = (MachOSectionAndSectionClass<P>*)l;
 			const MachOSectionAndSectionClass<P>* right = (MachOSectionAndSectionClass<P>*)r;
@@ -1216,12 +1216,12 @@
 				return 1;
 		}
 	};
-	
+
 	struct ParserAndSectionsArray { Parser* parser; const uint32_t* sortedSectionsArray; };
-	
 
-													Parser(const uint8_t* fileContent, uint64_t fileLength, 
-															const char* path, time_t modTime, ld::File::Ordinal ordinal, 
+
+													Parser(const uint8_t* fileContent, uint64_t fileLength,
+															const char* path, time_t modTime, ld::File::Ordinal ordinal,
 															bool warnUnwindConversionProblems, bool keepDwarfUnwind,
 															bool forceDwarfConversion, bool neverConvertDwarf,
 															bool verboseOptimizationHints);
@@ -1246,9 +1246,9 @@
 	pint_t											realAddr(pint_t addr);
 	const char*										getDwarfString(uint64_t form, const uint8_t*& p);
 	uint64_t										getDwarfOffset(uint64_t form, const uint8_t*& di, bool dwarf64);
-	bool											skip_form(const uint8_t ** offset, const uint8_t * end, 
+	bool											skip_form(const uint8_t ** offset, const uint8_t * end,
 																uint64_t form, uint8_t addr_size, bool dwarf64);
-	
+
 
 	// filled in by constructor
 	const uint8_t*								_fileContent;
@@ -1256,7 +1256,7 @@
 	const char*									_path;
 	time_t										_modTime;
 	ld::File::Ordinal							_ordinal;
-	
+
 	// filled in by parseLoadCommands()
 	File<A>*									_file;
 	const macho_nlist<P>*						_symbols;
@@ -1275,7 +1275,7 @@
 	macho_data_in_code_entry<P>*				_dataInCodeEnd;
 	const uint8_t*								_lohStart;
 	const uint8_t*								_lohEnd;
-		
+
 	// filled in by parse()
 	CFISection<A>*								_EHFrameSection;
 	CUSection<A>*								_compactUnwindSection;
@@ -1308,15 +1308,15 @@
 
 
 template <typename A>
-Parser<A>::Parser(const uint8_t* fileContent, uint64_t fileLength, const char* path, time_t modTime, 
-					ld::File::Ordinal ordinal, bool convertDUI, bool keepDwarfUnwind, bool forceDwarfConversion, 
+Parser<A>::Parser(const uint8_t* fileContent, uint64_t fileLength, const char* path, time_t modTime,
+					ld::File::Ordinal ordinal, bool convertDUI, bool keepDwarfUnwind, bool forceDwarfConversion,
 					bool neverConvertDwarf, bool verboseOptimizationHints)
 		: _fileContent(fileContent), _fileLength(fileLength), _path(path), _modTime(modTime),
 			_ordinal(ordinal), _file(NULL),
 			_symbols(NULL), _symbolCount(0), _indirectSymbolCount(0), _strings(NULL), _stringsSize(0),
-			_indirectTable(NULL), _indirectTableCount(0), 
-			_undefinedStartIndex(0), _undefinedEndIndex(0), 
-			_sectionsStart(NULL), _machOSectionsCount(0), _hasUUID(false), 
+			_indirectTable(NULL), _indirectTableCount(0),
+			_undefinedStartIndex(0), _undefinedEndIndex(0),
+			_sectionsStart(NULL), _machOSectionsCount(0), _hasUUID(false),
 			_dataInCodeStart(NULL), _dataInCodeEnd(NULL),
 			_lohStart(NULL), _lohEnd(NULL),
 			_EHFrameSection(NULL), _compactUnwindSection(NULL), _absoluteSection(NULL),
@@ -1466,7 +1466,7 @@
 			const macho_section<P>* sectionsStart = (macho_section<P>*)((char*)segment + sizeof(macho_segment_command<P>));
 			for (uint32_t si=0; si < segment->nsects(); ++si) {
 				const macho_section<P>* sect = &sectionsStart[si];
-				if ( (sect->size() > 0) 
+				if ( (sect->size() > 0)
 					&& (strcmp(sect->sectname(), "__objc_catlist") == 0)
 					&& (strcmp(sect->segname(), "__DATA") == 0) ) {
 						return true;
@@ -1501,7 +1501,7 @@
 			const macho_section<P>* sectionsStart = (macho_section<P>*)((char*)segment + sizeof(macho_segment_command<P>));
 			for (uint32_t si=0; si < segment->nsects(); ++si) {
 				const macho_section<P>* sect = &sectionsStart[si];
-				if ( (sect->size() > 0) 
+				if ( (sect->size() > 0)
 					&& (strcmp(sect->sectname(), "__category") == 0)
 					&& (strcmp(sect->segname(), "__OBJC") == 0) ) {
 						return true;
@@ -1551,7 +1551,7 @@
 template <typename A>
 int Parser<A>::pointerSorter(const void* l, const void* r)
 {
-	// sort references by address 
+	// sort references by address
 	const pint_t* left = (pint_t*)l;
 	const pint_t* right = (pint_t*)r;
 	return (*left - *right);
@@ -1574,7 +1574,7 @@
 		if ( cfiAddr <  endAddr )
 			return cfiAddr;
 		else
-			return endAddr;		
+			return endAddr;
 	}
 	else  {
 		if ( symbolAddr <  endAddr )
@@ -1590,7 +1590,7 @@
 // was becuase of a label, the symbol). Returns false when no more chunks.
 //
 template <typename A>
-bool Parser<A>::LabelAndCFIBreakIterator::next(Parser<A>& parser, const Section<A>& sect, uint32_t sectNum, pint_t startAddr, pint_t endAddr, 
+bool Parser<A>::LabelAndCFIBreakIterator::next(Parser<A>& parser, const Section<A>& sect, uint32_t sectNum, pint_t startAddr, pint_t endAddr,
 												pint_t* addr, pint_t* size, const macho_nlist<P>** symbol)
 {
 	bool cfiApplicable = (sect.machoSection()->flags() & (S_ATTR_PURE_INSTRUCTIONS | S_ATTR_SOME_INSTRUCTIONS));
@@ -1699,7 +1699,7 @@
 			*symbol = &sym;
 			return true;
 		}
-		else if ( nextCfiAddr < nextSymbolAddr ) { 
+		else if ( nextCfiAddr < nextSymbolAddr ) {
 			if ( nextCfiAddr >= endAddr )
 				return false;
 			++cfiIndex;
@@ -1727,7 +1727,7 @@
 		const macho_nlist<P>& sym = parser.symbolFromIndex(sortedSymbolIndexes[symIndex]);
 		pint_t nextSymbolAddr = sym.n_value();
 		// if next symbol found is not in this section, then done with iteration
-		if ( sym.n_sect() != sectNum ) 
+		if ( sym.n_sect() != sectNum )
 			return false;
 		++symIndex;
 		if ( nextSymbolAddr < startAddr )
@@ -1765,7 +1765,7 @@
 }
 
 #if !__has_builtin(__builtin_mul_overflow) // ld64-port (clang < 3.8)
-template<typename T> 
+template<typename T>
 bool __builtin_mul_overflow(uint32_t a, uint32_t b, T *r)
 {
 	static_assert(sizeof(T) == sizeof(uint32_t), "");
@@ -1812,26 +1812,26 @@
 	// respond to -t option
 	if ( opts.logAllFiles )
 		printf("%s\n", _path);
-		
+
 	_armUsesZeroCostExceptions = opts.armUsesZeroCostExceptions;
 	_maxDefaultCommonAlignment = opts.maxDefaultCommonAlignment;
 
 	// parse start of mach-o file
 	if ( ! parseLoadCommands(opts.platforms, opts.internalSDK) )
 		return _file;
-	
+
 	// make array of
 	uint32_t sortedSectionIndexes[_machOSectionsCount];
 	this->makeSortedSectionsArray(sortedSectionIndexes);
-	
+
 	// make symbol table sorted by address
 	this->prescanSymbolTable();
 	uint32_t sortedSymbolIndexes[_symbolsInSections];
 	this->makeSortedSymbolsArray(sortedSymbolIndexes, sortedSectionIndexes);
-		
+
 	// allocate Section<A> object for each mach-o section
 	makeSections();
-	
+
 	// if it exists, do special early parsing of __compact_unwind section
 	uint32_t countOfCUs = 0;
 	if ( _compactUnwindSection != NULL )
@@ -1852,18 +1852,18 @@
 		if ( cuInfoArray[i].lsdaAddress != 0 )
 			++cuLsdaCount;
 	}
-	
-	
-	// if it exists, do special early parsing of __eh_frame section 
+
+
+	// if it exists, do special early parsing of __eh_frame section
 	// stack allocate (if not too large) array of CFI_Atom_Info
 	uint32_t countOfCFIs = 0;
 	if ( _EHFrameSection != NULL )
 		countOfCFIs = _EHFrameSection->cfiCount(*this);
 	STACK_ALLOC_IF_SMALL(typename CFISection<A>::CFI_Atom_Info, cfiArray, countOfCFIs, 1024);
-	
+
 	// stack allocate (if not too large) a copy of __eh_frame to apply relocations to
 	uint32_t sectSize = 4;
-	if ( (countOfCFIs != 0) && _EHFrameSection->needsRelocating() ) 
+	if ( (countOfCFIs != 0) && _EHFrameSection->needsRelocating() )
 		sectSize = _EHFrameSection->machoSection()->size()+4;
 	STACK_ALLOC_IF_SMALL(uint8_t, ehBuffer, sectSize, 50*1024);
 	uint32_t cfiStartsCount = 0;
@@ -1884,7 +1884,7 @@
 		}
 	}
 	CFI_CU_InfoArrays cfis(cfiArray, countOfCFIs, cuInfoArray, countOfCUs);
-	
+
 	// create sorted array of function starts and lsda starts
 	pint_t cfiStartsArray[cfiStartsCount+cuLsdaCount];
 	uint32_t countOfFDEs = 0;
@@ -1923,14 +1923,14 @@
 		for(uint32_t i=1; i < cfiStartsArrayCount; ++i) {
 			assert( cfiStartsArray[i] != cfiStartsArray[i-1] );
 		}
-	#endif	
+	#endif
 	}
-	
+
 	Section<A>** sections = _file->_sectionsArray;
 	uint32_t	sectionsCount = _file->_sectionsArrayCount;
 
 	// figure out how many atoms will be allocated and allocate
-	LabelAndCFIBreakIterator breakIterator(sortedSymbolIndexes, _symbolsInSections, cfiStartsArray, 
+	LabelAndCFIBreakIterator breakIterator(sortedSymbolIndexes, _symbolsInSections, cfiStartsArray,
 											cfiStartsArrayCount, _overlappingSymbols);
 	uint32_t computedAtomCount = 0;
 	for (uint32_t i=0; i < sectionsCount; ++i ) {
@@ -1943,9 +1943,9 @@
 	//fprintf(stderr, "allocating %d atoms * sizeof(Atom<A>)=%ld, sizeof(ld::Atom)=%ld\n", computedAtomCount, sizeof(Atom<A>), sizeof(ld::Atom));
 	_file->_atomsArray = new uint8_t[computedAtomCount*sizeof(Atom<A>)];
 	_file->_atomsArrayCount = 0;
-	
+
 	// have each section append atoms to _atomsArray
-	LabelAndCFIBreakIterator breakIterator2(sortedSymbolIndexes, _symbolsInSections, cfiStartsArray, 
+	LabelAndCFIBreakIterator breakIterator2(sortedSymbolIndexes, _symbolsInSections, cfiStartsArray,
 												cfiStartsArrayCount, _overlappingSymbols);
 	for (uint32_t i=0; i < sectionsCount; ++i ) {
 		uint8_t* atoms = _file->_atomsArray + _file->_atomsArrayCount*sizeof(Atom<A>);
@@ -1956,12 +1956,12 @@
 	}
 	assert( _file->_atomsArrayCount == computedAtomCount && "more atoms allocated than expected");
 
-	
+
 	// have each section add all fix-ups for its atoms
 	_allFixups.reserve(computedAtomCount*5);
 	for (uint32_t i=0; i < sectionsCount; ++i )
 		sections[i]->makeFixups(*this, cfis);
-	
+
 	// assign fixups start offset for each atom
 	uint8_t* p = _file->_atomsArray;
 	uint32_t fixupOffset = 0;
@@ -1974,14 +1974,14 @@
 	}
 	assert(fixupOffset == _allFixups.size());
 	_file->_fixups.resize(fixupOffset);
-	
-	// copy each fixup for each atom 
+
+	// copy each fixup for each atom
 	for(typename std::vector<FixupInAtom>::iterator it=_allFixups.begin(); it != _allFixups.end(); ++it) {
 		uint32_t slot = it->atom->_fixupsStartIndex + it->atom->_fixupsCount;
 		_file->_fixups[slot] = it->fixup;
 		it->atom->_fixupsCount++;
 	}
-	
+
 	// done with temp vector
 	_allFixups.clear();
 
@@ -2024,13 +2024,13 @@
 				}
 				lastFunc->extendUnwindInfoRange();
 			}
-			else 
+			else
 				info->function->setUnwindInfoRange(_file->_unwindInfos.size()-1, 1);
 			lastFunc = info->function;
 			lastEnd = ui.startOffset + info->rangeLength;
 		}
 	}
-	
+
 	// process indirect symbols which become AliasAtoms
 	_file->_aliasAtomsArray = NULL;
 	_file->_aliasAtomsArrayCount = 0;
@@ -2039,8 +2039,8 @@
 		_file->_aliasAtomsArray = new uint8_t[_file->_aliasAtomsArrayCount*sizeof(AliasAtom)];
 		this->appendAliasAtoms(_file->_aliasAtomsArray);
 	}
-	
-	
+
+
 	// parse dwarf debug info to get line info
 	this->parseDebugInfo();
 
@@ -2060,7 +2060,7 @@
 	// set File attributes
 	_file->_canScatterAtoms = (header->flags() & MH_SUBSECTIONS_VIA_SYMBOLS);
 	_file->_cpuSubType = header->cpusubtype();
-	
+
 	const macho_segment_command<P>*	segment = NULL;
 	const uint8_t* const endOfFile = _fileContent + _fileLength;
 	const uint32_t cmd_count = header->ncmds();
@@ -2187,7 +2187,7 @@
 	cmdLinePlatforms.checkObjectCrosslink(lcPlatforms, path(), internalSDK, _usingBitcode);
 
 	// validate just one segment
-	if ( segment == NULL ) 
+	if ( segment == NULL )
 		throw "missing LC_SEGMENT";
 	if ( segment->fileoff() > _fileLength )
 		throw "LC_SEGMENT fileoff too large";
@@ -2256,7 +2256,7 @@
 		// ignore stabs
 		if ( (sym.n_type() & N_STAB) != 0 )
 			continue;
-			
+
 		// look at undefines
 		const char* symbolName = this->nameFromSymbol(sym);
 		if ( (sym.n_type() & N_TYPE) == N_UNDF ) {
@@ -2281,12 +2281,12 @@
 		// count absolute symbols
 		if ( (sym.n_type() & N_TYPE) == N_ABS ) {
 			const char* absName = this->nameFromSymbol(sym);
-			// ignore .objc_class_name_* symbols 
+			// ignore .objc_class_name_* symbols
 			if ( strncmp(absName, ".objc_class_name_", 17) == 0 ) {
 				_AppleObjc = true;
 				continue;
 			}
-			// ignore .objc_class_name_* symbols 
+			// ignore .objc_class_name_* symbols
 			if ( strncmp(absName, ".objc_category_name_", 20) == 0 )
 				continue;
 			// ignore empty *.eh symbols
@@ -2294,22 +2294,22 @@
 				continue;
 			++_absoluteSymbolCount;
 		}
-		
+
 		// only look at definitions
 		if ( (sym.n_type() & N_TYPE) != N_SECT )
 			continue;
-		
+
 		// 'L' labels do not denote atom breaks
 		if ( symbolName[0] == 'L' ) {
 			// <rdar://problem/9218847> Formalize data in code with L$start$ labels
-			if ( strncmp(symbolName, "L$start$", 8) == 0 ) 
+			if ( strncmp(symbolName, "L$start$", 8) == 0 )
 				_hasDataInCodeLabels = true;
 			continue;
 		}
 		// how many def syms in each section
 		if ( sym.n_sect() > _machOSectionsCount )
 			throw "bad n_sect in symbol table";
-			
+
 		_symbolsInSections++;
 	}
 }
@@ -2324,11 +2324,11 @@
 			continue;
 
 		// only look at N_INDR symbols
-		if ( (sym.n_type() & N_TYPE) != N_INDR ) 
+		if ( (sym.n_type() & N_TYPE) != N_INDR )
 			continue;
 
 		// skip non-external aliases
-		if ( (sym.n_type() & N_EXT) == 0 ) 
+		if ( (sym.n_type() & N_EXT) == 0 )
 			continue;
 
 		const char* symbolName = this->nameFromSymbol(sym);
@@ -2350,7 +2350,7 @@
 	const uint32_t* right = (uint32_t*)r;
 	const macho_section<P>* leftSect =	parser->machOSectionFromSectionIndex(*left);
 	const macho_section<P>* rightSect = parser->machOSectionFromSectionIndex(*right);
-	
+
 	// can't just return difference because 64-bit diff does not fit in 32-bit return type
 	int64_t result = leftSect->addr() - rightSect->addr();
 	if ( result == 0 ) {
@@ -2376,13 +2376,13 @@
 void Parser<A>::makeSortedSectionsArray(uint32_t array[])
 {
 	const bool log = false;
-	
+
 	if ( log ) {
 		fprintf(stderr, "unsorted sections:\n");
-		for(unsigned int i=0; i < _machOSectionsCount; ++i ) 
-			fprintf(stderr, "0x%08llX %s %s\n", _sectionsStart[i].addr(), _sectionsStart[i].segname(), _sectionsStart[i].sectname());
+		for(unsigned int i=0; i < _machOSectionsCount; ++i )
+			fprintf(stderr, "0x%08lX %s %s\n", _sectionsStart[i].addr(), _sectionsStart[i].segname(), _sectionsStart[i].sectname());
  	}
-	
+
 	// sort by symbol table address
 	for (uint32_t i=0; i < _machOSectionsCount; ++i)
 		array[i] = i;
@@ -2390,8 +2390,8 @@
 
 	if ( log ) {
 		fprintf(stderr, "sorted sections:\n");
-		for(unsigned int i=0; i < _machOSectionsCount; ++i ) 
-			fprintf(stderr, "0x%08llX %s %s\n", _sectionsStart[array[i]].addr(), _sectionsStart[array[i]].segname(), _sectionsStart[array[i]].sectname());
+		for(unsigned int i=0; i < _machOSectionsCount; ++i )
+			fprintf(stderr, "0x%08lX %s %s\n", _sectionsStart[array[i]].addr(), _sectionsStart[array[i]].segname(), _sectionsStart[array[i]].sectname());
 	}
 }
 
@@ -2429,7 +2429,7 @@
 		if ( leftIsTmp != rightIsTmp ) {
 			return (rightIsTmp ? -1 : 1);
 		}
-		
+
 		// if only one is global, make the other an alias (sort first)
 		if ( (leftSym.n_type() & N_EXT) != (rightSym.n_type() & N_EXT) ) {
 			if ( (rightSym.n_type() & N_EXT) != 0 )
@@ -2451,18 +2451,18 @@
 void Parser<A>::makeSortedSymbolsArray(uint32_t array[], const uint32_t sectionArray[])
 {
 	const bool log = false;
-	
+
 	uint32_t* p = array;
 	for (uint32_t i=0; i < this->_symbolCount; ++i) {
 		const macho_nlist<P>& sym =	symbolFromIndex(i);
 		// ignore stabs
 		if ( (sym.n_type() & N_STAB) != 0 )
 			continue;
-		
+
 		// only look at definitions
 		if ( (sym.n_type() & N_TYPE) != N_SECT )
 			continue;
-		
+
 		// 'L' labels do not denote atom breaks
 		const char* symbolName = this->nameFromSymbol(sym);
 		if ( symbolName[0] == 'L' )
@@ -2471,16 +2471,16 @@
 		// how many def syms in each section
 		if ( sym.n_sect() > _machOSectionsCount )
 			throw "bad n_sect in symbol table";
-			
+
 		// append to array
 		*p++ = i;
 	}
 	assert(p == &array[_symbolsInSections] && "second pass over symbol table yield a different number of symbols");
-	
+
 	// sort by symbol table address
 	ParserAndSectionsArray extra = { this, sectionArray };
 	::qsort_r(array, _symbolsInSections, sizeof(uint32_t), &extra, &symbolIndexSorter);
-	
+
 
 	// look for two symbols at same address
 	_overlappingSymbols = false;
@@ -2494,7 +2494,7 @@
 
 	if ( log ) {
 		fprintf(stderr, "sorted symbols:\n");
-		for(unsigned int i=0; i < _symbolsInSections; ++i ) 
+		for(unsigned int i=0; i < _symbolsInSections; ++i )
 			fprintf(stderr, "0x%09llX symIndex=%d sectNum=%2d, %s\n", symbolFromIndex(array[i]).n_value(), array[i], symbolFromIndex(array[i]).n_sect(), nameFromSymbol(symbolFromIndex(array[i])) );
 	}
 }
@@ -2587,7 +2587,7 @@
 				_file->_swiftLanguageVersion = ((flags >> 16) & 0xFFFF);
                 _file->_objcHasCategoryClassPropertiesField = (flags & 64);
 				if ( sect->size() > 8 ) {
-					warning("section %s/%s has unexpectedly large size %llu in %s", 
+					warning("section %s/%s has unexpectedly large size %llu in %s",
 							sect->segname(), Section<A>::makeSectionName(sect), sect->size(), _file->path());
 				}
 			}
@@ -2703,16 +2703,16 @@
 		_file->_bitcode = std::unique_ptr<ld::Bitcode>(new ld::BundleBitcode(&_fileContent[bundleSect->offset()], bundleSect->size()));
 	else if ( bitcodeAsm )
 		_file->_bitcode = std::unique_ptr<ld::Bitcode>(new ld::AsmBitcode(_fileContent, _fileLength));
-	
+
 	// sort by address (mach-o object files don't aways have sections sorted)
 	::qsort(machOSects, count, sizeof(MachOSectionAndSectionClass<P>), MachOSectionAndSectionClass<P>::sorter);
-		
+
 	// we will synthesize a dummy Section<A> object for tentative definitions
 	if ( _tentativeDefinitionCount > 0 ) {
 		totalSectionsSize += sizeof(TentativeDefinitionSection<A>);
 		machOSects[count++].type = sectionTypeTentativeDefinitions;
 	}
-	
+
 	// we will synthesize a dummy Section<A> object for Absolute symbols
 	if ( _absoluteSymbolCount > 0 ) {
 		totalSectionsSize += sizeof(AbsoluteSymbolSection<A>);
@@ -2782,7 +2782,7 @@
 				*objects++ = new (space) ObjC2CategoryListSection<A>(*this, *_file, machOSects[i].sect);
 				space += sizeof(ObjC2CategoryListSection<A>);
 				break;
-			case sectionTypeObjC1Classes: 
+			case sectionTypeObjC1Classes:
 				*objects++ = new (space) ObjC1ClassSection<A>(*this, *_file, machOSects[i].sect);
 				space += sizeof(ObjC1ClassSection<A>);
 				break;
@@ -2838,8 +2838,8 @@
 			}
 		}
 	}
-	
-	throwf("sectionForAddress(0x%llX) address not in any section", (uint64_t)addr);
+
+	throwf("sectionForAddress(0x%lX) address not in any section", (uint64_t)addr);
 }
 
 template <typename A>
@@ -2866,7 +2866,7 @@
 template <typename A>
 Atom<A>* Parser<A>::findAtomByAddressOrNullIfStub(pint_t addr)
 {
-	if ( hasStubsSection() && (_stubsMachOSection->addr() <= addr) && (addr < (_stubsMachOSection->addr()+_stubsMachOSection->size())) ) 
+	if ( hasStubsSection() && (_stubsMachOSection->addr() <= addr) && (addr < (_stubsMachOSection->addr()+_stubsMachOSection->size())) )
 		return NULL;
 	return findAtomByAddress(addr);
 }
@@ -3022,7 +3022,7 @@
 		// ignore stabs
 		if ( (sym.n_type() & N_STAB) != 0 )
 			continue;
-		
+
 		// only look at definitions
 		if ( (sym.n_type() & N_TYPE) != N_SECT )
 			continue;
@@ -3030,13 +3030,13 @@
 		// return with exact match
 		if ( sym.n_value() == addr ) {
 			const char* name = nameFromSymbol(sym);
-			if ( strncmp(name, "ltmp", 4) != 0 ) 
+			if ( strncmp(name, "ltmp", 4) != 0 )
 				return name;
 			// treat 'ltmp*' labels as close match
 			closestSymAddr = sym.n_value();
 			closestSymName = name;
 		}
-		
+
 		// record closest seen so far
 		if ( (sym.n_value() < addr) && ((sym.n_value() > closestSymAddr) || (closestSymName == NULL)) )
 			closestSymName = nameFromSymbol(sym);
@@ -3226,16 +3226,16 @@
 
 
 template <typename A>
-uint32_t TentativeDefinitionSection<A>::computeAtomCount(class Parser<A>& parser, 
-															struct Parser<A>::LabelAndCFIBreakIterator& it, 
+uint32_t TentativeDefinitionSection<A>::computeAtomCount(class Parser<A>& parser,
+															struct Parser<A>::LabelAndCFIBreakIterator& it,
 															const struct Parser<A>::CFI_CU_InfoArrays&)
 {
 	return parser.tentativeDefinitionCount();
 }
 
 template <typename A>
-uint32_t TentativeDefinitionSection<A>::appendAtoms(class Parser<A>& parser, uint8_t* p, 
-														struct Parser<A>::LabelAndCFIBreakIterator& it, 
+uint32_t TentativeDefinitionSection<A>::appendAtoms(class Parser<A>& parser, uint8_t* p,
+														struct Parser<A>::LabelAndCFIBreakIterator& it,
 														const struct Parser<A>::CFI_CU_InfoArrays&)
 {
 	this->_beginAtoms = (Atom<A>*)p;
@@ -3248,7 +3248,7 @@
 			if ( alignP2 == 0 ) {
 				// common symbols align to their size
 				// that is, a 4-byte common aligns to 4-bytes
-				// if this size is not a power of two, 
+				// if this size is not a power of two,
 				// then round up to the next power of two
 				alignP2 = 63 - (uint8_t)__builtin_clzll(size);
 				if ( size != (1ULL << alignP2) )
@@ -3259,8 +3259,8 @@
 			}
 			Atom<A>* allocatedSpace = (Atom<A>*)p;
 			new (allocatedSpace) Atom<A>(*this, parser.nameFromSymbol(sym), (pint_t)ULLONG_MAX, size,
-										ld::Atom::definitionTentative,  ld::Atom::combineByName, 
-										parser.scopeFromSymbol(sym), ld::Atom::typeZeroFill, ld::Atom::symbolTableIn, 
+										ld::Atom::definitionTentative,  ld::Atom::combineByName,
+										parser.scopeFromSymbol(sym), ld::Atom::typeZeroFill, ld::Atom::symbolTableIn,
 										parser.dontDeadStripFromSymbol(sym), false, false, ld::Atom::Alignment(alignP2) );
 			p += sizeof(Atom<A>);
 			++count;
@@ -3272,16 +3272,16 @@
 
 
 template <typename A>
-uint32_t AbsoluteSymbolSection<A>::computeAtomCount(class Parser<A>& parser, 
-															struct Parser<A>::LabelAndCFIBreakIterator& it, 
+uint32_t AbsoluteSymbolSection<A>::computeAtomCount(class Parser<A>& parser,
+															struct Parser<A>::LabelAndCFIBreakIterator& it,
 															const struct Parser<A>::CFI_CU_InfoArrays&)
 {
 	return parser.absoluteSymbolCount();
 }
 
 template <typename A>
-uint32_t AbsoluteSymbolSection<A>::appendAtoms(class Parser<A>& parser, uint8_t* p, 
-														struct Parser<A>::LabelAndCFIBreakIterator& it, 
+uint32_t AbsoluteSymbolSection<A>::appendAtoms(class Parser<A>& parser, uint8_t* p,
+														struct Parser<A>::LabelAndCFIBreakIterator& it,
 														const struct Parser<A>::CFI_CU_InfoArrays&)
 {
 	this->_beginAtoms = (Atom<A>*)p;
@@ -3291,10 +3291,10 @@
 		if ( (sym.n_type() & N_TYPE) != N_ABS )
 			continue;
 		const char* absName = parser.nameFromSymbol(sym);
-		// ignore .objc_class_name_* symbols 
+		// ignore .objc_class_name_* symbols
 		if ( strncmp(absName, ".objc_class_name_", 17) == 0 )
 			continue;
-		// ignore .objc_class_name_* symbols 
+		// ignore .objc_class_name_* symbols
 		if ( strncmp(absName, ".objc_category_name_", 20) == 0 )
 			continue;
 		// ignore empty *.eh symbols
@@ -3315,7 +3315,7 @@
 {
 	Atom<A>* end = this->_endAtoms;
 	for(Atom<A>* p = this->_beginAtoms; p < end; ++p) {
-		if ( p->_objAddress == value )	
+		if ( p->_objAddress == value )
 			return p;
 	}
 	return NULL;
@@ -3361,7 +3361,7 @@
 			break;
 		default:
 			throw "section does not use indirect symbol table";
-	}	
+	}
 	uint32_t indexInSection = (addr - sect->addr()) / elementSize;
 	uint32_t indexIntoIndirectTable = sect->reserved1() + indexInSection;
 	return this->indirectSymbol(indexIntoIndirectTable);
@@ -3400,7 +3400,7 @@
 		case N_SECT:
 			return ld::Atom::definitionRegular;
 		case N_UNDF:
-			if ( sym.n_value() != 0 ) 
+			if ( sym.n_value() != 0 )
 				return ld::Atom::definitionTentative;
 	}
 	throw "definitionFromSymbol() bad symbol";
@@ -3409,7 +3409,7 @@
 template <typename A>
 ld::Atom::Combine Parser<A>::combineFromSymbol(const macho_nlist<P>& sym)
 {
-	if ( sym.n_desc() & N_WEAK_DEF ) 
+	if ( sym.n_desc() & N_WEAK_DEF )
 		return ld::Atom::combineByName;
 	else
 		return ld::Atom::combineNever;
@@ -3422,7 +3422,7 @@
 	const char* symbolName = nameFromSymbol(sym);
 	// labels beginning with 'l' (lowercase ell) are automatically removed in final linked images <rdar://problem/4571042>
 	// labels beginning with 'L' should have been stripped by the assembler, so are stripped now
-	if ( sym.n_desc() & REFERENCED_DYNAMICALLY ) 
+	if ( sym.n_desc() & REFERENCED_DYNAMICALLY )
 		return ld::Atom::symbolTableInAndNeverStrip;
 	else if ( symbolName[0] == 'l' )
 		return ld::Atom::symbolTableNotInFinalLinkedImages;
@@ -3577,7 +3577,7 @@
 	case DW_FORM_sec_offset:
 	  sz = sizeof(typename A::P::uint_t);
       break;
-	
+
 	case DW_FORM_exprloc:
       sz = read_uleb128 (offset, end);
       break;
@@ -3585,7 +3585,7 @@
     case DW_FORM_flag_present:
 	  sz = 0;
 	  break;
-	  
+
     case DW_FORM_ref_sig8:
 	  sz = 8;
 	  break;
@@ -3621,7 +3621,7 @@
 			di += 4;
 			break;
 		default:
-			warning("unknown dwarf string encoding (form=%lld) in %s", form, this->_path);
+			warning("unknown dwarf string encoding (form=%ld) in %s", form, this->_path);
 			break;
 	}
 	return result;
@@ -3630,7 +3630,7 @@
 template <typename A>
 uint64_t Parser<A>::getDwarfOffset(uint64_t form, const uint8_t*& di, bool dwarf64)
 {
-	if ( form == DW_FORM_sec_offset ) 
+	if ( form == DW_FORM_sec_offset )
 		form = (dwarf64 ? DW_FORM_data8 : DW_FORM_data4);
 	uint64_t result = -1;
 	switch (form) {
@@ -3678,7 +3678,7 @@
 void Parser<A>::parseDebugInfo()
 {
 	addAstFiles();
-	
+
 	// check for dwarf __debug_info section
 	if ( _file->_dwarfDebugInfoSect == NULL ) {
 		// if no DWARF debug info, look for stabs
@@ -3687,7 +3687,7 @@
 	}
 	if ( _file->_dwarfDebugInfoSect->size() == 0 )
 		return;
-		
+
 	uint64_t stmtList;
 	const char* tuDir;
 	const char* tuName;
@@ -3710,7 +3710,7 @@
 	else {
 		_file->_dwarfTranslationUnitPath = NULL;
 	}
-	
+
 	// add line number info to atoms from dwarf
 	std::vector<AtomAndLineInfo<A> > entries;
 	entries.reserve(64);
@@ -3762,7 +3762,7 @@
 							}
 							if ( curAtom == NULL )
 								break; // file has line info but no functions
-							if ( result.end_of_sequence && (curAtomAddress+curAtomSize < result.pc) ) {	
+							if ( result.end_of_sequence && (curAtomAddress+curAtomSize < result.pc) ) {
 								// a one line function can be returned by line_next() as one entry with pc at end of blob
 								// look for alt atom starting at end of previous atom
 								uint32_t previousEnd = curAtomAddress+curAtomSize;
@@ -3803,7 +3803,7 @@
 							entry.info.atomOffset = curAtomOffset;
 							entry.info.fileName = filename;
 							entry.info.lineNumber = result.line;
-							//fprintf(stderr, "addr=0x%08llX, line=%lld, file=%s, atom=%s, atom.size=0x%X, end=%d\n", 
+							//fprintf(stderr, "addr=0x%08llX, line=%lld, file=%s, atom=%s, atom.size=0x%X, end=%d\n",
 							//		result.pc, result.line, filename, curAtom->name(), curAtomSize, result.end_of_sequence);
 							entries.push_back(entry);
 							curAtom->incrementLineInfoCount();
@@ -3817,7 +3817,7 @@
 			}
 		}
 	}
-		
+
 	// assign line info start offset for each atom
 	uint8_t* p = _file->_atomsArray;
 	uint32_t liOffset = 0;
@@ -3831,13 +3831,13 @@
 	assert(liOffset == entries.size());
 	_file->_lineInfos.resize(liOffset);
 
-	// copy each line info for each atom 
+	// copy each line info for each atom
 	for (typename std::vector<AtomAndLineInfo<A> >::iterator it = entries.begin(); it != entries.end(); ++it) {
 		uint32_t slot = it->atom->_lineInfoStartIndex + it->atom->_lineInfoCount;
 		_file->_lineInfos[slot] = it->info;
 		it->atom->_lineInfoCount++;
 	}
-	
+
 	// done with temp vector
 	entries.clear();
 }
@@ -3891,7 +3891,7 @@
 								stab.string = symString;
 							}
 							else {
-								fprintf(stderr, "can't find atom for stabs BNSYM at %08llX in %s",
+								fprintf(stderr, "can't find atom for stabs BNSYM at %08lX in %s",
 									(uint64_t)sym.n_value(), _path);
 							}
 							break;
@@ -3964,7 +3964,7 @@
 									stab.string = symString;
 								}
 								else {
-									warning("can't find atom for stabs FUN at %08llX in %s",
+									warning("can't find atom for stabs FUN at %08lX in %s",
 										(uint64_t)currentAtomAddress, _path);
 								}
 							}
@@ -4000,7 +4000,7 @@
 								stab.string = symString;
 							}
 							else {
-								warning("can't find atom for stabs 0x%X at %08llX in %s",
+								warning("can't find atom for stabs 0x%X at %08lX in %s",
 									type, (uint64_t)sym.n_value(), _path);
 							}
 							break;
@@ -4032,7 +4032,7 @@
 										stab.string = symString;
 									}
 									else {
-										warning("can't find atom for stabs FUN at %08llX in %s",
+										warning("can't find atom for stabs FUN at %08lX in %s",
 											(uint64_t)currentAtomAddress, _path);
 									}
 								}
@@ -4268,7 +4268,7 @@
 		handler.doAtom(*((AliasAtom*)p));
 		p += sizeof(AliasAtom);
 	}
-	
+
 	return (_atomsArrayCount != 0) || (_aliasAtomsArrayCount != 0);
 }
 
@@ -4278,7 +4278,7 @@
 	// mach-o section record only has room for 16-byte seg/sect names
 	// so a 16-byte name has no trailing zero
 	const char* name = sect->segname();
-	if ( strlen(name) < 16 ) 
+	if ( strlen(name) < 16 )
 		return name;
 	char* tmp = new char[17];
 	strlcpy(tmp, name, 17);
@@ -4289,9 +4289,9 @@
 const char* Section<A>::makeSectionName(const macho_section<typename A::P>* sect)
 {
 	const char* name = sect->sectname();
-	if ( strlen(name) < 16 ) 
+	if ( strlen(name) < 16 )
 		return name;
-		
+
 	// special case common long section names so we don't have to malloc
 	if ( strncmp(sect->sectname(), "__objc_classrefs", 16) == 0 )
 		return "__objc_classrefs";
@@ -4379,7 +4379,7 @@
 				return ld::Section::typeCode;
 			}
 			else if ( strcmp(sect->segname(), "__TEXT") == 0 ) {
-				if ( strcmp(sect->sectname(), "__eh_frame") == 0 ) 
+				if ( strcmp(sect->sectname(), "__eh_frame") == 0 )
 					return ld::Section::typeCFI;
 				else if ( strcmp(sect->sectname(), "__ustring") == 0 )
 					return ld::Section::typeUTF16Strings;
@@ -4391,7 +4391,7 @@
 					return ld::Section::typeInitializerPointers;
 			}
 			else if ( strcmp(sect->segname(), "__DATA") == 0 ) {
-				if ( strcmp(sect->sectname(), "__cfstring") == 0 ) 
+				if ( strcmp(sect->sectname(), "__cfstring") == 0 )
 					return ld::Section::typeCFString;
 				else if ( strcmp(sect->sectname(), "__dyld") == 0 )
 					return ld::Section::typeDyldInfo;
@@ -4403,7 +4403,7 @@
 					return ld::Section::typeObjC2CategoryList;
 			}
 			else if ( strcmp(sect->segname(), "__OBJC") == 0 ) {
-				if ( strcmp(sect->sectname(), "__class") == 0 ) 
+				if ( strcmp(sect->sectname(), "__class") == 0 )
 					return ld::Section::typeObjC1Classes;
 			}
 			break;
@@ -4441,13 +4441,13 @@
 				return pivot;
 		}
 		if ( addr >= atomEndAddr ) {
-			// key > pivot 
+			// key > pivot
 			// move base to atom after pivot
 			base = &pivot[1];
-			--n; 
+			--n;
 		}
 		else {
-			// key < pivot 
+			// key < pivot
 			// keep same base
 		}
 	}
@@ -4455,18 +4455,18 @@
 }
 
 template <typename A>
-ld::Atom::Alignment Section<A>::alignmentForAddress(pint_t addr) 
-{ 
+ld::Atom::Alignment Section<A>::alignmentForAddress(pint_t addr)
+{
 	const uint32_t sectionAlignment = this->_machOSection->align();
 	uint32_t modulus = (addr % (1 << sectionAlignment));
 	if ( modulus > 0xFFFF )
-		warning("alignment for symbol at address 0x%08llX in %s exceeds 2^16", (uint64_t)addr, this->file().path());
+		warning("alignment for symbol at address 0x%08lX in %s exceeds 2^16", (uint64_t)addr, this->file().path());
 	return ld::Atom::Alignment(sectionAlignment, modulus);
 }
 
 template <typename A>
-uint32_t Section<A>::sectionNum(class Parser<A>& parser) const	
-{ 
+uint32_t Section<A>::sectionNum(class Parser<A>& parser) const
+{
 	if ( _machOSection == NULL )
 		return 0;
 	else
@@ -4474,16 +4474,16 @@
 }
 
 // arm does not have zero cost exceptions
-template <> 
-uint32_t CFISection<arm>::cfiCount(Parser<arm>& parser) 
+template <>
+uint32_t CFISection<arm>::cfiCount(Parser<arm>& parser)
 {
 	if ( parser.armUsesZeroCostExceptions() ) {
 		// create ObjectAddressSpace object for use by libunwind
 		OAS oas(*this, (uint8_t*)this->file().fileContent()+this->_machOSection->offset());
-		return libunwind::CFI_Parser<OAS>::getCFICount(oas, 
+		return libunwind::CFI_Parser<OAS>::getCFICount(oas,
 											this->_machOSection->addr(), this->_machOSection->size());
 	}
-	return 0; 
+	return 0;
 }
 
 template <typename A>
@@ -4491,7 +4491,7 @@
 {
 	// create ObjectAddressSpace object for use by libunwind
 	OAS oas(*this, (uint8_t*)this->file().fileContent()+this->_machOSection->offset());
-	return libunwind::CFI_Parser<OAS>::getCFICount(oas, 
+	return libunwind::CFI_Parser<OAS>::getCFICount(oas,
 										this->_machOSection->addr(), this->_machOSection->size());
 }
 
@@ -4499,7 +4499,7 @@
 void CFISection<A>::warnFunc(void* ref, uint64_t funcAddr, const char* msg)
 {
 	Parser<A>* parser = (Parser<A>*)ref;
-	if ( ! parser->warnUnwindConversionProblems() ) 
+	if ( ! parser->warnUnwindConversionProblems() )
 		return;
 	if ( funcAddr != CFI_INVALID_ADDRESS ) {
 		// atoms are not constructed yet, so scan symbol table for labels
@@ -4545,7 +4545,7 @@
 	for (const macho_relocation_info<P>* reloc = relocs; reloc < relocsEnd; ++reloc) {
 		uint64_t value = 0;
 		switch ( reloc->r_type() ) {
-			case X86_64_RELOC_SUBTRACTOR:	
+			case X86_64_RELOC_SUBTRACTOR:
 				value =  0 - parser.symbolFromIndex(reloc->r_symbolnum()).n_value();
 				++reloc;
 				if ( reloc->r_extern() )
@@ -4581,35 +4581,35 @@
 				break;
 		}
 	}
-	
+
 	// create ObjectAddressSpace object for use by libunwind
 	OAS oas(*this, buffer);
-	
+
 	// use libuwind to parse __eh_frame data into array of CFI_Atom_Info
 	const char* msg;
 	msg = libunwind::DwarfInstructions<OAS, libunwind::Registers_x86_64>::parseCFIs(
-							oas, this->_machOSection->addr(), this->_machOSection->size(), 
-							cuStarts, cuCount, parser.keepDwarfUnwind(), parser.forceDwarfConversion(), parser.neverConvertDwarf(), 
+							oas, this->_machOSection->addr(), this->_machOSection->size(),
+							cuStarts, cuCount, parser.keepDwarfUnwind(), parser.forceDwarfConversion(), parser.neverConvertDwarf(),
 							cfiArray, count, (void*)&parser, warnFunc);
-	if ( msg != NULL ) 
+	if ( msg != NULL )
 		throwf("malformed __eh_frame section: %s", msg);
 }
 
 template <>
-void CFISection<x86>::cfiParse(class Parser<x86>& parser, uint8_t* buffer, 
+void CFISection<x86>::cfiParse(class Parser<x86>& parser, uint8_t* buffer,
 									libunwind::CFI_Atom_Info<CFISection<x86>::OAS> cfiArray[],
 									uint32_t& count, const pint_t cuStarts[], uint32_t cuCount)
 {
 	// create ObjectAddressSpace object for use by libunwind
 	OAS oas(*this, (uint8_t*)this->file().fileContent()+this->_machOSection->offset());
-	
+
 	// use libuwind to parse __eh_frame data into array of CFI_Atom_Info
 	const char* msg;
 	msg = libunwind::DwarfInstructions<OAS, libunwind::Registers_x86>::parseCFIs(
-							oas, this->_machOSection->addr(), this->_machOSection->size(), 
+							oas, this->_machOSection->addr(), this->_machOSection->size(),
 							cuStarts, cuCount, parser.keepDwarfUnwind(), parser.forceDwarfConversion(), parser.neverConvertDwarf(),
 							cfiArray, count, (void*)&parser, warnFunc);
-	if ( msg != NULL ) 
+	if ( msg != NULL )
 		throwf("malformed __eh_frame section: %s", msg);
 }
 
@@ -4617,7 +4617,7 @@
 
 
 template <>
-void CFISection<arm>::cfiParse(class Parser<arm>& parser, uint8_t* buffer, 
+void CFISection<arm>::cfiParse(class Parser<arm>& parser, uint8_t* buffer,
 									libunwind::CFI_Atom_Info<CFISection<arm>::OAS> cfiArray[],
 									uint32_t& count, const pint_t cuStarts[], uint32_t cuCount)
 {
@@ -4628,21 +4628,21 @@
 	}
 	// create ObjectAddressSpace object for use by libunwind
 	OAS oas(*this, (uint8_t*)this->file().fileContent()+this->_machOSection->offset());
-	
+
 	// use libuwind to parse __eh_frame data into array of CFI_Atom_Info
 	const char* msg;
 	msg = libunwind::DwarfInstructions<OAS, libunwind::Registers_arm>::parseCFIs(
-							oas, this->_machOSection->addr(), this->_machOSection->size(), 
+							oas, this->_machOSection->addr(), this->_machOSection->size(),
 							cuStarts, cuCount, parser.keepDwarfUnwind(), parser.forceDwarfConversion(), parser.neverConvertDwarf(),
 							cfiArray, count, (void*)&parser, warnFunc);
-	if ( msg != NULL ) 
+	if ( msg != NULL )
 		throwf("malformed __eh_frame section: %s", msg);
 }
 
 
 
 template <>
-void CFISection<arm64>::cfiParse(class Parser<arm64>& parser, uint8_t* buffer, 
+void CFISection<arm64>::cfiParse(class Parser<arm64>& parser, uint8_t* buffer,
 									libunwind::CFI_Atom_Info<CFISection<arm64>::OAS> cfiArray[],
 									uint32_t& count, const pint_t cuStarts[], uint32_t cuCount)
 {
@@ -4656,11 +4656,11 @@
 	for (const macho_relocation_info<P>* reloc = relocs; reloc < relocsEnd; ++reloc) {
 		uint64_t* p64 = (uint64_t*)&buffer[reloc->r_address()];
 		uint32_t* p32 = (uint32_t*)&buffer[reloc->r_address()];
-		uint32_t addend32 = E::get32(*p32); 
-		uint64_t addend64 = E::get64(*p64); 
+		uint32_t addend32 = E::get32(*p32);
+		uint64_t addend64 = E::get64(*p64);
 		uint64_t value = 0;
 		switch ( reloc->r_type() ) {
-			case ARM64_RELOC_SUBTRACTOR:	
+			case ARM64_RELOC_SUBTRACTOR:
 				value =  0 - parser.symbolFromIndex(reloc->r_symbolnum()).n_value();
 				++reloc;
 				if ( reloc->r_extern() )
@@ -4694,26 +4694,26 @@
 				break;
 		}
 	}
-	
-	
+
+
 	// create ObjectAddressSpace object for use by libunwind
 	OAS oas(*this, buffer);
-	
+
 	// use libuwind to parse __eh_frame data into array of CFI_Atom_Info
 	const char* msg;
 	msg = libunwind::DwarfInstructions<OAS, libunwind::Registers_arm64>::parseCFIs(
-							oas, this->_machOSection->addr(), this->_machOSection->size(), 
+							oas, this->_machOSection->addr(), this->_machOSection->size(),
 							cuStarts, cuCount, parser.keepDwarfUnwind(), parser.forceDwarfConversion(), parser.neverConvertDwarf(),
 							cfiArray, count, (void*)&parser, warnFunc);
-	if ( msg != NULL ) 
+	if ( msg != NULL )
 		throwf("malformed __eh_frame section: %s", msg);
 }
 
 
 
 template <typename A>
-uint32_t CFISection<A>::computeAtomCount(class Parser<A>& parser, 
-											struct Parser<A>::LabelAndCFIBreakIterator& it, 
+uint32_t CFISection<A>::computeAtomCount(class Parser<A>& parser,
+											struct Parser<A>::LabelAndCFIBreakIterator& it,
 											const struct Parser<A>::CFI_CU_InfoArrays& cfis)
 {
 	return cfis.cfiCount;
@@ -4722,8 +4722,8 @@
 
 
 template <typename A>
-uint32_t CFISection<A>::appendAtoms(class Parser<A>& parser, uint8_t* p, 
-									struct Parser<A>::LabelAndCFIBreakIterator& it, 
+uint32_t CFISection<A>::appendAtoms(class Parser<A>& parser, uint8_t* p,
+									struct Parser<A>::LabelAndCFIBreakIterator& it,
 									const struct Parser<A>::CFI_CU_InfoArrays& cfis)
 {
 	this->_beginAtoms = (Atom<A>*)p;
@@ -4732,9 +4732,9 @@
 	const CFI_Atom_Info* end   = &cfis.cfiArray[cfis.cfiCount];
 	for(const CFI_Atom_Info* a=start; a < end; ++a) {
 		Atom<A>* space = (Atom<A>*)p;
-		new (space) Atom<A>(*this, (a->isCIE ? "CIE" : "FDE"), a->address, a->size, 
+		new (space) Atom<A>(*this, (a->isCIE ? "CIE" : "FDE"), a->address, a->size,
 										ld::Atom::definitionRegular, ld::Atom::combineNever, ld::Atom::scopeTranslationUnit,
-										ld::Atom::typeCFI, ld::Atom::symbolTableNotInFinalLinkedImages, 
+										ld::Atom::typeCFI, ld::Atom::symbolTableNotInFinalLinkedImages,
 										false, false, false, ld::Atom::Alignment(0));
 		p += sizeof(Atom<A>);
 	}
@@ -4755,7 +4755,7 @@
 	if ( personalityEncoding == 0x9B ) {
 		// compiler always produces X86_64_RELOC_GOT with addend of 4 to personality function
 		// CFISection<x86_64>::cfiParse() set targetAddress to be symbolIndex + 4 + addressInCIE
-		uint32_t symbolIndex = cieInfo->u.cieInfo.personality.targetAddress - 4 
+		uint32_t symbolIndex = cieInfo->u.cieInfo.personality.targetAddress - 4
 									- cieInfo->address - cieInfo->u.cieInfo.personality.offsetInCFI;
 		const macho_nlist<P>& sym = parser.symbolFromIndex(symbolIndex);
 		const char* personalityName = parser.nameFromSymbol(sym);
@@ -4767,7 +4767,7 @@
 		parser.addFixup(src, ld::Fixup::k3of3, ld::Fixup::kindStoreX86PCRel32GOT);
 	}
 	else if ( personalityEncoding != 0 ) {
-		throwf("unsupported address encoding (%02X) of personality function in CIE", 
+		throwf("unsupported address encoding (%02X) of personality function in CIE",
 				personalityEncoding);
 	}
 }
@@ -4802,7 +4802,7 @@
 	if ( personalityEncoding == 0x9B ) {
 		// compiler always produces ARM64_RELOC_GOT r_pcrel=1 to personality function
 		// CFISection<arm64>::cfiParse() set targetAddress to be symbolIndex + addressInCIE
-		uint32_t symbolIndex = cieInfo->u.cieInfo.personality.targetAddress 
+		uint32_t symbolIndex = cieInfo->u.cieInfo.personality.targetAddress
 									- cieInfo->address - cieInfo->u.cieInfo.personality.offsetInCFI;
 		const macho_nlist<P>& sym = parser.symbolFromIndex(symbolIndex);
 		const char* personalityName = parser.nameFromSymbol(sym);
@@ -4813,7 +4813,7 @@
 		parser.addFixup(src, ld::Fixup::k2of2, ld::Fixup::kindStoreARM64PCRelToGOT);
 	}
 	else if ( personalityEncoding != 0 ) {
-		throwf("unsupported address encoding (%02X) of personality function in CIE", 
+		throwf("unsupported address encoding (%02X) of personality function in CIE",
 				personalityEncoding);
 	}
 }
@@ -4905,7 +4905,7 @@
 				default:
 					throw "unsupported encoding in FDE of pointer to function";
 			}
-		
+
 			// add reference from FDE to LSDA
 			typename Parser<A>::SourceLocation fdeToLsdaSrc(fdeAtom,  p->u.fdeInfo.lsda.offsetInCFI);
 			if ( lsdaAtom != NULL ) {
@@ -4929,11 +4929,11 @@
 						throw "unsupported encoding in FDE of pointer to LSDA";
 				}
 			}
-			
+
 			// FDE is in group lead by function atom
 			typename Parser<A>::SourceLocation fdeSrc(functionAtom,0);
 			parser.addFixup(fdeSrc, ld::Fixup::k1of1, ld::Fixup::kindNoneGroupSubordinateFDE, fdeAtom);
-			
+
 			// LSDA is in group lead by function atom
 			if ( lsdaAtom != NULL ) {
 				parser.addFixup(fdeSrc, ld::Fixup::k1of1, ld::Fixup::kindNoneGroupSubordinateLSDA, lsdaAtom);
@@ -4963,10 +4963,10 @@
 				}
 			}
 		}
-		throwf("__eh_frame parsing problem.  Can't find target of reference to address 0x%08llX", (uint64_t)addr);
+		throwf("__eh_frame parsing problem.  Can't find target of reference to address 0x%08lX", (uint64_t)addr);
 	}
 }
-		
+
 
 template <typename A>
 uint64_t CFISection<A>::OAS::getULEB128(pint_t& logicalAddr, pint_t end)
@@ -5043,7 +5043,7 @@
 		default:
 			throwf("ObjectFileAddressSpace<A>::getEncodedP() encoding 0x%08X not supported", encoding);
 	}
-	
+
 	// then add relative offset
 	switch ( encoding & 0x70 ) {
 		case DW_EH_PE_absptr:
@@ -5074,7 +5074,7 @@
 //  Instead we skip the dereference and return the address of the pointer.
 //	if ( encoding & DW_EH_PE_indirect )
 //		result = getP(result);
-	
+
 	return result;
 }
 
@@ -5214,7 +5214,7 @@
 template <typename A>
 int CUSection<A>::infoSorter(const void* l, const void* r)
 {
-	// sort references by symbol index, then address 
+	// sort references by symbol index, then address
 	const Info* left = (Info*)l;
 	const Info* right = (Info*)r;
 	if ( left->functionSymbolIndex == right->functionSymbolIndex )
@@ -5245,7 +5245,7 @@
 			info->compactUnwindInfo |= UNWIND_HAS_LSDA;
 		}
 	}
-	
+
 	// scan relocs, extern relocs are needed for personality references (possibly for function/lsda refs??)
 	const uint32_t sectionSize = this->_machOSection->size();
 	if ( this->_machOSection->reloff() > parser.fileLength() )
@@ -5268,7 +5268,7 @@
 			else if ( (reloc->r_address() % sizeof(macho_compact_unwind_entry<P>)) == macho_compact_unwind_entry<P>::lsdaFieldOffset() ) {
 				uint32_t entryIndex = reloc->r_address() / sizeof(macho_compact_unwind_entry<P>);
 				const macho_nlist<P>& lsdaSym = parser.symbolFromIndex(reloc->r_symbolnum());
-				if ( (lsdaSym.n_type() & N_TYPE) == N_SECT ) 
+				if ( (lsdaSym.n_type() & N_TYPE) == N_SECT )
 					array[entryIndex].lsdaAddress = lsdaSym.n_value();
 				else
 					warning("unexpected extern relocation to lsda in __compact_unwind section");
@@ -5289,7 +5289,7 @@
 			}
 		}
 	}
-	
+
 	// sort array by function start address so unwind infos will be contiguous for a given function
 	::qsort(array, cnt, sizeof(Info), infoSorter);
 }
@@ -5300,7 +5300,7 @@
 	const macho_section<P>*	machoSect =	this->machoSection();
 	if ( (machoSect->size() % sizeof(macho_compact_unwind_entry<P>)) != 0 )
 		throw "malformed __LD,__compact_unwind section, bad length";
-		
+
 	return machoSect->size() / sizeof(macho_compact_unwind_entry<P>);
 }
 
@@ -5311,10 +5311,10 @@
 	Info* const arrayEnd = &cus.cuArray[cus.cuCount];
 	for (Info* info=arrayStart; info < arrayEnd; ++info) {
 		// find function atom from address
-		info->function = parser.findAtomByAddress(info->functionStartAddress);	
+		info->function = parser.findAtomByAddress(info->functionStartAddress);
 		// find lsda atom from address
 		if ( info->lsdaAddress != 0 ) {
-			info->lsda = parser.findAtomByAddress(info->lsdaAddress);		
+			info->lsda = parser.findAtomByAddress(info->lsdaAddress);
 			// add lsda subordinate
 			typename Parser<A>::SourceLocation src(info->function, info->functionStartAddress - info->function->objectAddress());
 			parser.addFixup(src, ld::Fixup::k1of1, ld::Fixup::kindNoneGroupSubordinateLSDA, info->lsda);
@@ -5325,12 +5325,12 @@
 			parser.addFixup(src, ld::Fixup::k1of1, ld::Fixup::kindNoneGroupSubordinatePersonality, false, info->personality);
 		}
 	}
-	
+
 }
 
 template <typename A>
 SymboledSection<A>::SymboledSection(Parser<A>& parser, File<A>& f, const macho_section<typename A::P>* s)
-	: Section<A>(f, s), _type(ld::Atom::typeUnclassified) 
+	: Section<A>(f, s), _type(ld::Atom::typeUnclassified)
 {
 	switch ( s->flags() & SECTION_TYPE ) {
 		case S_ZEROFILL:
@@ -5368,7 +5368,7 @@
 
 
 template <typename A>
-bool SymboledSection<A>::dontDeadStrip() 
+bool SymboledSection<A>::dontDeadStrip()
 {
 	switch ( _type ) {
 		case ld::Atom::typeInitializerPointers:
@@ -5386,8 +5386,8 @@
 
 
 template <typename A>
-uint32_t SymboledSection<A>::computeAtomCount(class Parser<A>& parser, 
-												struct Parser<A>::LabelAndCFIBreakIterator& it, 
+uint32_t SymboledSection<A>::computeAtomCount(class Parser<A>& parser,
+												struct Parser<A>::LabelAndCFIBreakIterator& it,
 												const struct Parser<A>::CFI_CU_InfoArrays&)
 {
 	const pint_t startAddr = this->_machOSection->addr();
@@ -5406,7 +5406,7 @@
 }
 
 template <typename A>
-uint32_t SymboledSection<A>::appendAtoms(class Parser<A>& parser, uint8_t* p, 
+uint32_t SymboledSection<A>::appendAtoms(class Parser<A>& parser, uint8_t* p,
 											struct Parser<A>::LabelAndCFIBreakIterator& it,
 											const struct Parser<A>::CFI_CU_InfoArrays&)
 {
@@ -5441,7 +5441,7 @@
 			if ( ctype == ld::Atom::typeLSDA )
 				inclusion = ld::Atom::symbolTableInWithRandomAutoStripLabel;
 			new (allocatedSpace) Atom<A>(*this, "anon", addr, size, ld::Atom::definitionRegular, ld::Atom::combineNever,
-										ld::Atom::scopeTranslationUnit, ctype, inclusion, 
+										ld::Atom::scopeTranslationUnit, ctype, inclusion,
 										this->dontDeadStrip(), false, false, this->alignmentForAddress(addr));
 		}
 		p += sizeof(Atom<A>);
@@ -5468,8 +5468,8 @@
 
 
 template <typename A>
-uint32_t ImplicitSizeSection<A>::computeAtomCount(class Parser<A>& parser, 
-													struct Parser<A>::LabelAndCFIBreakIterator& it, 
+uint32_t ImplicitSizeSection<A>::computeAtomCount(class Parser<A>& parser,
+													struct Parser<A>::LabelAndCFIBreakIterator& it,
 													const struct Parser<A>::CFI_CU_InfoArrays&)
 {
 	uint32_t count = 0;
@@ -5477,7 +5477,7 @@
 	const pint_t startAddr = sect->addr();
 	const pint_t endAddr = startAddr + sect->size();
 	for (pint_t addr = startAddr; addr < endAddr; addr += elementSizeAtAddress(addr) ) {
-		if ( useElementAt(parser, it, addr) ) 
+		if ( useElementAt(parser, it, addr) )
 			++count;
 	}
 	if ( it.fileHasOverlappingSymbols && (sect->size() != 0) && (this->combine(parser, startAddr) == ld::Atom::combineByNameAndContent) ) {
@@ -5490,7 +5490,7 @@
 			const pint_t symbolAddr = sym.n_value();
 			const uint8_t symbolSectNum = sym.n_sect();
 			const bool ignore = this->ignoreLabel(parser.nameFromSymbol(sym));
-			if ( !ignore && !prevIgnore && (symbolAddr == prevSymbolAddr) && (prevSymbolSectNum == symbolSectNum) && (symbolSectNum == this->sectionNum(parser)) ) { 
+			if ( !ignore && !prevIgnore && (symbolAddr == prevSymbolAddr) && (prevSymbolSectNum == symbolSectNum) && (symbolSectNum == this->sectionNum(parser)) ) {
 				++count;
 			}
 			prevSymbolAddr = symbolAddr;
@@ -5502,12 +5502,12 @@
 }
 
 template <typename A>
-uint32_t ImplicitSizeSection<A>::appendAtoms(class Parser<A>& parser, uint8_t* p, 
-											struct Parser<A>::LabelAndCFIBreakIterator& it, 
+uint32_t ImplicitSizeSection<A>::appendAtoms(class Parser<A>& parser, uint8_t* p,
+											struct Parser<A>::LabelAndCFIBreakIterator& it,
 											const struct Parser<A>::CFI_CU_InfoArrays&)
 {
 	this->_beginAtoms = (Atom<A>*)p;
-	
+
 	const macho_section<P>* sect = this->machoSection();
 	const pint_t startAddr = sect->addr();
 	const pint_t endAddr = startAddr + sect->size();
@@ -5525,17 +5525,17 @@
 			allocatedSpace = (Atom<A>*)p;
 			if ( this->ignoreLabel(parser.nameFromSymbol(*foundLabel)) ) {
 				if ( size == 0 ) {
-					// <rdar://problem/10018737> 
-					// a size of zero means there is another label at same location 
+					// <rdar://problem/10018737>
+					// a size of zero means there is another label at same location
 					// and we are supposed to ignore this label
 					skip = true;
 				}
 				else {
 					//fprintf(stderr, "  0x%08llX make annon, size=%lld\n", (uint64_t)foundAddr, (uint64_t)size);
-					new (allocatedSpace) Atom<A>(*this, this->unlabeledAtomName(parser, foundAddr), foundAddr, 
-											this->elementSizeAtAddress(foundAddr), this->definition(), 
-											this->combine(parser, foundAddr), this->scopeAtAddress(parser, foundAddr), 
-											this->contentType(), this->symbolTableInclusion(), 
+					new (allocatedSpace) Atom<A>(*this, this->unlabeledAtomName(parser, foundAddr), foundAddr,
+											this->elementSizeAtAddress(foundAddr), this->definition(),
+											this->combine(parser, foundAddr), this->scopeAtAddress(parser, foundAddr),
+											this->contentType(), this->symbolTableInclusion(),
 											this->dontDeadStrip(), false, false, this->alignmentForAddress(foundAddr));
 				}
 			}
@@ -5557,9 +5557,9 @@
 			if ( this->useElementAt(parser, it, addr) ) {
 				//fprintf(stderr, "  0x%08llX make annon, size=%lld\n", (uint64_t)addr, (uint64_t)elementSizeAtAddress(addr));
 				allocatedSpace = (Atom<A>*)p;
-				new (allocatedSpace) Atom<A>(*this, this->unlabeledAtomName(parser, addr), addr, this->elementSizeAtAddress(addr), 
-											this->definition(), this->combine(parser, addr), this->scopeAtAddress(parser, addr), 
-											this->contentType(), this->symbolTableInclusion(), 
+				new (allocatedSpace) Atom<A>(*this, this->unlabeledAtomName(parser, addr), addr, this->elementSizeAtAddress(addr),
+											this->definition(), this->combine(parser, addr), this->scopeAtAddress(parser, addr),
+											this->contentType(), this->symbolTableInclusion(),
 											this->dontDeadStrip(), false, false, this->alignmentForAddress(addr));
 				++count;
 				p += sizeof(Atom<A>);
@@ -5586,12 +5586,12 @@
 }
 
 template <typename A>
-bool Literal4Section<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+bool Literal4Section<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const
 {
 	assert(this->type() == rhs.section().type());
 	const uint32_t* literalContent = (uint32_t*)atom->contentPointer();
-	
+
 	const Atom<A>* rhsAtom = dynamic_cast<const Atom<A>*>(&rhs);
 	assert(rhsAtom != NULL);
 	if ( rhsAtom != NULL ) {
@@ -5625,14 +5625,14 @@
 }
 
 template <typename A>
-bool Literal8Section<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+bool Literal8Section<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const
 {
 	if ( rhs.section().type() != ld::Section::typeLiteral8 )
 		return false;
 	assert(this->type() == rhs.section().type());
 	const uint64_t* literalContent = (uint64_t*)atom->contentPointer();
-	
+
 	const Atom<A>* rhsAtom = dynamic_cast<const Atom<A>*>(&rhs);
 	assert(rhsAtom != NULL);
 	if ( rhsAtom != NULL ) {
@@ -5660,14 +5660,14 @@
 }
 
 template <typename A>
-bool Literal16Section<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+bool Literal16Section<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const
 {
 	if ( rhs.section().type() != ld::Section::typeLiteral16 )
 		return false;
 	assert(this->type() == rhs.section().type());
 	const uint64_t* literalContent = (uint64_t*)atom->contentPointer();
-	
+
 	const Atom<A>* rhsAtom = dynamic_cast<const Atom<A>*>(&rhs);
 	assert(rhsAtom != NULL);
 	if ( rhsAtom != NULL ) {
@@ -5695,8 +5695,8 @@
 
 template <typename A>
 bool CStringSection<A>::ignoreLabel(const char* label) const
-{ 
-	return (label[0] == 'L') || (label[0] == 'l'); 
+{
+	return (label[0] == 'L') || (label[0] == 'l');
 }
 
 
@@ -5720,7 +5720,7 @@
 
 
 template <typename A>
-bool CStringSection<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+bool CStringSection<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const
 {
 	if ( rhs.section().type() != ld::Section::typeCString )
@@ -5729,7 +5729,7 @@
 	assert(strcmp(this->sectionName(), rhs.section().sectionName())== 0);
 	assert(strcmp(this->segmentName(), rhs.section().segmentName())== 0);
 	const char* stringContent = (char*)atom->contentPointer();
-	
+
 	const Atom<A>* rhsAtom = dynamic_cast<const Atom<A>*>(&rhs);
 	assert(rhsAtom != NULL);
 	if ( rhsAtom != NULL ) {
@@ -5792,7 +5792,7 @@
 			target.addend = (targetAddr - target.atom->objectAddress());
 			// <rdar://problem/8385011> if pointer to thumb function, mask of thumb bit (not an addend of +1)
 			if ( target.atom->isThumb() )
-				target.addend &= (-2); 
+				target.addend &= (-2);
 			assert(src.atom->combine() == ld::Atom::combineNever);
 		}
 		else {
@@ -5819,17 +5819,17 @@
 	uint32_t symIndex = parser.symbolIndexFromIndirectSectionAddress(addr, sect);
 	if ( symIndex == INDIRECT_SYMBOL_LOCAL)
 		return ld::Atom::combineNever;
-		
+
 	// don't coalesce non-lazy-pointers to local symbols
 	const macho_nlist<P>& sym = parser.symbolFromIndex(symIndex);
-	if ( ((sym.n_type() & N_TYPE) == N_SECT) && ((sym.n_type() & N_EXT) == 0) ) 
+	if ( ((sym.n_type() & N_TYPE) == N_SECT) && ((sym.n_type() & N_EXT) == 0) )
 		return ld::Atom::combineNever;
-	
+
 	return ld::Atom::combineByNameAndReferences;
 }
 
 template <typename A>
-const char* NonLazyPointerSection<A>::targetName(const class Atom<A>* atom, const ld::IndirectBindingTable& ind) 
+const char* NonLazyPointerSection<A>::targetName(const class Atom<A>* atom, const ld::IndirectBindingTable& ind)
 {
 	assert(atom->combine() == ld::Atom::combineByNameAndReferences);
 	assert(atom->fixupCount() == 1);
@@ -5864,7 +5864,7 @@
 }
 
 template <typename A>
-bool NonLazyPointerSection<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+bool NonLazyPointerSection<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& indirectBindingTable) const
 {
 	if ( rhs.section().type() != ld::Section::typeNonLazyPointer )
@@ -5883,13 +5883,13 @@
 
 template <typename A>
 ld::Atom::Scope NonLazyPointerSection<A>::scopeAtAddress(Parser<A>& parser, pint_t addr)
-{ 
+{
 	const macho_section<P>* sect = this->machoSection();
 	uint32_t symIndex = parser.symbolIndexFromIndirectSectionAddress(addr, sect);
 	if ( symIndex == INDIRECT_SYMBOL_LOCAL)
 		return ld::Atom::scopeTranslationUnit;
 	else
-		return ld::Atom::scopeLinkageUnit; 
+		return ld::Atom::scopeLinkageUnit;
 }
 
 
@@ -6082,7 +6082,7 @@
 
 
 template <typename A>
-bool CFStringSection<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+bool CFStringSection<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& indirectBindingTable) const
 {
 	if ( atom == &rhs )
@@ -6091,7 +6091,7 @@
 		return false;
 	assert(this->type() == rhs.section().type());
 	assert(strcmp(this->sectionName(), "__cfstring") == 0);
-	
+
 	ContentType thisType;
 	unsigned int charCount;
 	const uint8_t* cstringContent = this->targetContent(atom, indirectBindingTable, &thisType, &charCount);
@@ -6111,9 +6111,9 @@
 		return false;
 
 	// no need to compare content of pointers are already the same
-	if ( cstringContent == rhsStringContent ) 
+	if ( cstringContent == rhsStringContent )
 		return true;
-	
+
 	// no need to compare content if size is different
 	if ( charCount != rhsCharCount )
 		return false;
@@ -6157,7 +6157,7 @@
 	uint32_t classObjcFileOffset = sct->offset() - sct->addr() + addr;
 	const uint8_t* mappedFileContent = this->file().fileContent();
 	pint_t nameAddr = P::getP(*((pint_t*)(mappedFileContent+classObjcFileOffset+2*sizeof(pint_t))));
-	
+
 	// find section containing string address to get string bytes
 	const macho_section<P>* const sections = parser.firstMachOSection();
 	const uint32_t sectionCount = parser.machOSectionCount();
@@ -6222,7 +6222,7 @@
 }
 
 template <typename A>
-bool ObjC2ClassRefsSection<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+bool ObjC2ClassRefsSection<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& indirectBindingTable) const
 {
 	assert(this->type() == rhs.section().type());
@@ -6289,7 +6289,7 @@
 }
 
 template <typename A>
-unsigned long PointerToCStringSection<A>::contentHash(const class Atom<A>* atom, 
+unsigned long PointerToCStringSection<A>::contentHash(const class Atom<A>* atom,
 													const ld::IndirectBindingTable& indirectBindingTable) const
 {
 	// make hash from section name and target cstring name
@@ -6304,7 +6304,7 @@
 }
 
 template <typename A>
-bool PointerToCStringSection<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+bool PointerToCStringSection<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& indirectBindingTable) const
 {
 	assert(this->type() == rhs.section().type());
@@ -6312,8 +6312,8 @@
 	// we only want to coalesce in same section name
 	if ( *this != rhs.section() )
 		return false;
-	
-	// get string content for this 
+
+	// get string content for this
 	const char* cstringContent = this->targetCString(atom, indirectBindingTable);
 	const Atom<A>* rhsAtom = dynamic_cast<const Atom<A>*>(&rhs);
 	assert(rhsAtom !=  NULL);
@@ -6340,7 +6340,7 @@
 }
 
 template <typename A>
-bool UTF16StringSection<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs, 
+bool UTF16StringSection<A>::canCoalesceWith(const class Atom<A>* atom, const ld::Atom& rhs,
 													const ld::IndirectBindingTable& ind) const
 {
 	if ( rhs.section().type() != ld::Section::typeUTF16Strings )
@@ -6386,7 +6386,7 @@
 	Parser<x86_64>::TargetDesc		toTarget;
 	src.atom = this->findAtomByAddress(srcAddr);
 	if ( src.atom == NULL )
-		throwf("malformed mach-o, reloc addr 0x%llX not in any atom", srcAddr);
+		throwf("malformed mach-o, reloc addr 0x%lX not in any atom", srcAddr);
 	src.offsetInAtom = srcAddr - src.atom->_objAddress;
 	const uint8_t* fixUpPtr = file().fileContent() + sect->offset() + reloc->r_address();
 	uint64_t contentValue = 0;
@@ -6456,7 +6456,7 @@
 		case X86_64_RELOC_SIGNED_4:
 			if ( ! reloc->r_pcrel() )
 				throw "not pcrel and X86_64_RELOC_SIGNED* not supported";
-			if ( reloc->r_length() != 2 ) 
+			if ( reloc->r_length() != 2 )
 				throw "length != 2 and X86_64_RELOC_SIGNED* not supported";
 			switch ( reloc->r_type() ) {
 				case X86_64_RELOC_SIGNED:
@@ -6466,12 +6466,12 @@
 					if ( reloc->r_extern() )
 						target.addend += 1;
 					parser.addFixups(src, ld::Fixup::kindStoreX86PCRel32_1, target);
-					break;	
+					break;
 				case X86_64_RELOC_SIGNED_2:
 					if ( reloc->r_extern() )
 						target.addend += 2;
 					parser.addFixups(src, ld::Fixup::kindStoreX86PCRel32_2, target);
-					break;	
+					break;
 				case X86_64_RELOC_SIGNED_4:
 					if ( reloc->r_extern() )
 						target.addend += 4;
@@ -6504,20 +6504,20 @@
 			}
 			break;
 		case X86_64_RELOC_GOT:
-			if ( ! reloc->r_extern() ) 
+			if ( ! reloc->r_extern() )
 				throw "not extern and X86_64_RELOC_GOT not supported";
 			if ( ! reloc->r_pcrel() )
 				throw "not pcrel and X86_64_RELOC_GOT not supported";
-			if ( reloc->r_length() != 2 ) 
+			if ( reloc->r_length() != 2 )
 				throw "length != 2 and X86_64_RELOC_GOT not supported";
 			parser.addFixups(src, ld::Fixup::kindStoreX86PCRel32GOT, target);
 			break;
 		case X86_64_RELOC_GOT_LOAD:
-			if ( ! reloc->r_extern() ) 
+			if ( ! reloc->r_extern() )
 				throw "not extern and X86_64_RELOC_GOT_LOAD not supported";
 			if ( ! reloc->r_pcrel() )
 				throw "not pcrel and X86_64_RELOC_GOT_LOAD not supported";
-			if ( reloc->r_length() != 2 ) 
+			if ( reloc->r_length() != 2 )
 				throw "length != 2 and X86_64_RELOC_GOT_LOAD not supported";
 			parser.addFixups(src, ld::Fixup::kindStoreX86PCRel32GOTLoad, target);
 			break;
@@ -6573,11 +6573,11 @@
 				parser.addFixup(src, ld::Fixup::k4of4, ld::Fixup::kindStoreLittleEndian64);
 			break;
 		case X86_64_RELOC_TLV:
-			if ( ! reloc->r_extern() ) 
+			if ( ! reloc->r_extern() )
 				throw "not extern and X86_64_RELOC_TLV not supported";
 			if ( ! reloc->r_pcrel() )
 				throw "not pcrel and X86_64_RELOC_TLV not supported";
-			if ( reloc->r_length() != 2 ) 
+			if ( reloc->r_length() != 2 )
 				throw "length != 2 and X86_64_RELOC_TLV not supported";
 			parser.addFixups(src, ld::Fixup::kindStoreX86PCRel32TLVLoad, target);
 			break;
@@ -6678,7 +6678,7 @@
 					target.atom = NULL;
 					target.name = parser.nameFromSymbol(sym);
 					target.weakImport = parser.weakImportFromSymbol(sym);
-				}			
+				}
 				target.addend = (int64_t)(int32_t)E::get32(*((uint32_t*)fixUpPtr));
 				if ( reloc->r_pcrel() ) {
 					parser.addFixups(src, ld::Fixup::kindStoreX86PCRel32TLVLoad, target);
@@ -6760,7 +6760,7 @@
 			case GENERIC_RELOC_SECTDIFF:
 			case GENERIC_RELOC_LOCAL_SECTDIFF:
 				{
-					if ( !nextRelocIsPair ) 
+					if ( !nextRelocIsPair )
 						throw "GENERIC_RELOC_SECTDIFF missing following pair";
 					switch ( sreloc->r_length() ) {
 						case 0:
@@ -6826,7 +6826,7 @@
 }
 
 
-	
+
 
 
 #if SUPPORT_ARCH_arm_any
@@ -6844,7 +6844,7 @@
 	Parser<arm>::SourceLocation	src;
 	Parser<arm>::TargetDesc		target;
 	const macho_relocation_info<P>* nextReloc;
-	
+
 	if ( (reloc->r_address() & R_SCATTERED) == 0 ) {
 		bool externSymbolIsThumbDef = false;
 		srcAddr = sect->addr() + reloc->r_address();
@@ -6892,14 +6892,14 @@
 					dstAddr = srcAddr + displacement;
 					parser.findTargetFromAddressAndSectionNum(dstAddr, reloc->r_symbolnum(), target);
 				}
-				// special case "calls" for dtrace 
+				// special case "calls" for dtrace
 				if ( (target.name != NULL) && (strncmp(target.name, "___dtrace_probe$", 16) == 0) ) {
 					parser.addFixup(src, ld::Fixup::k1of1,
 															ld::Fixup::kindStoreARMDtraceCallSiteNop, false, target.name);
 					parser.addDtraceExtraInfos(src, &target.name[16]);
 				}
 				else if ( (target.name != NULL) && (strncmp(target.name, "___dtrace_isenabled$", 20) == 0) ) {
-					parser.addFixup(src, ld::Fixup::k1of1, 
+					parser.addFixup(src, ld::Fixup::k1of1,
 															ld::Fixup::kindStoreARMDtraceIsEnableSiteClear, false, target.name);
 					parser.addDtraceExtraInfos(src, &target.name[20]);
 				}
@@ -6940,14 +6940,14 @@
 				else {
 					parser.findTargetFromAddressAndSectionNum(dstAddr, reloc->r_symbolnum(), target);
 				}
-				// special case "calls" for dtrace 
+				// special case "calls" for dtrace
 				if ( (target.name != NULL) && (strncmp(target.name, "___dtrace_probe$", 16) == 0) ) {
 					parser.addFixup(src, ld::Fixup::k1of1,
 															ld::Fixup::kindStoreThumbDtraceCallSiteNop, false, target.name);
 					parser.addDtraceExtraInfos(src, &target.name[16]);
 				}
 				else if ( (target.name != NULL) && (strncmp(target.name, "___dtrace_isenabled$", 20) == 0) ) {
-					parser.addFixup(src, ld::Fixup::k1of1, 
+					parser.addFixup(src, ld::Fixup::k1of1,
 															ld::Fixup::kindStoreThumbDtraceIsEnableSiteClear, false, target.name);
 					parser.addDtraceExtraInfos(src, &target.name[20]);
 				}
@@ -7130,7 +7130,7 @@
 			case ARM_RELOC_SECTDIFF:
 			case ARM_RELOC_LOCAL_SECTDIFF:
 				{
-					if ( ! nextRelocIsPair ) 
+					if ( ! nextRelocIsPair )
 						throw "ARM_RELOC_SECTDIFF missing following pair";
 					if ( sreloc->r_length() != 2 )
 						throw "bad length for ARM_RELOC_SECTDIFF";
@@ -7150,7 +7150,7 @@
 						src2.offsetInAtom = 0;
 						parser.addFixup(src2, ld::Fixup::k1of1, ld::Fixup::kindNoneGroupSubordinateLSDA, targetAtom);
 					}
-					if ( addend < 0 ) { 
+					if ( addend < 0 ) {
 						// switch binding base on coalescing
 						if ( targetAtom->scope() == ld::Atom::scopeTranslationUnit ) {
 							parser.addFixup(src, ld::Fixup::k1of5, ld::Fixup::kindSetTargetAddress, targetAtom);
@@ -7209,7 +7209,7 @@
 					}
 					if ( sreloc->r_length() & 1 )
 						dstAddr = ((instruction16 << 16) | other16);
-					else 
+					else
 						dstAddr = (other16 << 16) | instruction16;
 					if ( targetAtom->isThumb() )
 						dstAddr &= (-2); // remove thumb bit
@@ -7262,7 +7262,7 @@
 					}
 					if ( sreloc->r_length() & 1 )
 						dstAddr = ((instruction16 << 16) | other16);
-					else 
+					else
 						dstAddr = (other16 << 16) | instruction16;
 					if ( targetAtom->scope() == ld::Atom::scopeTranslationUnit ) {
 						parser.addFixup(src, ld::Fixup::k1of3, ld::Fixup::kindSetTargetAddress, targetAtom);
@@ -7306,7 +7306,7 @@
 	Parser<arm64>::TargetDesc		toTarget;
 	int32_t prefixRelocAddend = 0;
 	if ( reloc->r_type() == ARM64_RELOC_ADDEND ) {
-		uint32_t rawAddend = reloc->r_symbolnum(); 
+		uint32_t rawAddend = reloc->r_symbolnum();
 		prefixRelocAddend = rawAddend;
 		if ( rawAddend & 0x00800000 )
 			prefixRelocAddend |= 0xFF000000; // sign extend 24-bit signed int to 32-bits
@@ -7391,7 +7391,7 @@
 		case ARM64_RELOC_BRANCH26:
 			if ( ! reloc->r_pcrel() )
 				throw "not pcrel and ARM64_RELOC_BRANCH26 not supported";
-			if ( ! reloc->r_extern() ) 
+			if ( ! reloc->r_extern() )
 				throw "r_extern == 0 and ARM64_RELOC_BRANCH26 not supported";
 			if ( reloc->r_length() != 2 )
 				throw "r_length != 2 and ARM64_RELOC_BRANCH26 not supported";
@@ -7422,9 +7422,9 @@
 		case ARM64_RELOC_PAGE21:
 			if ( ! reloc->r_pcrel() )
 				throw "not pcrel and ARM64_RELOC_PAGE21 not supported";
-			if ( ! reloc->r_extern() ) 
+			if ( ! reloc->r_extern() )
 				throw "r_extern == 0 and ARM64_RELOC_PAGE21 not supported";
-			if ( reloc->r_length() != 2 ) 
+			if ( reloc->r_length() != 2 )
 				throw "length != 2 and ARM64_RELOC_PAGE21 not supported";
 			target.addend = prefixRelocAddend;
 			instruction = contentValue;
@@ -7444,9 +7444,9 @@
 		case ARM64_RELOC_PAGEOFF12:
 			if ( reloc->r_pcrel() )
 				throw "pcrel and ARM64_RELOC_PAGEOFF12 not supported";
-			if ( ! reloc->r_extern() ) 
+			if ( ! reloc->r_extern() )
 				throw "r_extern == 0 and ARM64_RELOC_PAGEOFF12 not supported";
-			if ( reloc->r_length() != 2 ) 
+			if ( reloc->r_length() != 2 )
 				throw "length != 2 and ARM64_RELOC_PAGEOFF12 not supported";
 			target.addend = prefixRelocAddend;
 			instruction = contentValue;
@@ -7472,7 +7472,7 @@
 					warning("pageoff12 instruction at 0x%08X has embedded addend. ARM64_RELOC_ADDEND should be used instead", reloc->r_address());
 					target.addend = encodedAddend;
 				}
-				else {	
+				else {
 					throwf("pageoff12 instruction at 0x%08X has embedded addend and ARM64_RELOC_ADDEND also used", reloc->r_address());
 				}
 			}
@@ -7481,9 +7481,9 @@
 		case ARM64_RELOC_GOT_LOAD_PAGE21:
 			if ( ! reloc->r_pcrel() )
 				throw "not pcrel and ARM64_RELOC_GOT_LOAD_PAGE21 not supported";
-			if ( ! reloc->r_extern() ) 
+			if ( ! reloc->r_extern() )
 				throw "r_extern == 0 and ARM64_RELOC_GOT_LOAD_PAGE21 not supported";
-			if ( reloc->r_length() != 2 ) 
+			if ( reloc->r_length() != 2 )
 				throw "length != 2 and ARM64_RELOC_GOT_LOAD_PAGE21 not supported";
 			if ( prefixRelocAddend != 0 )
 				throw "ARM64_RELOC_ADDEND followed by ARM64_RELOC_GOT_LOAD_PAGE21 not supported";
@@ -7496,9 +7496,9 @@
 		case ARM64_RELOC_GOT_LOAD_PAGEOFF12:
 			if ( reloc->r_pcrel() )
 				throw "pcrel and ARM64_RELOC_GOT_LOAD_PAGEOFF12 not supported";
-			if ( ! reloc->r_extern() ) 
+			if ( ! reloc->r_extern() )
 				throw "r_extern == 0 and ARM64_RELOC_GOT_LOAD_PAGEOFF12 not supported";
-			if ( reloc->r_length() != 2 ) 
+			if ( reloc->r_length() != 2 )
 				throw "length != 2 and ARM64_RELOC_GOT_LOAD_PAGEOFF12 not supported";
 			if ( prefixRelocAddend != 0 )
 				throw "ARM64_RELOC_ADDEND followed by ARM64_RELOC_GOT_LOAD_PAGEOFF12 not supported";
@@ -7509,9 +7509,9 @@
 		case ARM64_RELOC_TLVP_LOAD_PAGE21:
 			if ( ! reloc->r_pcrel() )
 				throw "not pcrel and ARM64_RELOC_TLVP_LOAD_PAGE21 not supported";
-			if ( ! reloc->r_extern() ) 
+			if ( ! reloc->r_extern() )
 				throw "r_extern == 0 and ARM64_RELOC_TLVP_LOAD_PAGE21 not supported";
-			if ( reloc->r_length() != 2 ) 
+			if ( reloc->r_length() != 2 )
 				throw "length != 2 and ARM64_RELOC_TLVP_LOAD_PAGE21 not supported";
 			if ( prefixRelocAddend != 0 )
 				throw "ARM64_RELOC_ADDEND followed by ARM64_RELOC_TLVP_LOAD_PAGE21 not supported";
@@ -7524,9 +7524,9 @@
 		case ARM64_RELOC_TLVP_LOAD_PAGEOFF12:
 			if ( reloc->r_pcrel() )
 				throw "pcrel and ARM64_RELOC_TLVP_LOAD_PAGEOFF12 not supported";
-			if ( ! reloc->r_extern() ) 
+			if ( ! reloc->r_extern() )
 				throw "r_extern == 0 and ARM64_RELOC_TLVP_LOAD_PAGEOFF12 not supported";
-			if ( reloc->r_length() != 2 ) 
+			if ( reloc->r_length() != 2 )
 				throw "length != 2 and ARM64_RELOC_TLVP_LOAD_PAGEOFF12 not supported";
 			if ( prefixRelocAddend != 0 )
 				throw "ARM64_RELOC_ADDEND followed by ARM64_RELOC_TLVP_LOAD_PAGEOFF12 not supported";
@@ -7588,17 +7588,17 @@
 				parser.addFixup(src, ld::Fixup::k4of4, ld::Fixup::kindStoreLittleEndian64);
 			break;
         case ARM64_RELOC_POINTER_TO_GOT:
-			if ( ! reloc->r_extern() ) 
+			if ( ! reloc->r_extern() )
 				throw "r_extern == 0 and ARM64_RELOC_POINTER_TO_GOT not supported";
 			if ( prefixRelocAddend != 0 )
 				throw "ARM64_RELOC_ADDEND followed by ARM64_RELOC_POINTER_TO_GOT not supported";
  			if ( reloc->r_pcrel() ) {
-                if ( reloc->r_length() != 2 ) 
+                if ( reloc->r_length() != 2 )
                     throw "r_length != 2 and r_extern = 1 and ARM64_RELOC_POINTER_TO_GOT not supported";
                 parser.addFixups(src, ld::Fixup::kindStoreARM64PCRelToGOT, target);
             }
             else {
-                if ( reloc->r_length() != 3 ) 
+                if ( reloc->r_length() != 3 )
                     throw "r_length != 3 and r_extern = 0 and ARM64_RELOC_POINTER_TO_GOT not supported";
                 parser.addFixups(src, ld::Fixup::kindStoreARM64PointerToGOT, target);
             }
@@ -7662,7 +7662,7 @@
 {
 	// inherited
 	FixedSizeSection<A>::addRelocFixup(parser, reloc);
-	
+
 	assert(0 && "needs template specialization");
 	return false;
 }
@@ -7674,7 +7674,7 @@
 	if ( ((reloc->r_address() & R_SCATTERED) == 0) && (reloc->r_type() == GENERIC_RELOC_VANILLA) ) {
 		assert( reloc->r_length() == 2 );
 		assert( ! reloc->r_pcrel() );
-		
+
 		const macho_section<P>* sect = this->machoSection();
 		Parser<x86>::SourceLocation	src;
 		uint32_t srcAddr = sect->addr() + reloc->r_address();
@@ -7685,14 +7685,14 @@
 			const uint8_t* fixUpPtr = file().fileContent() + sect->offset() + reloc->r_address();
 			uint32_t contentValue = LittleEndian::get32(*((uint32_t*)fixUpPtr));
 			parser.findTargetFromAddressAndSectionNum(contentValue, reloc->r_symbolnum(), stringTarget);
-			
+
 			assert(stringTarget.atom != NULL);
 			assert(stringTarget.atom->contentType() == ld::Atom::typeCString);
 			const char* superClassBaseName = (char*)stringTarget.atom->rawContentPointer();
 			char* superClassName = new char[strlen(superClassBaseName) + 20];
 			strcpy(superClassName, ".objc_class_name_");
 			strcat(superClassName, superClassBaseName);
-			
+
 			parser.addFixup(src, ld::Fixup::k1of1, ld::Fixup::kindSetTargetAddress, false, superClassName);
 		}
 	}
@@ -7707,7 +7707,7 @@
 {
 	// inherited
 	PointerToCStringSection<A>::addRelocFixup(parser, reloc);
-	
+
 	assert(0 && "needs template specialization");
 	return false;
 }
@@ -7722,7 +7722,7 @@
 	assert( reloc->r_type() == GENERIC_RELOC_VANILLA );
 	assert( reloc->r_length() == 2 );
 	assert( ! reloc->r_pcrel() );
-	
+
 	const macho_section<P>* sect = this->machoSection();
 	Parser<x86>::SourceLocation	src;
 	uint32_t srcAddr = sect->addr() + reloc->r_address();
@@ -7732,7 +7732,7 @@
 	const uint8_t* fixUpPtr = file().fileContent() + sect->offset() + reloc->r_address();
 	uint32_t contentValue = LittleEndian::get32(*((uint32_t*)fixUpPtr));
 	parser.findTargetFromAddressAndSectionNum(contentValue, reloc->r_symbolnum(), stringTarget);
-	
+
 	assert(stringTarget.atom != NULL);
 	assert(stringTarget.atom->contentType() == ld::Atom::typeCString);
 	const char* baseClassName = (char*)stringTarget.atom->rawContentPointer();
@@ -7764,7 +7764,7 @@
 			if ( count != 3 )
 				warning("arm64 Linker Optimiztion Hint %d has wrong number of arguments", kind);
 	}
-	
+
 	// pick lowest address in tuple for use as offsetInAtom
 	uint64_t lowestAddress = addrs[0];
 	for(int i=1; i < count; ++i) {
@@ -7777,24 +7777,24 @@
 	const uint64_t atomEndAddr = atomStartAddr + inAtom->size();
 	for(int i=0; i < count; ++i) {
 		if ( (addrs[i] < atomStartAddr) || (addrs[i] >= atomEndAddr) ) {
-			warning("arm64 Linker Optimiztion Hint addresses are not in same atom: 0x%08llX and 0x%08llX",
+			warning("arm64 Linker Optimiztion Hint addresses are not in same atom: 0x%08lX and 0x%08lX",
 				lowestAddress, addrs[i]);
 			return; // skip this LOH
 		}
 		if ( (addrs[i] & 0x3) != 0 ) {
-			warning("arm64 Linker Optimiztion Hint address is not 4-byte aligned: 0x%08llX", addrs[i]);
+			warning("arm64 Linker Optimiztion Hint address is not 4-byte aligned: 0x%08lX", addrs[i]);
 			return; // skip this LOH
 		}
 		if ( (addrs[i] - lowestAddress) > 0xFFFF ) {
 			if ( parser.verboseOptimizationHints() ) {
-				warning("arm64 Linker Optimiztion Hint addresses are too far apart: 0x%08llX and 0x%08llX",
+				warning("arm64 Linker Optimiztion Hint addresses are too far apart: 0x%08lX and 0x%08lX",
 					lowestAddress, addrs[i]);
 			}
 			return; // skip this LOH
 		}
 	}
-	
-	// encoded kind, count, and address deltas in 64-bit addend 
+
+	// encoded kind, count, and address deltas in 64-bit addend
 	ld::Fixup::LOH_arm64 extra;
 	extra.addend = 0;
 	extra.info.kind = kind;
@@ -7831,7 +7831,7 @@
 			throwf("in section %s,%s reloc %u: %s", sect->segname(), Section<A>::makeSectionName(sect), r, msg);
 		}
 	}
-	
+
 	// add follow-on fixups if .o file is missing .subsections_via_symbols
 	if ( this->addFollowOnFixups() ) {
 		Atom<A>* end = &_endAtoms[-1];
@@ -7906,7 +7906,7 @@
 						kind = ld::Fixup::kindDataInCodeStartJT32;
 					else if ( strncmp(&symbolName[8], "jta32$", 4) == 0 )
 						kind = ld::Fixup::kindDataInCodeStartJTA32;
-					else 
+					else
 						warning("unknown L$start$ label %s in file %s", symbolName, this->file().path());
 					if ( kind != ld::Fixup::kindNone ) {
 						Atom<A>* inAtom = parser.findAtomByAddress(sym.n_value());
@@ -7917,7 +7917,7 @@
 			}
 		}
 	}
-	
+
 	// <rdar://problem/11150575> Handle LC_DATA_IN_CODE in object files
 	if ( this->type() == ld::Section::typeCode ) {
 		const pint_t startAddr = this->_machOSection->addr();
@@ -7954,7 +7954,7 @@
 			}
 		}
 	}
-	
+
 	// <rdar://problem/11945700> convert linker optimization hints into internal format
 	if ( this->type() == ld::Section::typeCode && parser.hasOptimizationHints() ) {
 		const pint_t startAddr = this->_machOSection->addr();
@@ -7990,8 +7990,8 @@
 			}
 		}
 	}
-	
-	
+
+
 	// add follow-on fixups for aliases
 	if ( _hasAliases ) {
 		for(Atom<A>* p = _beginAtoms; p < _endAtoms; ++p) {
@@ -8011,7 +8011,7 @@
 //
 // main function used by linker to instantiate ld::Files
 //
-ld::relocatable::File* parse(const uint8_t* fileContent, uint64_t fileLength, 
+ld::relocatable::File* parse(const uint8_t* fileContent, uint64_t fileLength,
 							 const char* path, time_t modTime, ld::File::Ordinal ordinal, const ParserOptions& opts)
 {
 	switch ( opts.architecture ) {
@@ -8095,7 +8095,7 @@
 		return true;
 	}
 	return false;
-}					
+}
 
 //
 // used by linker is error messages to describe bad .o file
@@ -8121,7 +8121,7 @@
 
 //
 // Used by archive reader when -ObjC option is specified
-//	
+//
 bool hasObjC2Categories(const uint8_t* fileContent)
 {
 	if ( mach_o::relocatable::Parser<x86_64>::validFile(fileContent) ) {
@@ -8139,11 +8139,11 @@
     }
 #endif
 	return false;
-}				
+}
 
 //
 // Used by archive reader when -ObjC option is specified
-//	
+//
 bool hasObjC1Categories(const uint8_t* fileContent)
 {
 	if ( mach_o::relocatable::Parser<x86>::validFile(fileContent, false, 0) ) {
diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/passes/branch_island.cpp cctools-port-format/cctools/ld64/src/ld/passes/branch_island.cpp
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/passes/branch_island.cpp	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/passes/branch_island.cpp	2020-11-26 19:29:46.918874452 -0800
@@ -67,8 +67,8 @@
 public:
 											ARM64BranchIslandAtom(const char* nm, const ld::Atom* target, TargetAndOffset finalTarget)
 				: ld::Atom(_s_text_section, ld::Atom::definitionRegular, ld::Atom::combineNever,
-							ld::Atom::scopeLinkageUnit, ld::Atom::typeBranchIsland, 
-							ld::Atom::symbolTableIn, false, false, false, ld::Atom::Alignment(2)), 
+							ld::Atom::scopeLinkageUnit, ld::Atom::typeBranchIsland,
+							ld::Atom::symbolTableIn, false, false, false, ld::Atom::Alignment(2)),
 				_name(nm),
 				_fixup1(0, ld::Fixup::k1of1, ld::Fixup::kindStoreTargetAddressARM64Branch26, target),
 				_fixup2(0, ld::Fixup::k1of1, ld::Fixup::kindIslandTarget, finalTarget.atom) {
@@ -99,12 +99,12 @@
 public:
 											ARMtoARMBranchIslandAtom(const char* nm, const ld::Atom* target, TargetAndOffset finalTarget)
 				: ld::Atom(_s_text_section, ld::Atom::definitionRegular, ld::Atom::combineNever,
-							ld::Atom::scopeLinkageUnit, ld::Atom::typeBranchIsland, 
-							ld::Atom::symbolTableIn, false, false, false, ld::Atom::Alignment(2)), 
+							ld::Atom::scopeLinkageUnit, ld::Atom::typeBranchIsland,
+							ld::Atom::symbolTableIn, false, false, false, ld::Atom::Alignment(2)),
 				_name(nm),
 				_fixup1(0, ld::Fixup::k1of1, ld::Fixup::kindStoreTargetAddressARMBranch24, target),
 				_fixup2(0, ld::Fixup::k1of1, ld::Fixup::kindIslandTarget, finalTarget.atom) {
-					if (_s_log) fprintf(stderr, "%p: ARM-to-ARM branch island to final target %s\n", 
+					if (_s_log) fprintf(stderr, "%p: ARM-to-ARM branch island to final target %s\n",
 										this, finalTarget.atom->name());
 				}
 
@@ -131,11 +131,11 @@
 public:
 											ARMtoThumb1BranchIslandAtom(const char* nm, const ld::Atom* target, TargetAndOffset finalTarget)
 				: ld::Atom(_s_text_section, ld::Atom::definitionRegular, ld::Atom::combineNever,
-							ld::Atom::scopeLinkageUnit, ld::Atom::typeBranchIsland, 
-							ld::Atom::symbolTableIn, false, false, false, ld::Atom::Alignment(2)), 
+							ld::Atom::scopeLinkageUnit, ld::Atom::typeBranchIsland,
+							ld::Atom::symbolTableIn, false, false, false, ld::Atom::Alignment(2)),
 				_name(nm),
 				_finalTarget(finalTarget) {
-					if (_s_log) fprintf(stderr, "%p: ARM-to-thumb1 branch island to final target %s\n", 
+					if (_s_log) fprintf(stderr, "%p: ARM-to-thumb1 branch island to final target %s\n",
 										this, finalTarget.atom->name());
 				}
 
@@ -153,7 +153,7 @@
 		OSWriteLittleInt32(&buffer[ 0], 0, 0xe59fc004);	// 	ldr  ip, pc + 4
 		OSWriteLittleInt32(&buffer[ 4], 0, 0xe08fc00c);	// 	add	 ip, pc, ip
 		OSWriteLittleInt32(&buffer[ 8], 0, 0xe12fff1c);	// 	bx	 ip
-		OSWriteLittleInt32(&buffer[12], 0, displacement);	// 	.long target-this		
+		OSWriteLittleInt32(&buffer[12], 0, displacement);	// 	.long target-this
 	}
 	virtual void							setScope(Scope)					{ }
 
@@ -168,12 +168,12 @@
 public:
 											Thumb2toThumbBranchIslandAtom(const char* nm, const ld::Atom* target, TargetAndOffset finalTarget)
 				: ld::Atom(_s_text_section, ld::Atom::definitionRegular, ld::Atom::combineNever,
-							ld::Atom::scopeLinkageUnit, ld::Atom::typeBranchIsland, 
-							ld::Atom::symbolTableIn, false, true, false, ld::Atom::Alignment(1)), 
+							ld::Atom::scopeLinkageUnit, ld::Atom::typeBranchIsland,
+							ld::Atom::symbolTableIn, false, true, false, ld::Atom::Alignment(1)),
 				_name(nm),
 				_fixup1(0, ld::Fixup::k1of1, ld::Fixup::kindStoreTargetAddressThumbBranch22, target),
-				_fixup2(0, ld::Fixup::k1of1, ld::Fixup::kindIslandTarget, finalTarget.atom)		{ 
-					if (_s_log) fprintf(stderr, "%p: Thumb-to-thumb branch island to final target %s\n", 
+				_fixup2(0, ld::Fixup::k1of1, ld::Fixup::kindIslandTarget, finalTarget.atom)		{
+					if (_s_log) fprintf(stderr, "%p: Thumb-to-thumb branch island to final target %s\n",
 										this, finalTarget.atom->name());
 					}
 
@@ -200,15 +200,15 @@
 public:
 											Thumb2toThumbBranchAbsoluteIslandAtom(const char* nm, const ld::Section& inSect, TargetAndOffset finalTarget)
 				: ld::Atom(inSect, ld::Atom::definitionRegular, ld::Atom::combineNever,
-							ld::Atom::scopeLinkageUnit, ld::Atom::typeBranchIsland, 
-							ld::Atom::symbolTableIn, false, true, false, ld::Atom::Alignment(1)), 
+							ld::Atom::scopeLinkageUnit, ld::Atom::typeBranchIsland,
+							ld::Atom::symbolTableIn, false, true, false, ld::Atom::Alignment(1)),
 				_name(nm),
 				_fixup1(0, ld::Fixup::k1of2, ld::Fixup::kindSetTargetAddress, finalTarget.atom),
 				_fixup2(0, ld::Fixup::k2of2, ld::Fixup::kindStoreThumbLow16),
 				_fixup3(4, ld::Fixup::k1of2, ld::Fixup::kindSetTargetAddress, finalTarget.atom),
 				_fixup4(4, ld::Fixup::k2of2, ld::Fixup::kindStoreThumbHigh16),
 				_fixup5(0, ld::Fixup::k1of1, ld::Fixup::kindIslandTarget, finalTarget.atom) {
-					if (_s_log) fprintf(stderr, "%p: Thumb-to-thumb absolute branch island to final target %s\n", 
+					if (_s_log) fprintf(stderr, "%p: Thumb-to-thumb absolute branch island to final target %s\n",
 										this, finalTarget.atom->name());
 					}
 
@@ -240,11 +240,11 @@
 public:
 											NoPicARMtoThumbMBranchIslandAtom(const char* nm, const ld::Atom* target, TargetAndOffset finalTarget)
 				: ld::Atom(_s_text_section, ld::Atom::definitionRegular, ld::Atom::combineNever,
-							ld::Atom::scopeLinkageUnit, ld::Atom::typeBranchIsland, 
-							ld::Atom::symbolTableIn, false, false, false, ld::Atom::Alignment(2)), 
+							ld::Atom::scopeLinkageUnit, ld::Atom::typeBranchIsland,
+							ld::Atom::symbolTableIn, false, false, false, ld::Atom::Alignment(2)),
 				_name(nm),
 				_finalTarget(finalTarget) {
-					if (_s_log) fprintf(stderr, "%p: NoPIC ARM-to-Thumb branch island to final target %s\n", 
+					if (_s_log) fprintf(stderr, "%p: NoPIC ARM-to-Thumb branch island to final target %s\n",
 										this, finalTarget.atom->name());
 					}
 
@@ -260,7 +260,7 @@
 		if ( _finalTarget.atom->isThumb() )
 			targetAddr |= 1;
 		OSWriteLittleInt32(&buffer[0], 0, 0xe51ff004);	// 	ldr	pc, [pc, #-4]
-		OSWriteLittleInt32(&buffer[4], 0, targetAddr);	// 	.long target-this		
+		OSWriteLittleInt32(&buffer[4], 0, targetAddr);	// 	.long target-this
 	}
 	virtual void							setScope(Scope)					{ }
 
@@ -270,7 +270,7 @@
 };
 
 
-static ld::Atom* makeBranchIsland(const Options& opts, ld::Fixup::Kind kind, int islandRegion, const ld::Atom* nextTarget, 
+static ld::Atom* makeBranchIsland(const Options& opts, ld::Fixup::Kind kind, int islandRegion, const ld::Atom* nextTarget,
 									TargetAndOffset finalTarget, const ld::Section& inSect, bool crossSectionBranch)
 {
 	char* name;
@@ -327,7 +327,7 @@
 		case CPU_TYPE_ARM:
 			if ( ! seenThumbBranch )
 				return 32000000;  // ARM can branch +/- 32MB
-			else if ( opts.preferSubArchitecture() && opts.archSupportsThumb2() ) 
+			else if ( opts.preferSubArchitecture() && opts.archSupportsThumb2() )
 				return 16000000;  // thumb2 can branch +/- 16MB
 			else
 				return  4000000;  // thumb1 can branch +/- 4MB
@@ -349,7 +349,7 @@
 		case CPU_TYPE_ARM:
 			if ( ! seenThumbBranch )
 				return 30*1024*1024;	// 2MB of branch islands per 32MB
-			else if ( opts.preferSubArchitecture() && opts.archSupportsThumb2() ) 
+			else if ( opts.preferSubArchitecture() && opts.archSupportsThumb2() )
 				return 14*1024*1024;	// 2MB of branch islands per 16MB
 			else
 				return 3500000;			// 0.5MB of branch islands per 4MB
@@ -427,7 +427,7 @@
 					haveBranch = true;
 					break;
                 default:
-                    break;   
+                    break;
 			}
 			if ( haveBranch && (target->contentType() != ld::Atom::typeStub) ) {
 				// <rdar://problem/14792124> haveCrossSectionBranches only applies to -preload builds
@@ -443,7 +443,7 @@
 			if ( atomAlign.modulus > currentModulus )
 				offset += atomAlign.modulus-currentModulus;
 			else
-				offset += atomAlign.modulus+atomAlignP2-currentModulus;		
+				offset += atomAlign.modulus+atomAlignP2-currentModulus;
 		}
 		(const_cast<ld::Atom*>(atom))->setSectionOffset(offset);
 		offset += atom->size();
@@ -451,8 +451,8 @@
 	uint64_t totalTextSize = offset + stubCount*16;
 	if ( (totalTextSize < textSizeWhenMightNeedBranchIslands(opts, hasThumbBranches)) && !haveCrossSectionBranches )
 		return;
-	if (_s_log) fprintf(stderr, "ld: section %s size=%llu, might need branch islands\n", textSection->sectionName(), totalTextSize);
-	
+	if (_s_log) fprintf(stderr, "ld: section %s size=%lu, might need branch islands\n", textSection->sectionName(), totalTextSize);
+
 	// Figure out how many regions of branch islands will be needed, and their locations.
 	// Construct a vector containing the atoms after which branch islands will be inserted,
 	// taking into account follow on fixups. No atom run without an island can exceed kBetweenRegions.
@@ -493,10 +493,10 @@
 		regionsMap[i] = new AtomToIsland();
 		regionsIslands[i] = new std::vector<const ld::Atom*>();
 		regionAddresses[i] = branchIslandInsertionPoints[i]->sectionOffset() + branchIslandInsertionPoints[i]->size();
-		if (_s_log) fprintf(stderr, "ld: branch islands will be inserted at 0x%08llX after %s\n", regionAddresses[i], branchIslandInsertionPoints[i]->name());
+		if (_s_log) fprintf(stderr, "ld: branch islands will be inserted at 0x%08lX after %s\n", regionAddresses[i], branchIslandInsertionPoints[i]->name());
 	}
 	unsigned int islandCount = 0;
-	
+
 	// create islands for branches in __text that are out of range
 	for (std::vector<const ld::Atom*>::iterator ait=textSection->atoms.begin(); ait != textSection->atoms.end(); ++ait) {
 		const ld::Atom* atom = *ait;
@@ -539,7 +539,7 @@
 					haveBranch = true;
 					break;
                 default:
-                    break;   
+                    break;
 			}
 			if ( haveBranch ) {
 				bool crossSectionBranch = ( preload && (atom->section() != target->section()) );
@@ -561,7 +561,7 @@
 					if ( pos == region->end() ) {
 						island = makeBranchIsland(opts, fit->kind, 0, target, finalTargetAndOffset, atom->section(), true);
 						(*region)[finalTargetAndOffset] = island;
-						if (_s_log) fprintf(stderr, "added absolute branching island %p %s, displacement=%lld\n", 
+						if (_s_log) fprintf(stderr, "added absolute branching island %p %s, displacement=%ld\n",
 												island, island->name(), displacement);
 						++islandCount;
 						regionsIslands[0]->push_back(island);
@@ -577,12 +577,12 @@
 				else if ( displacement > kBranchLimit ) {
 					// create forward branch chain
 					const ld::Atom* nextTarget = target;
-					if (_s_log) fprintf(stderr, "need forward branching island srcAdr=0x%08llX, dstAdr=0x%08llX, target=%s\n",
+					if (_s_log) fprintf(stderr, "need forward branching island srcAdr=0x%08lX, dstAdr=0x%08lX, target=%s\n",
 														srcAddr, dstAddr, target->name());
 					for (int i=kIslandRegionsCount-1; i >=0 ; --i) {
 						AtomToIsland* region = regionsMap[i];
 						int64_t islandRegionAddr = regionAddresses[i];
-						if ( (srcAddr < islandRegionAddr) && ((islandRegionAddr <= dstAddr)) ) { 
+						if ( (srcAddr < islandRegionAddr) && ((islandRegionAddr <= dstAddr)) ) {
 							AtomToIsland::iterator pos = region->find(finalTargetAndOffset);
 							if ( pos == region->end() ) {
 								ld::Atom* island = makeBranchIsland(opts, fit->kind, i, nextTarget, finalTargetAndOffset, atom->section(), false);
@@ -609,7 +609,7 @@
 						AtomToIsland* region = regionsMap[i];
 						int64_t islandRegionAddr = regionAddresses[i];
 						if ( (dstAddr < islandRegionAddr) && (islandRegionAddr <= srcAddr) ) {
-							if (_s_log) fprintf(stderr, "need backward branching island srcAdr=0x%08llX, dstAdr=0x%08llX, target=%s\n", srcAddr, dstAddr, target->name());
+							if (_s_log) fprintf(stderr, "need backward branching island srcAdr=0x%08lX, dstAdr=0x%08lX, target=%s\n", srcAddr, dstAddr, target->name());
 							AtomToIsland::iterator pos = region->find(finalTargetAndOffset);
 							if ( pos == region->end() ) {
 								ld::Atom* island = makeBranchIsland(opts, fit->kind, i, prevTarget, finalTargetAndOffset, atom->section(), false);
@@ -639,7 +639,7 @@
 		if ( _s_log ) fprintf(stderr, "ld: %u branch islands required in %u regions\n", islandCount, kIslandRegionsCount);
 		std::vector<const ld::Atom*> newAtomList;
 		newAtomList.reserve(textSection->atoms.size()+islandCount);
-		
+
 		int regionIndex = 0;
 		for (std::vector<const ld::Atom*>::iterator ait=textSection->atoms.begin(); ait != textSection->atoms.end(); ait++) {
 			const ld::Atom* atom = *ait;
@@ -662,7 +662,7 @@
 	// Assign addresses to sections
 	state.setSectionSizesAndAlignments();
 	state.assignFileOffsets();
-	
+
 	// Assign addresses to atoms in a side table
 	const bool log = false;
 	if ( log ) fprintf(stderr, "buildAddressMap()\n");
@@ -670,7 +670,7 @@
 		ld::Internal::FinalSection* sect = *sit;
 		uint16_t maxAlignment = 0;
 		uint64_t offset = 0;
-		if ( log ) fprintf(stderr, "  section=%s/%s, address=0x%08llX\n", sect->segmentName(), sect->sectionName(), sect->address);
+		if ( log ) fprintf(stderr, "  section=%s/%s, address=0x%08lX\n", sect->segmentName(), sect->sectionName(), sect->address);
 		for (std::vector<const ld::Atom*>::iterator ait = sect->atoms.begin(); ait != sect->atoms.end(); ++ait) {
 			const ld::Atom* atom = *ait;
 			uint32_t atomAlignmentPowerOf2 = atom->alignment().powerOf2;
@@ -687,27 +687,27 @@
 				else
 					offset += requiredModulus+alignment-currentModulus;
 			}
-			
-			if ( log ) fprintf(stderr, "    0x%08llX atom=%p, name=%s\n", sect->address+offset, atom, atom->name());
+
+			if ( log ) fprintf(stderr, "    0x%08lX atom=%p, name=%s\n", sect->address+offset, atom, atom->name());
 			sAtomToAddress[atom] = sect->address + offset;
-			
+
 			offset += atom->size();
 		}
 	}
 
-	
+
 }
 
 void doPass(const Options& opts, ld::Internal& state)
-{	
+{
 	// only make branch islands in final linked images
 	if ( opts.outputKind() == Options::kObjectFile )
 		return;
-	
+
 	// Allow user to disable branch island generation
 	if ( !opts.allowBranchIslands() )
 		return;
-	
+
 	// only ARM[64] needs branch islands
 	switch ( opts.architecture() ) {
 		case CPU_TYPE_ARM:
@@ -718,11 +718,11 @@
 		default:
 			return;
 	}
-	
+
 	if ( opts.outputKind() == Options::kPreload ) {
 		buildAddressMap(opts, state);
 	}
-	
+
 	// scan sections for number of stubs
 	unsigned stubCount = 0;
 	for (std::vector<ld::Internal::FinalSection*>::iterator sit=state.sections.begin(); sit != state.sections.end(); ++sit) {
@@ -734,12 +734,12 @@
 	// scan sections and add island to each code section
 	for (std::vector<ld::Internal::FinalSection*>::iterator sit=state.sections.begin(); sit != state.sections.end(); ++sit) {
 		ld::Internal::FinalSection* sect = *sit;
-		if ( sect->type() == ld::Section::typeCode ) 
+		if ( sect->type() == ld::Section::typeCode )
 			makeIslandsForSection(opts, state, sect, stubCount);
 	}
 }
 
 
 } // namespace branch_island
-} // namespace passes 
-} // namespace ld 
+} // namespace passes
+} // namespace ld
diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/passes/code_dedup.cpp cctools-port-format/cctools/ld64/src/ld/passes/code_dedup.cpp
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/passes/code_dedup.cpp	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/passes/code_dedup.cpp	2020-11-26 19:27:13.110874452 -0800
@@ -248,7 +248,7 @@
 void doPass(const Options& opts, ld::Internal& state)
 {
 	const bool log = false;
-	
+
 	// only de-duplicate in final linked images
 	if ( opts.outputKind() == Options::kObjectFile )
 		return;
@@ -315,7 +315,7 @@
             continue;
         if ( verbose )  {
             dedupSavings += ((dups.size() - 1) * masterAtom->size());
-            fprintf(stderr, "deduplicate the following %lu functions (%llu bytes apiece):\n", dups.size(), masterAtom->size());
+            fprintf(stderr, "deduplicate the following %lu functions (%lu bytes apiece):\n", dups.size(), masterAtom->size());
         }
         for (const ld::Atom* dupAtom : dups) {
             if ( verbose )
@@ -333,7 +333,7 @@
         }
     }
     if ( verbose )  {
-        fprintf(stderr, "deduplication saved %llu bytes of __text\n", dedupSavings);
+        fprintf(stderr, "deduplication saved %lu bytes of __text\n", dedupSavings);
     }
 
     if ( log ) {
@@ -368,7 +368,7 @@
     if ( log ) {
         fprintf(stderr, "atoms before pruning:\n");
         for (const ld::Atom* atom : textSection->atoms)
-            fprintf(stderr, "  %p (size=%llu) %s\n", atom, atom->size(), atom->name());
+            fprintf(stderr, "  %p (size=%lu) %s\n", atom, atom->size(), atom->name());
     }
     // remove replaced atoms from section
 	textSection->atoms.erase(std::remove_if(textSection->atoms.begin(), textSection->atoms.end(),
@@ -383,7 +383,7 @@
     if ( log ) {
         fprintf(stderr, "atoms after pruning:\n");
         for (const ld::Atom* atom : textSection->atoms)
-            fprintf(stderr, "  %p (size=%llu) %s\n", atom, atom->size(), atom->name());
+            fprintf(stderr, "  %p (size=%lu) %s\n", atom, atom->size(), atom->name());
     }
 
    //fprintf(stderr, "hash-count=%lu, fixup-compares=%lu, atom-count=%u\n", sHashCount, sFixupCompareCount, atomsBeingComparedCount);
@@ -391,5 +391,5 @@
 
 
 } // namespace dedup
-} // namespace passes 
-} // namespace ld 
+} // namespace passes
+} // namespace ld
diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/passes/dtrace_dof.cpp cctools-port-format/cctools/ld64/src/ld/passes/dtrace_dof.cpp
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/passes/dtrace_dof.cpp	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/passes/dtrace_dof.cpp	2020-11-26 19:27:20.942874452 -0800
@@ -64,7 +64,7 @@
 protected:
 	friend class File;
 	virtual									~Atom() {}
-	
+
 	class File&								_file;
 	const char*								_name;
 	const uint8_t*							_content;
@@ -73,17 +73,17 @@
 };
 
 
-class File : public ld::File 
+class File : public ld::File
 {
 public:
-								File(const char* segmentName, const char* sectionName, const char* pth, 
-									const uint8_t fileContent[], uint64_t fileLength, Ordinal ord, 
+								File(const char* segmentName, const char* sectionName, const char* pth,
+									const uint8_t fileContent[], uint64_t fileLength, Ordinal ord,
 									const char* symbolName="dof")
 									: ld::File(pth, 0, ord, Other),
-									  _atom(*this, symbolName, fileContent, fileLength), 
+									  _atom(*this, symbolName, fileContent, fileLength),
 									  _section(segmentName, sectionName, ld::Section::typeDtraceDOF) { }
 	virtual						~File() {}
-	
+
 	virtual bool				forEachAtom(AtomHandler& h) const { h.doAtom(_atom); return true; }
 	virtual bool				justInTimeforEachAtom(const char* name, AtomHandler&) const { return false; }
 
@@ -92,15 +92,15 @@
 	ld::Atom&					atom() { return _atom; }
 private:
 	friend class Atom;
-	
+
 	Atom						_atom;
 	ld::Section					_section;
 };
 
 Atom::Atom(File& f, const char* n,  const uint8_t* content, uint64_t sz)
 	: ld::Atom(f._section, ld::Atom::definitionRegular, ld::Atom::combineNever,
-		ld::Atom::scopeTranslationUnit, ld::Atom::typeUnclassified, 
-		symbolTableNotIn, false, false, false, ld::Atom::Alignment(0)), 
+		ld::Atom::scopeTranslationUnit, ld::Atom::typeUnclassified,
+		symbolTableNotIn, false, false, false, ld::Atom::Alignment(0)),
 		_file(f), _name(strdup(n)), _content(content), _size(sz) {}
 
 
@@ -119,11 +119,11 @@
 void doPass(const Options& opts, ld::Internal& internal)
 {
 	static bool log = false;
-	
+
 	// only make __dof section in final linked images
 	if ( opts.outputKind() == Options::kObjectFile )
 		return;
-	
+
 	// skip making __dof section if command line option said not to
 	if ( ! opts.generateDtraceDOF() )
 		return;
@@ -134,7 +134,7 @@
 	std::map<const ld::Atom*,CStringSet>			atomToDtraceTypes;
 	for (std::vector<ld::Internal::FinalSection*>::iterator sit=internal.sections.begin(); sit != internal.sections.end(); ++sit) {
 		ld::Internal::FinalSection* sect = *sit;
-		if ( sect->type() != ld::Section::typeCode ) 
+		if ( sect->type() != ld::Section::typeCode )
 			continue;
 		for (std::vector<const ld::Atom*>::iterator ait=sect->atoms.begin();  ait != sect->atoms.end(); ++ait) {
 			const ld::Atom* atom = *ait;
@@ -163,9 +163,9 @@
 	}
 
 	// if no probes, we're done
-	if ( (probeSites.size() == 0) && (isEnabledSites.size() == 0) ) 
+	if ( (probeSites.size() == 0) && (isEnabledSites.size() == 0) )
 		return;
-	
+
 	ld::Fixup::Kind storeKind = ld::Fixup::kindNone;
 	switch ( opts.architecture() ) {
 		case CPU_TYPE_I386:
@@ -177,7 +177,7 @@
 		default:
 			throw "unsupported arch for DOF";
 	}
-	
+
 	// partition probes by provider name
 	// The symbol names looks like:
 	//	"___dtrace_probe$" provider-name "$" probe-name [ "$"... ]
@@ -218,7 +218,7 @@
 			providerToProbes[providerName].push_back(*it);
 		}
 	}
-	
+
 	// create a DOF section for each provider
 	int dofIndex=1;
 	CStringSet sectionNamesUsed;
@@ -259,7 +259,7 @@
 			//fprintf(stderr, "\t%s\n", *it);
 			++index;
 		}
-		
+
 		// build list of probe/isenabled sites
 		const uint32_t probeCount = probes.size();
 		const char* probeNames[probeCount];
@@ -275,13 +275,13 @@
 		if ( log ) {
 			fprintf(stderr, "calling libtrace to create DOF:\n");
 			fprintf(stderr, "   types::\n");
-			for(int i=0; i < typeCount; ++i) 
+			for(int i=0; i < typeCount; ++i)
 				fprintf(stderr, "     [%u]\t %s\n", i, typeNames[i]);
 			fprintf(stderr, "   probes::\n");
-			for(uint32_t i=0; i < probeCount; ++i) 
+			for(uint32_t i=0; i < probeCount; ++i)
 				fprintf(stderr, "     [%u]\t %s in %s\n", i, probeNames[i], funtionNames[i]);
 		}
-		
+
 		// call dtrace library to create DOF section
 		size_t dofSectionSize;
 		uint8_t* p = (*pCreateDOF)(opts.architecture(), typeCount, typeNames, probeCount, probeNames, funtionNames, offsetsInDOF, &dofSectionSize);
@@ -310,7 +310,7 @@
 				uint64_t offset = offsetsInDOF[i];
 				//fprintf(stderr, "%s offset[%d]=0x%08llX\n", providerName, i, offset);
 				if ( offset > dofSectionSize )
-					throwf("offsetsInDOF[%d]=%0llX > dofSectionSize=%0lX\n", i, offset, dofSectionSize);
+					throwf("offsetsInDOF[%d]=%0lX > dofSectionSize=%0lX\n", i, offset, dofSectionSize);
 				f->addSectionFixup(ld::Fixup(offset, ld::Fixup::k1of4, ld::Fixup::kindSetTargetAddress, probes[i].atom));
 				f->addSectionFixup(ld::Fixup(offset, ld::Fixup::k2of4, ld::Fixup::kindAddAddend, probes[i].offset));
 				f->addSectionFixup(ld::Fixup(offset, ld::Fixup::k3of4, ld::Fixup::kindSubtractTargetAddress, &f->atom()));
@@ -323,12 +323,12 @@
 			throw "error creating dtrace DOF section";
 		}
 	}
-	
+
 
 
 }
 
 
 } // namespace dtrace
-} // namespace passes 
-} // namespace ld 
+} // namespace passes
+} // namespace ld
diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/passes/huge.cpp cctools-port-format/cctools/ld64/src/ld/passes/huge.cpp
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/passes/huge.cpp	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/passes/huge.cpp	2020-11-26 19:26:56.262874452 -0800
@@ -102,7 +102,7 @@
 	if ( opts.architecture() != CPU_TYPE_X86_64 )
 		return;
 
-	// only needed if some (non-linkedit) atoms have an addresss >2GB from base address 
+	// only needed if some (non-linkedit) atoms have an addresss >2GB from base address
 	state.usingHugeSections = false;
 	uint64_t address = 0;
 	for (std::vector<ld::Internal::FinalSection*>::iterator sit=state.sections.begin(); sit != state.sections.end(); ++sit) {
@@ -115,7 +115,7 @@
 			const ld::Atom* atom = *ait;
 			if ( (address > 0x7FFFFFFFLL) && !sect->isSectionHidden() ) {
 				state.usingHugeSections = true;
-				if (log) fprintf(stderr, "atom: %s is >2GB (0x%09llX), so enabling huge mode\n", atom->name(), address);
+				if (log) fprintf(stderr, "atom: %s is >2GB (0x%09lX), so enabling huge mode\n", atom->name(), address);
 				break;
 			}
 			address += atom->size();
@@ -139,20 +139,20 @@
 				if ( atom->size() > 1024*1024 ) {
 					hugeSection->atoms.push_back(atom);
 					state.atomToSection[atom] = hugeSection;
-					if (log) fprintf(stderr, "moved to __huge: %s, size=%llu\n", atom->name(), atom->size());
+					if (log) fprintf(stderr, "moved to __huge: %s, size=%lu\n", atom->name(), atom->size());
 					*ait = NULL;  // change atom to NULL for later bulk removal
 					movedSome = true;
 				}
 			}
-			if ( movedSome ) 
+			if ( movedSome )
 				sect->atoms.erase(std::remove_if(sect->atoms.begin(), sect->atoms.end(), NullAtom()), sect->atoms.end());
 		}
 	}
 
-	
+
 }
 
 
 } // namespace huge
-} // namespace passes 
-} // namespace ld 
+} // namespace passes
+} // namespace ld
diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/passes/thread_starts.cpp cctools-port-format/cctools/ld64/src/ld/passes/thread_starts.cpp
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/passes/thread_starts.cpp	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/passes/thread_starts.cpp	2020-11-26 19:31:48.474874452 -0800
@@ -132,7 +132,7 @@
 		ld::Internal::FinalSection* sect = *sit;
 		uint16_t maxAlignment = 0;
 		uint64_t offset = 0;
-		if ( log ) fprintf(stderr, "  section=%s/%s, address=0x%08llX\n", sect->segmentName(), sect->sectionName(), sect->address);
+		if ( log ) fprintf(stderr, "  section=%s/%s, address=0x%08lX\n", sect->segmentName(), sect->sectionName(), sect->address);
 		for (std::vector<const ld::Atom*>::iterator ait = sect->atoms.begin(); ait != sect->atoms.end(); ++ait) {
 			const ld::Atom* atom = *ait;
 			uint32_t atomAlignmentPowerOf2 = atom->alignment().powerOf2;
@@ -150,7 +150,7 @@
 					offset += requiredModulus+alignment-currentModulus;
 			}
 
-			if ( log ) fprintf(stderr, "    0x%08llX atom=%p, name=%s\n", sect->address+offset, atom, atom->name());
+			if ( log ) fprintf(stderr, "    0x%08lX atom=%p, name=%s\n", sect->address+offset, atom, atom->name());
 			sAtomToAddress[atom] = sect->address + offset;
 
 			offset += atom->size();
@@ -224,7 +224,7 @@
 						fixupAddressesInSection.push_back(address);
 						//fprintf(stderr, "pointer at 0x%08llX\n", address);
 						if ( (address & (minAlignment-1)) != 0 ) {
-							throwf("pointer not aligned at address 0x%llX (%s + %d from %s)",
+							throwf("pointer not aligned at address 0x%lX (%s + %d from %s)",
 								   address, atom->name(), fit->offsetInAtom, atom->safeFilePath());
 						}
 					}
@@ -325,5 +325,5 @@
 
 
 } // namespace thread_starts
-} // namespace passes 
-} // namespace ld 
+} // namespace passes
+} // namespace ld
diff -ur cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/SymbolTable.cpp cctools-port-format/cctools/ld64/src/ld/SymbolTable.cpp
--- cctools-port-634a084377ee2e2932c66459b0396edf76da2e9f/cctools/ld64/src/ld/SymbolTable.cpp	2020-10-06 23:55:56.000000000 -0700
+++ cctools-port-format/cctools/ld64/src/ld/SymbolTable.cpp	2020-11-26 20:08:43.590874452 -0800
@@ -21,7 +21,7 @@
  *
  * @APPLE_LICENSE_HEADER_END@
  */
- 
+
 
 #include <stdlib.h>
 #include <sys/types.h>
@@ -58,9 +58,9 @@
 static ld::IndirectBindingTable*	_s_indirectBindingTable = NULL;
 
 
-SymbolTable::SymbolTable(const Options& opts, std::vector<const ld::Atom*>& ibt) 
+SymbolTable::SymbolTable(const Options& opts, std::vector<const ld::Atom*>& ibt)
 	: _options(opts), _cstringTable(6151), _indirectBindingTable(ibt), _hasExternalTentativeDefinitions(false)
-{  
+{
 	_s_indirectBindingTable = this;
 }
 
@@ -193,7 +193,7 @@
 	NameCollisionResolution(const ld::Atom& a, const ld::Atom& b, Options::Treatment duplicates, const Options& options) : _atomA(a), _atomB(b), _options(options), _reportDuplicate(false), _duplicates(duplicates) {
 		pickAtom();
 	}
-	
+
 	// Returns which atom to use
 	const ld::Atom& chosen() { return *_chosen; }
 	bool choseAtom(const ld::Atom& atom) { return _chosen == &atom; }
@@ -213,29 +213,29 @@
 	void pickAtom(const ld::Atom& atom) { _chosen = &atom; } // primitive to set which atom is picked
 	void pickAtomA() { pickAtom(_atomA); }	// primitive to pick atom A
 	void pickAtomB() { pickAtom(_atomB); }	// primitive to pick atom B
-	
+
 	// use atom A if pickA, otherwise use atom B
 	void pickAOrB(bool pickA) { if (pickA) pickAtomA(); else pickAtomB(); }
-	
+
 	void pickHigherOrdinal() {
 		pickAOrB(_atomA.file()->ordinal() < _atomB.file()->ordinal());
 	}
-	
+
 	void pickLowerOrdinal() {
 		pickAOrB(_atomA.file()->ordinal() > _atomB.file()->ordinal());
 	}
-	
+
 	void pickLargerSize() {
 		if (_atomA.size() == _atomB.size())
 			pickLowerOrdinal();
 		else
 			pickAOrB(_atomA.size() > _atomB.size());
 	}
-	
+
 	void pickGreaterAlignment() {
 		pickAOrB(_atomA.alignment().trailingZeros() > _atomB.alignment().trailingZeros());
 	}
-	
+
 	void pickBetweenRegularAtoms() {
 		if ( _atomA.combine() == ld::Atom::combineByName ) {
 			if ( _atomB.combine() == ld::Atom::combineByName ) {
@@ -283,10 +283,10 @@
 				// both are not-weak
 				if ( _atomA.section().type() == ld::Section::typeMachHeader ) {
 					pickAtomA();
-				} 
+				}
 				else if ( _atomB.section().type() == ld::Section::typeMachHeader ) {
 					pickAtomB();
-				} 
+				}
 				else {
 					switch (_duplicates) {
 						case Options::Treatment::kError:
@@ -306,7 +306,7 @@
 			}
 		}
 	}
-	
+
 	void pickCommonsMode(const ld::Atom& dylib, const ld::Atom& proxy) {
 		assert(dylib.definition() == ld::Atom::definitionTentative);
 		assert(proxy.definition() == ld::Atom::definitionProxy);
@@ -328,7 +328,7 @@
 					   proxy.name(), proxy.safeFilePath(), dylib.safeFilePath());
 		}
 	}
-	
+
 	void pickProxyAtom() {
 		// both atoms are definitionProxy
 		// <rdar://problem/5137732> ld should keep looking when it finds a weak definition in a dylib
@@ -340,7 +340,7 @@
 				throwf("symbol %s exported from both %s and %s\n", _atomA.name(), _atomA.safeFilePath(), _atomB.safeFilePath());
 		}
 	}
-	
+
 	void pickAtom() {
 		//fprintf(stderr, "pickAtom(), a=%p, def=%d, b=%p, def=%d\n", &_atomA, _atomA.definition(), &_atomB, _atomB.definition());
 		// First, discriminate by definition
@@ -352,7 +352,7 @@
 						break;
 					case ld::Atom::definitionTentative:
 						if ( _atomB.size() > _atomA.size() ) {
-							warning("tentative definition of '%s' with size %llu from '%s' is being replaced by real definition of smaller size %llu from '%s'",
+							warning("tentative definition of '%s' with size %lu from '%s' is being replaced by real definition of smaller size %lu from '%s'",
 									_atomA.name(), _atomB.size(), _atomB.safeFilePath(), _atomA.size(), _atomA.safeFilePath());
 						}
 						pickAtomA();
@@ -370,7 +370,7 @@
 				switch (_atomB.definition()) {
 					case ld::Atom::definitionRegular:
 						if ( _atomA.size() > _atomB.size() ) {
-							warning("tentative definition of '%s' with size %llu from '%s' is being replaced by real definition of smaller size %llu from '%s'",
+							warning("tentative definition of '%s' with size %lu from '%s' is being replaced by real definition of smaller size %lu from '%s'",
 									_atomA.name(), _atomA.size(),_atomA.safeFilePath(), _atomB.size(), _atomB.safeFilePath());
 						}
 						pickAtomB();
@@ -490,7 +490,7 @@
 	}
 	if ( useNew ) {
 		_indirectBindingTable[slot] = &newAtom;
-		if ( existingAtom != NULL ) 
+		if ( existingAtom != NULL )
 			markCoalescedAway(existingAtom);
 	}
 	else {
@@ -514,7 +514,7 @@
 	}
 	if ( useNew ) {
 		_indirectBindingTable[slot] = &newAtom;
-		if ( existingAtom != NULL ) 
+		if ( existingAtom != NULL )
 			markCoalescedAway(existingAtom);
 	}
 	else {
@@ -551,14 +551,14 @@
 	// remove this from list of all atoms used
 	//fprintf(stderr, "markCoalescedAway(%p) from %s\n", atom, atom->safeFilePath());
 	(const_cast<ld::Atom*>(atom))->setCoalescedAway();
-	
+
 	//
-	// The fixupNoneGroupSubordinate* fixup kind is used to model group comdat.  
+	// The fixupNoneGroupSubordinate* fixup kind is used to model group comdat.
 	// The "signature" atom in the group has a fixupNoneGroupSubordinate* fixup to
-	// all other members of the group.  So, if the signature atom is 
-	// coalesced away, all other atoms in the group should also be removed.  
+	// all other members of the group.  So, if the signature atom is
+	// coalesced away, all other atoms in the group should also be removed.
 	//
-	for (ld::Fixup::iterator fit=atom->fixupsBegin(), fend=atom->fixupsEnd(); fit != fend; ++fit) {	
+	for (ld::Fixup::iterator fit=atom->fixupsBegin(), fend=atom->fixupsEnd(); fit != fend; ++fit) {
 		switch ( fit->kind ) {
 			case ld::Fixup::kindNoneGroupSubordinate:
 			case ld::Fixup::kindNoneGroupSubordinateFDE:
@@ -622,19 +622,19 @@
 }
 
 
-bool SymbolTable::hasName(const char* name)			
-{ 
+bool SymbolTable::hasName(const char* name)
+{
 	NameToSlot::iterator pos = _byNameTable.find(name);
-	if ( pos == _byNameTable.end() ) 
+	if ( pos == _byNameTable.end() )
 		return false;
-	return (_indirectBindingTable[pos->second] != NULL); 
+	return (_indirectBindingTable[pos->second] != NULL);
 }
 
 // find existing or create new slot
 SymbolTable::IndirectBindingSlot SymbolTable::findSlotForName(const char* name)
 {
 	NameToSlot::iterator pos = _byNameTable.find(name);
-	if ( pos != _byNameTable.end() ) 
+	if ( pos != _byNameTable.end() )
 		return pos->second;
 	// create new slot for this name
 	SymbolTable::IndirectBindingSlot slot = _indirectBindingTable.size();
@@ -818,7 +818,7 @@
 		default:
 			assert(0 && "section type does not support coalescing by content");
 	}
-	_indirectBindingTable.push_back(atom); 
+	_indirectBindingTable.push_back(atom);
 	*existingAtom = NULL;
 	return slot;
 }
@@ -829,11 +829,11 @@
 SymbolTable::IndirectBindingSlot SymbolTable::findSlotForReferences(const ld::Atom* atom, const ld::Atom** existingAtom)
 {
 	//fprintf(stderr, "findSlotForReferences(%p)\n", atom);
-	
+
 	SymbolTable::IndirectBindingSlot slot = 0;
 	ReferencesToSlot::iterator pos;
 	switch ( atom->section().type() ) {
-		case ld::Section::typeNonLazyPointer:		
+		case ld::Section::typeNonLazyPointer:
 			pos = _nonLazyPointerTable.find(atom);
 			if ( pos != _nonLazyPointerTable.end() ) {
 				*existingAtom = _indirectBindingTable[pos->second];
@@ -945,7 +945,7 @@
 
 void SymbolTable::printStatistics()
 {
-//	fprintf(stderr, "cstring table size: %lu, bucket count: %lu, hash func called %u times\n", 
+//	fprintf(stderr, "cstring table size: %lu, bucket count: %lu, hash func called %u times\n",
 //				_cstringTable.size(), _cstringTable.bucket_count(), cstringHashCount);
 	int count[11];
 	for(unsigned int b=0; b < 11; ++b) {
@@ -953,7 +953,7 @@
 	}
 	for(unsigned int i=0; i < _cstringTable.bucket_count(); ++i) {
 		unsigned int n = _cstringTable.bucket_size(i);
-		if ( n < 10 ) 
+		if ( n < 10 )
 			count[n] += 1;
 		else
 			count[10] += 1;
@@ -964,21 +964,21 @@
 	}
 	fprintf(stderr, "indirect table size: %lu\n", _indirectBindingTable.size());
 	fprintf(stderr, "by-name table size: %lu\n", _byNameTable.size());
-//	fprintf(stderr, "by-content table size: %lu, hash count: %u, equals count: %u, lookup count: %u\n", 
+//	fprintf(stderr, "by-content table size: %lu, hash count: %u, equals count: %u, lookup count: %u\n",
 //						_byContentTable.size(), contentHashCount, contentEqualCount, contentLookupCount);
-//	fprintf(stderr, "by-ref table size: %lu, hashed count: %u, equals count: %u, lookup count: %u, insert count: %u\n", 
+//	fprintf(stderr, "by-ref table size: %lu, hashed count: %u, equals count: %u, lookup count: %u, insert count: %u\n",
 //						_byReferencesTable.size(), refHashCount, refEqualsCount, refLookupCount, refInsertCount);
 
 	//ReferencesHash obj;
 	//for(ReferencesHashToSlot::iterator it=_byReferencesTable.begin(); it != _byReferencesTable.end(); ++it) {
 	//	if ( obj.operator()(it->first) == 0x2F3AC0EAC744EA70 ) {
 	//		fprintf(stderr, "hash=0x2F3AC0EAC744EA70 for %p %s from %s\n", it->first, it->first->name(), it->first->safeFilePath());
-	//	
+	//
 	//	}
 	//}
-	
+
 }
 
-} // namespace tool 
-} // namespace ld 
+} // namespace tool
+} // namespace ld
 
